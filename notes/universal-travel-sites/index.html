<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Universal Travel Sites | My Web | Wei, Feng</title>
<meta name="keywords" content="FDS Homework">
<meta name="description" content="Universal Travel Sites After finishing her tour around the Earth, CYLL is now planning a universal travel sites development project. After a careful investigation, she has a list of capacities of all the satellite transportation stations in hand. To estimate a budget, she must know the minimum capacity that a planet station must have to guarantee that every space vessel can dock and download its passengers on arrival. Input Specification:">
<meta name="author" content="">
<link rel="canonical" href="https://novel2430.github.io/notes/universal-travel-sites/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.9c78afd72529c14d4d3c0fa583c3e82265e0d8a303d475223d3b37442260ba22.css" integrity="sha256-nHiv1yUpwU1NPA&#43;lg8PoImXg2KMD1HUiPTs3RCJguiI=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://novel2430.github.io/img/favicon/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://novel2430.github.io/img/favicon/favicon16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://novel2430.github.io/img/favicon/favicon32x32.png">
<link rel="apple-touch-icon" href="https://novel2430.github.io/img/favicon/apple-touch-icon.png">
<link rel="mask-icon" href="https://novel2430.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://novel2430.github.io/notes/universal-travel-sites/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:title" content="Universal Travel Sites" />
<meta property="og:description" content="Universal Travel Sites After finishing her tour around the Earth, CYLL is now planning a universal travel sites development project. After a careful investigation, she has a list of capacities of all the satellite transportation stations in hand. To estimate a budget, she must know the minimum capacity that a planet station must have to guarantee that every space vessel can dock and download its passengers on arrival. Input Specification:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://novel2430.github.io/notes/universal-travel-sites/" /><meta property="article:section" content="notes" />
<meta property="article:published_time" content="2024-02-14T01:12:56+08:00" />
<meta property="article:modified_time" content="2024-02-14T01:12:56+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Universal Travel Sites"/>
<meta name="twitter:description" content="Universal Travel Sites After finishing her tour around the Earth, CYLL is now planning a universal travel sites development project. After a careful investigation, she has a list of capacities of all the satellite transportation stations in hand. To estimate a budget, she must know the minimum capacity that a planet station must have to guarantee that every space vessel can dock and download its passengers on arrival. Input Specification:"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://novel2430.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Universal Travel Sites",
      "item": "https://novel2430.github.io/notes/universal-travel-sites/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Universal Travel Sites",
  "name": "Universal Travel Sites",
  "description": "Universal Travel Sites After finishing her tour around the Earth, CYLL is now planning a universal travel sites development project. After a careful investigation, she has a list of capacities of all the satellite transportation stations in hand. To estimate a budget, she must know the minimum capacity that a planet station must have to guarantee that every space vessel can dock and download its passengers on arrival. Input Specification:",
  "keywords": [
    "FDS Homework"
  ],
  "articleBody": "Universal Travel Sites After finishing her tour around the Earth, CYLL is now planning a universal travel sites development project. After a careful investigation, she has a list of capacities of all the satellite transportation stations in hand. To estimate a budget, she must know the minimum capacity that a planet station must have to guarantee that every space vessel can dock and download its passengers on arrival.\nInput Specification: Each input file contains one test case. For each case, the first line contains the names of the source and the destination planets, and a positive integer N (≤500). Then N lines follow, each in the format: source[i] destination[i] capacity[i] where source[i] and destination[i] are the names of the satellites and the two involved planets, and capacity[i] \u003e 0 is the maximum number of passengers that can be transported at one pass from source[i] to destination[i]. Each name is a string of 3 uppercase characters chosen from {A-Z}, e.g., ZJU. Note that the satellite transportation stations have no accommodation facilities for the passengers. Therefore none of the passengers can stay. Such a station will not allow arrivals of space vessels that contain more than its own capacity. It is guaranteed that the list contains neither the routes to the source planet nor that from the destination planet.\nOutput Specification: For each test case, just print in one line the minimum capacity that a planet station must have to guarantee that every space vessel can dock and download its passengers on arrival.\nSample Input: EAR MAR 11 EAR AAA 300 EAR BBB 400 AAA BBB 100 AAA CCC 400 AAA MAR 300 BBB DDD 400 AAA DDD 400 DDD AAA 100 CCC MAR 400 DDD CCC 200 DDD MAR 300 Sample Output: 700 Code Dinic // USING DINIC #include #include #include #define MAXN 2000 #define INF 0x3f3f3f3f typedef enum { FALSE, TRUE } boolean; typedef struct Graph{ int edge_num; int node_num; int flow[MAXN][MAXN]; char dict[MAXN][4]; }Graph ; typedef struct QueueNode{ int val; struct QueueNode* next; }QueueNode ; typedef struct Queue{ QueueNode* head; QueueNode* tail; }Queue ; QueueNode* queue_node_init(int val){ QueueNode* res = (QueueNode*)malloc(sizeof(QueueNode)); res-\u003eval = val; res-\u003enext = NULL; return res; } Queue* queue_init(){ Queue* res = (Queue*)malloc(sizeof(Queue)); res-\u003ehead = queue_node_init(0); res-\u003etail = res-\u003ehead; return res; } void queue_insert(Queue* queue, int val){ QueueNode* node = queue_node_init(val); queue-\u003etail-\u003enext = node; queue-\u003etail = node; queue-\u003ehead-\u003eval++; } int queue_pop(Queue* queue){ int res = -1; QueueNode* cur = queue-\u003ehead-\u003enext; if(cur!=NULL){ res = cur-\u003eval; queue-\u003ehead-\u003enext = cur-\u003enext; if(cur==queue-\u003etail){ queue-\u003etail = queue-\u003ehead; } free(cur); cur = NULL; queue-\u003ehead-\u003eval--; } return res; } void queue_delete(Queue* queue){ QueueNode* cur = queue-\u003ehead; while(cur!=NULL){ QueueNode* tmp = cur; cur = cur-\u003enext; free(tmp); tmp = NULL; } free(queue); queue = NULL; } boolean queue_is_empty(Queue* queue){ if(queue-\u003ehead==queue-\u003etail) return TRUE; return FALSE; } Graph* graph_init(char* start, char* end, int edge_num){ Graph* res = (Graph*)malloc(sizeof(Graph)); res-\u003eedge_num = 2; res-\u003enode_num = edge_num; memset(res-\u003eflow, 0, sizeof(res-\u003eflow)); strcpy(res-\u003edict[0], start); strcpy(res-\u003edict[1], end); return res; } void graph_insert_edge(Graph* graph, char* planet1, char* planet2, int weight){ int p1_idx = -1; int p2_idx = -1; for(int i=0; i\u003cgraph-\u003enode_num; i++){ if(strcmp(graph-\u003edict[i], planet1)==0){ p1_idx = i; } if(strcmp(graph-\u003edict[i], planet2)==0){ p2_idx = i; } } if(p1_idx==-1){ strcpy(graph-\u003edict[graph-\u003enode_num], planet1); p1_idx = graph-\u003enode_num; graph-\u003enode_num++; } if(p2_idx==-1){ strcpy(graph-\u003edict[graph-\u003enode_num], planet2); p2_idx = graph-\u003enode_num; graph-\u003enode_num++; } graph-\u003eflow[p1_idx][p2_idx] = weight; } int min(int a, int b){ if(a\u003eb) return b; return a; } int count_node_flow_sum(Graph* graph, int idx){ int res = 0; for(int i=0; i\u003cgraph-\u003enode_num; i++){ res += graph-\u003eflow[idx][i]; } return res; } void build_level_graph_bfs(int* level, Graph* graph){ Queue* queue = queue_init(); queue_insert(queue, 0); level[0] = 1; while(!queue_is_empty(queue)){ int cur_idx = queue_pop(queue); for(int i=0; i\u003cgraph-\u003enode_num; i++){ if(level[i]==0 \u0026\u0026 graph-\u003eflow[cur_idx][i]\u003e0){ queue_insert(queue, i); level[i] = level[cur_idx]+1; } } } queue_delete(queue); } int find_blocking_flow_dfs(Graph* graph, int* level, int cur_idx, int last_flow){ if(cur_idx==1){ // meet end return last_flow; } int res = 0; for(int i=0; i\u003cgraph-\u003enode_num; i++){ if(level[i]==level[cur_idx]+1 \u0026\u0026 graph-\u003eflow[cur_idx][i]\u003e0){ int flow = find_blocking_flow_dfs(graph, level, i, min(last_flow-res, graph-\u003eflow[cur_idx][i])); graph-\u003eflow[cur_idx][i] -= flow; graph-\u003eflow[i][cur_idx] += flow; res += flow; } } return res; } void dinic(Graph* graph){ int level[MAXN]; while(1){ // build level graph memset(level, 0, sizeof(level)); build_level_graph_bfs(level, graph); // find blocking flow in level graph // \u0026 // update residual graph if(!find_blocking_flow_dfs(graph, level, 0, INF)){ // No blocking flow then break break; } } } int main(int argc, char *argv[]){ char start[4]; char end[4]; int edge_num; scanf(\"%s %s %d\", start, end, \u0026edge_num); Graph* graph = graph_init(start, end, edge_num); for(int i=0; i\u003cedge_num; i++){ char planet1[4]; char planet2[4]; int capacity; scanf(\"%s %s %d\", planet1, planet2, \u0026capacity); graph_insert_edge(graph, planet1, planet2, capacity); } int before = count_node_flow_sum(graph, 0); dinic(graph); int after = count_node_flow_sum(graph, 0); printf(\"%d\\n\", before-after); return 0; } Code Ford Fulkerson #include #include #include #define MAXN 2000 #define INF 0x3f3f3f3f typedef enum { FALSE, TRUE } boolean; typedef struct Graph{ int edge_num; int node_num; int flow[MAXN][MAXN]; char dict[MAXN][4]; }Graph ; typedef struct QueueNode{ int val; struct QueueNode* next; }QueueNode ; typedef struct Queue{ QueueNode* head; QueueNode* tail; }Queue ; QueueNode* queue_node_init(int val){ QueueNode* res = (QueueNode*)malloc(sizeof(QueueNode)); res-\u003eval = val; res-\u003enext = NULL; return res; } Queue* queue_init(){ Queue* res = (Queue*)malloc(sizeof(Queue)); res-\u003ehead = queue_node_init(0); res-\u003etail = res-\u003ehead; return res; } void queue_insert(Queue* queue, int val){ QueueNode* node = queue_node_init(val); queue-\u003etail-\u003enext = node; queue-\u003etail = node; queue-\u003ehead-\u003eval++; } int queue_pop(Queue* queue){ int res = -1; QueueNode* cur = queue-\u003ehead-\u003enext; if(cur!=NULL){ res = cur-\u003eval; queue-\u003ehead-\u003enext = cur-\u003enext; if(cur==queue-\u003etail){ queue-\u003etail = queue-\u003ehead; } free(cur); cur = NULL; queue-\u003ehead-\u003eval--; } return res; } void queue_delete(Queue* queue){ QueueNode* cur = queue-\u003ehead; while(cur!=NULL){ QueueNode* tmp = cur; cur = cur-\u003enext; free(tmp); tmp = NULL; } free(queue); queue = NULL; } void queue_empty(Queue* queue){ QueueNode* cur = queue-\u003ehead-\u003enext; while(cur!=NULL){ QueueNode* tmp = cur; cur = cur-\u003enext; free(tmp); tmp = NULL; } queue-\u003etail = queue-\u003ehead; } boolean queue_is_empty(Queue* queue){ if(queue-\u003ehead==queue-\u003etail) return TRUE; return FALSE; } Graph* graph_init(char* start, char* end, int edge_num){ Graph* res = (Graph*)malloc(sizeof(Graph)); res-\u003eedge_num = 2; res-\u003enode_num = edge_num; memset(res-\u003eflow, 0, sizeof(res-\u003eflow)); strcpy(res-\u003edict[0], start); strcpy(res-\u003edict[1], end); return res; } void graph_insert_edge(Graph* graph, char* planet1, char* planet2, int weight){ int p1_idx = -1; int p2_idx = -1; for(int i=0; i\u003cgraph-\u003enode_num; i++){ if(strcmp(graph-\u003edict[i], planet1)==0){ p1_idx = i; } if(strcmp(graph-\u003edict[i], planet2)==0){ p2_idx = i; } } if(p1_idx==-1){ strcpy(graph-\u003edict[graph-\u003enode_num], planet1); p1_idx = graph-\u003enode_num; graph-\u003enode_num++; } if(p2_idx==-1){ strcpy(graph-\u003edict[graph-\u003enode_num], planet2); p2_idx = graph-\u003enode_num; graph-\u003enode_num++; } graph-\u003eflow[p1_idx][p2_idx] = weight; } int min(int a, int b){ if(a\u003eb) return b; return a; } boolean has_one_path_bfs(Graph* graph, Queue* queue, boolean* visit, int* path, int start, int end){ queue_insert(queue, start); while (!queue_is_empty(queue)) { int cur_idx = queue_pop(queue); visit[cur_idx] = TRUE; if(cur_idx==end) return TRUE; for(int i=0; i\u003cgraph-\u003enode_num; i++){ if(!visit[i] \u0026\u0026 graph-\u003eflow[cur_idx][i]\u003e0){ queue_insert(queue, i); path[i] = cur_idx; } } } return FALSE; } int update_one_path_residual_dfs(Graph* graph, int* path, int cur_idx, int end, int last_num){ if(cur_idx==end){ return last_num; } int next = path[cur_idx]; int min_flow = update_one_path_residual_dfs(graph, path, next, end, min(last_num, graph-\u003eflow[next][cur_idx])); graph-\u003eflow[next][cur_idx] -= min_flow; graph-\u003eflow[cur_idx][next] += min_flow; return min_flow; } void ford_fulkerson(Graph* graph){ Queue* queue = queue_init(); int path[MAXN]; for(int i=0; i\u003cgraph-\u003enode_num; i++) path[i] = i; boolean visit[MAXN]; memset(visit, FALSE, sizeof(visit)); int count = 0; while(has_one_path_bfs(graph, queue, visit, path, 0, 1)){ update_one_path_residual_dfs(graph, path, 1, 0, INF); for(int i=0; i\u003cgraph-\u003enode_num; i++) path[i] = i; queue_empty(queue); memset(visit, FALSE, sizeof(visit)); } queue_delete(queue); } int count_node_flow_sum(Graph* graph, int idx){ int res = 0; for(int i=0; i\u003cgraph-\u003enode_num; i++){ res += graph-\u003eflow[idx][i]; } return res; } int main(int argc, char *argv[]){ char start[4]; char end[4]; int edge_num; scanf(\"%s %s %d\", start, end, \u0026edge_num); Graph* graph = graph_init(start, end, edge_num); for(int i=0; i\u003cedge_num; i++){ char planet1[4]; char planet2[4]; int capacity; scanf(\"%s %s %d\", planet1, planet2, \u0026capacity); graph_insert_edge(graph, planet1, planet2, capacity); } int before = count_node_flow_sum(graph, 0); ford_fulkerson(graph); int after = count_node_flow_sum(graph, 0); printf(\"%d\\n\", before-after); return 0; } ",
  "wordCount" : "1264",
  "inLanguage": "en",
  "datePublished": "2024-02-14T01:12:56+08:00",
  "dateModified": "2024-02-14T01:12:56+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://novel2430.github.io/notes/universal-travel-sites/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "My Web | Wei, Feng",
    "logo": {
      "@type": "ImageObject",
      "url": "https://novel2430.github.io/img/favicon/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://novel2430.github.io/" accesskey="h" title="My Web | Wei, Feng (Alt + H)">My Web | Wei, Feng</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://novel2430.github.io/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://novel2430.github.io/ideas/" title="Ideas">
                    <span>Ideas</span>
                </a>
            </li>
            <li>
                <a href="https://novel2430.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://novel2430.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://novel2430.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://novel2430.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://novel2430.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://novel2430.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Universal Travel Sites
    </h1>
    <div class="post-meta"><span title='2024-02-14 01:12:56 +0800 CST'>February 14, 2024</span>&nbsp;·&nbsp;3 min

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#universal-travel-sites" aria-label="Universal Travel Sites">Universal Travel Sites</a><ul>
                            
                    <li>
                        <a href="#input-specification" aria-label="Input Specification:">Input Specification:</a></li>
                    <li>
                        <a href="#output-specification" aria-label="Output Specification:">Output Specification:</a></li>
                    <li>
                        <a href="#sample-input" aria-label="Sample Input:">Sample Input:</a></li>
                    <li>
                        <a href="#sample-output" aria-label="Sample Output:">Sample Output:</a></li>
                    <li>
                        <a href="#code-dinic" aria-label="Code Dinic">Code Dinic</a></li>
                    <li>
                        <a href="#code-ford-fulkerson" aria-label="Code Ford Fulkerson">Code Ford Fulkerson</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h1 id="universal-travel-sites">Universal Travel Sites<a hidden class="anchor" aria-hidden="true" href="#universal-travel-sites">#</a></h1>
<p>After finishing her tour around the Earth, CYLL is now planning a universal travel sites development project. After a careful investigation, she has a list of capacities of all the satellite transportation stations in hand. To estimate a budget, she must know the minimum capacity that a planet station must have to guarantee that every space vessel can dock and download its passengers on arrival.</p>
<h2 id="input-specification">Input Specification:<a hidden class="anchor" aria-hidden="true" href="#input-specification">#</a></h2>
<p>Each input file contains one test case. For each case, the first line contains the names of the source and the destination planets, and a positive integer N (≤500). Then N lines follow, each in the format: <code>source[i]</code> <code>destination[i]</code> <code>capacity[i]</code> where <code>source[i]</code> and <code>destination[i]</code> are the names of the satellites and the two involved planets, and <code>capacity[i]</code> &gt; 0 is the maximum number of passengers that can be transported at one pass from <code>source[i]</code> to <code>destination[i]</code>. Each name is a string of 3 uppercase characters chosen from {A-Z}, e.g., ZJU.
Note that the satellite transportation stations have no accommodation facilities for the passengers. Therefore none of the passengers can stay. Such a station will not allow arrivals of space vessels that contain more than its own capacity. It is guaranteed that the list contains neither the routes to the source planet nor that from the destination planet.</p>
<h2 id="output-specification">Output Specification:<a hidden class="anchor" aria-hidden="true" href="#output-specification">#</a></h2>
<p>For each test case, just print in one line the minimum capacity that a planet station must have to guarantee that every space vessel can dock and download its passengers on arrival.</p>
<h2 id="sample-input">Sample Input:<a hidden class="anchor" aria-hidden="true" href="#sample-input">#</a></h2>
<pre tabindex="0"><code>EAR MAR 11
EAR AAA 300
EAR BBB 400
AAA BBB 100
AAA CCC 400
AAA MAR 300
BBB DDD 400
AAA DDD 400
DDD AAA 100
CCC MAR 400
DDD CCC 200
DDD MAR 300
</code></pre><h2 id="sample-output">Sample Output:<a hidden class="anchor" aria-hidden="true" href="#sample-output">#</a></h2>
<pre tabindex="0"><code>700
</code></pre><h2 id="code-dinic">Code Dinic<a hidden class="anchor" aria-hidden="true" href="#code-dinic">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// USING DINIC
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAXN 2000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define INF 0x3f3f3f3f
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">enum</span> { FALSE, TRUE } boolean;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Graph{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> edge_num;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> node_num;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> flow[MAXN][MAXN];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> dict[MAXN][<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>}Graph ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> QueueNode{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> val;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> QueueNode<span style="color:#f92672">*</span> next;
</span></span><span style="display:flex;"><span>}QueueNode ;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Queue{
</span></span><span style="display:flex;"><span>  QueueNode<span style="color:#f92672">*</span> head;
</span></span><span style="display:flex;"><span>  QueueNode<span style="color:#f92672">*</span> tail;
</span></span><span style="display:flex;"><span>}Queue ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>QueueNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">queue_node_init</span>(<span style="color:#66d9ef">int</span> val){
</span></span><span style="display:flex;"><span>  QueueNode<span style="color:#f92672">*</span> res <span style="color:#f92672">=</span> (QueueNode<span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(QueueNode));
</span></span><span style="display:flex;"><span>  res<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">=</span> val;
</span></span><span style="display:flex;"><span>  res<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>Queue<span style="color:#f92672">*</span> <span style="color:#a6e22e">queue_init</span>(){
</span></span><span style="display:flex;"><span>  Queue<span style="color:#f92672">*</span> res <span style="color:#f92672">=</span> (Queue<span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(Queue));
</span></span><span style="display:flex;"><span>  res<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> <span style="color:#a6e22e">queue_node_init</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  res<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> res<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">queue_insert</span>(Queue<span style="color:#f92672">*</span> queue, <span style="color:#66d9ef">int</span> val){
</span></span><span style="display:flex;"><span>  QueueNode<span style="color:#f92672">*</span> node <span style="color:#f92672">=</span> <span style="color:#a6e22e">queue_node_init</span>(val);
</span></span><span style="display:flex;"><span>  queue<span style="color:#f92672">-&gt;</span>tail<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> node; 
</span></span><span style="display:flex;"><span>  queue<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>  queue<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">-&gt;</span>val<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">queue_pop</span>(Queue<span style="color:#f92672">*</span> queue){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  QueueNode<span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> queue<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(cur<span style="color:#f92672">!=</span>NULL){
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>val;
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(cur<span style="color:#f92672">==</span>queue<span style="color:#f92672">-&gt;</span>tail){
</span></span><span style="display:flex;"><span>      queue<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> queue<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(cur);
</span></span><span style="display:flex;"><span>    cur <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">-&gt;</span>val<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">queue_delete</span>(Queue<span style="color:#f92672">*</span> queue){
</span></span><span style="display:flex;"><span>  QueueNode<span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> queue<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(cur<span style="color:#f92672">!=</span>NULL){
</span></span><span style="display:flex;"><span>    QueueNode<span style="color:#f92672">*</span> tmp <span style="color:#f92672">=</span> cur;
</span></span><span style="display:flex;"><span>    cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(tmp);
</span></span><span style="display:flex;"><span>    tmp <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">free</span>(queue);
</span></span><span style="display:flex;"><span>  queue <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>boolean <span style="color:#a6e22e">queue_is_empty</span>(Queue<span style="color:#f92672">*</span> queue){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(queue<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">==</span>queue<span style="color:#f92672">-&gt;</span>tail) <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Graph<span style="color:#f92672">*</span> <span style="color:#a6e22e">graph_init</span>(<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> start, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> end, <span style="color:#66d9ef">int</span> edge_num){
</span></span><span style="display:flex;"><span>  Graph<span style="color:#f92672">*</span> res <span style="color:#f92672">=</span> (Graph<span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(Graph));
</span></span><span style="display:flex;"><span>  res<span style="color:#f92672">-&gt;</span>edge_num <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>  res<span style="color:#f92672">-&gt;</span>node_num <span style="color:#f92672">=</span> edge_num;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">memset</span>(res<span style="color:#f92672">-&gt;</span>flow, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(res<span style="color:#f92672">-&gt;</span>flow));
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">strcpy</span>(res<span style="color:#f92672">-&gt;</span>dict[<span style="color:#ae81ff">0</span>], start);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">strcpy</span>(res<span style="color:#f92672">-&gt;</span>dict[<span style="color:#ae81ff">1</span>], end);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">graph_insert_edge</span>(Graph<span style="color:#f92672">*</span> graph, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> planet1, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> planet2, <span style="color:#66d9ef">int</span> weight){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> p1_idx <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> p2_idx <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>graph<span style="color:#f92672">-&gt;</span>node_num; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">strcmp</span>(graph<span style="color:#f92672">-&gt;</span>dict[i], planet1)<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>      p1_idx <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">strcmp</span>(graph<span style="color:#f92672">-&gt;</span>dict[i], planet2)<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>      p2_idx <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(p1_idx<span style="color:#f92672">==-</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">strcpy</span>(graph<span style="color:#f92672">-&gt;</span>dict[graph<span style="color:#f92672">-&gt;</span>node_num], planet1);
</span></span><span style="display:flex;"><span>    p1_idx <span style="color:#f92672">=</span> graph<span style="color:#f92672">-&gt;</span>node_num;
</span></span><span style="display:flex;"><span>    graph<span style="color:#f92672">-&gt;</span>node_num<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(p2_idx<span style="color:#f92672">==-</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">strcpy</span>(graph<span style="color:#f92672">-&gt;</span>dict[graph<span style="color:#f92672">-&gt;</span>node_num], planet2);
</span></span><span style="display:flex;"><span>    p2_idx <span style="color:#f92672">=</span> graph<span style="color:#f92672">-&gt;</span>node_num;
</span></span><span style="display:flex;"><span>    graph<span style="color:#f92672">-&gt;</span>node_num<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  graph<span style="color:#f92672">-&gt;</span>flow[p1_idx][p2_idx] <span style="color:#f92672">=</span> weight;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">min</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(a<span style="color:#f92672">&gt;</span>b) <span style="color:#66d9ef">return</span> b;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> a;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">count_node_flow_sum</span>(Graph<span style="color:#f92672">*</span> graph, <span style="color:#66d9ef">int</span> idx){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>graph<span style="color:#f92672">-&gt;</span>node_num; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">+=</span> graph<span style="color:#f92672">-&gt;</span>flow[idx][i];
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">build_level_graph_bfs</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> level, Graph<span style="color:#f92672">*</span> graph){
</span></span><span style="display:flex;"><span>  Queue<span style="color:#f92672">*</span> queue <span style="color:#f92672">=</span> <span style="color:#a6e22e">queue_init</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">queue_insert</span>(queue, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  level[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">queue_is_empty</span>(queue)){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> cur_idx <span style="color:#f92672">=</span> <span style="color:#a6e22e">queue_pop</span>(queue);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>graph<span style="color:#f92672">-&gt;</span>node_num; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span>(level[i]<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> graph<span style="color:#f92672">-&gt;</span>flow[cur_idx][i]<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">queue_insert</span>(queue, i);
</span></span><span style="display:flex;"><span>        level[i] <span style="color:#f92672">=</span> level[cur_idx]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>; 
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">queue_delete</span>(queue);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find_blocking_flow_dfs</span>(Graph<span style="color:#f92672">*</span> graph, <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> level, <span style="color:#66d9ef">int</span> cur_idx, <span style="color:#66d9ef">int</span> last_flow){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(cur_idx<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// meet end
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> last_flow;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>graph<span style="color:#f92672">-&gt;</span>node_num; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(level[i]<span style="color:#f92672">==</span>level[cur_idx]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> graph<span style="color:#f92672">-&gt;</span>flow[cur_idx][i]<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">int</span> flow <span style="color:#f92672">=</span> <span style="color:#a6e22e">find_blocking_flow_dfs</span>(graph, level, i, <span style="color:#a6e22e">min</span>(last_flow<span style="color:#f92672">-</span>res, graph<span style="color:#f92672">-&gt;</span>flow[cur_idx][i]));
</span></span><span style="display:flex;"><span>      graph<span style="color:#f92672">-&gt;</span>flow[cur_idx][i] <span style="color:#f92672">-=</span> flow;
</span></span><span style="display:flex;"><span>      graph<span style="color:#f92672">-&gt;</span>flow[i][cur_idx] <span style="color:#f92672">+=</span> flow;
</span></span><span style="display:flex;"><span>      res <span style="color:#f92672">+=</span> flow;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dinic</span>(Graph<span style="color:#f92672">*</span> graph){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> level[MAXN];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// build level graph
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">memset</span>(level, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(level));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">build_level_graph_bfs</span>(level, graph);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// find blocking flow in level graph
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// &amp;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// update residual graph
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">find_blocking_flow_dfs</span>(graph, level, <span style="color:#ae81ff">0</span>, INF)){
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// No blocking flow then break
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> start[<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> end[<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> edge_num;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%s %s %d&#34;</span>, start, end, <span style="color:#f92672">&amp;</span>edge_num);
</span></span><span style="display:flex;"><span>  Graph<span style="color:#f92672">*</span> graph <span style="color:#f92672">=</span> <span style="color:#a6e22e">graph_init</span>(start, end, edge_num);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>edge_num; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> planet1[<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> planet2[<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> capacity;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%s %s %d&#34;</span>, planet1, planet2, <span style="color:#f92672">&amp;</span>capacity);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">graph_insert_edge</span>(graph, planet1, planet2, capacity);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> before <span style="color:#f92672">=</span> <span style="color:#a6e22e">count_node_flow_sum</span>(graph, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">dinic</span>(graph);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> after <span style="color:#f92672">=</span> <span style="color:#a6e22e">count_node_flow_sum</span>(graph, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, before<span style="color:#f92672">-</span>after);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="code-ford-fulkerson">Code Ford Fulkerson<a hidden class="anchor" aria-hidden="true" href="#code-ford-fulkerson">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAXN 2000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define INF 0x3f3f3f3f
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">enum</span> { FALSE, TRUE } boolean;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Graph{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> edge_num;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> node_num;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> flow[MAXN][MAXN];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> dict[MAXN][<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>}Graph ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> QueueNode{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> val;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> QueueNode<span style="color:#f92672">*</span> next;
</span></span><span style="display:flex;"><span>}QueueNode ;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Queue{
</span></span><span style="display:flex;"><span>  QueueNode<span style="color:#f92672">*</span> head;
</span></span><span style="display:flex;"><span>  QueueNode<span style="color:#f92672">*</span> tail;
</span></span><span style="display:flex;"><span>}Queue ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>QueueNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">queue_node_init</span>(<span style="color:#66d9ef">int</span> val){
</span></span><span style="display:flex;"><span>  QueueNode<span style="color:#f92672">*</span> res <span style="color:#f92672">=</span> (QueueNode<span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(QueueNode));
</span></span><span style="display:flex;"><span>  res<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">=</span> val;
</span></span><span style="display:flex;"><span>  res<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>Queue<span style="color:#f92672">*</span> <span style="color:#a6e22e">queue_init</span>(){
</span></span><span style="display:flex;"><span>  Queue<span style="color:#f92672">*</span> res <span style="color:#f92672">=</span> (Queue<span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(Queue));
</span></span><span style="display:flex;"><span>  res<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> <span style="color:#a6e22e">queue_node_init</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  res<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> res<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">queue_insert</span>(Queue<span style="color:#f92672">*</span> queue, <span style="color:#66d9ef">int</span> val){
</span></span><span style="display:flex;"><span>  QueueNode<span style="color:#f92672">*</span> node <span style="color:#f92672">=</span> <span style="color:#a6e22e">queue_node_init</span>(val);
</span></span><span style="display:flex;"><span>  queue<span style="color:#f92672">-&gt;</span>tail<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> node; 
</span></span><span style="display:flex;"><span>  queue<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>  queue<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">-&gt;</span>val<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">queue_pop</span>(Queue<span style="color:#f92672">*</span> queue){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  QueueNode<span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> queue<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(cur<span style="color:#f92672">!=</span>NULL){
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>val;
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(cur<span style="color:#f92672">==</span>queue<span style="color:#f92672">-&gt;</span>tail){
</span></span><span style="display:flex;"><span>      queue<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> queue<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(cur);
</span></span><span style="display:flex;"><span>    cur <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">-&gt;</span>val<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">queue_delete</span>(Queue<span style="color:#f92672">*</span> queue){
</span></span><span style="display:flex;"><span>  QueueNode<span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> queue<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(cur<span style="color:#f92672">!=</span>NULL){
</span></span><span style="display:flex;"><span>    QueueNode<span style="color:#f92672">*</span> tmp <span style="color:#f92672">=</span> cur;
</span></span><span style="display:flex;"><span>    cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(tmp);
</span></span><span style="display:flex;"><span>    tmp <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">free</span>(queue);
</span></span><span style="display:flex;"><span>  queue <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">queue_empty</span>(Queue<span style="color:#f92672">*</span> queue){
</span></span><span style="display:flex;"><span>  QueueNode<span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> queue<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(cur<span style="color:#f92672">!=</span>NULL){
</span></span><span style="display:flex;"><span>    QueueNode<span style="color:#f92672">*</span> tmp <span style="color:#f92672">=</span> cur;
</span></span><span style="display:flex;"><span>    cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(tmp);
</span></span><span style="display:flex;"><span>    tmp <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  queue<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> queue<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>boolean <span style="color:#a6e22e">queue_is_empty</span>(Queue<span style="color:#f92672">*</span> queue){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(queue<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">==</span>queue<span style="color:#f92672">-&gt;</span>tail) <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Graph<span style="color:#f92672">*</span> <span style="color:#a6e22e">graph_init</span>(<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> start, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> end, <span style="color:#66d9ef">int</span> edge_num){
</span></span><span style="display:flex;"><span>  Graph<span style="color:#f92672">*</span> res <span style="color:#f92672">=</span> (Graph<span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(Graph));
</span></span><span style="display:flex;"><span>  res<span style="color:#f92672">-&gt;</span>edge_num <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>  res<span style="color:#f92672">-&gt;</span>node_num <span style="color:#f92672">=</span> edge_num;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">memset</span>(res<span style="color:#f92672">-&gt;</span>flow, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(res<span style="color:#f92672">-&gt;</span>flow));
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">strcpy</span>(res<span style="color:#f92672">-&gt;</span>dict[<span style="color:#ae81ff">0</span>], start);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">strcpy</span>(res<span style="color:#f92672">-&gt;</span>dict[<span style="color:#ae81ff">1</span>], end);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">graph_insert_edge</span>(Graph<span style="color:#f92672">*</span> graph, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> planet1, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> planet2, <span style="color:#66d9ef">int</span> weight){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> p1_idx <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> p2_idx <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>graph<span style="color:#f92672">-&gt;</span>node_num; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">strcmp</span>(graph<span style="color:#f92672">-&gt;</span>dict[i], planet1)<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>      p1_idx <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">strcmp</span>(graph<span style="color:#f92672">-&gt;</span>dict[i], planet2)<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>      p2_idx <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(p1_idx<span style="color:#f92672">==-</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">strcpy</span>(graph<span style="color:#f92672">-&gt;</span>dict[graph<span style="color:#f92672">-&gt;</span>node_num], planet1);
</span></span><span style="display:flex;"><span>    p1_idx <span style="color:#f92672">=</span> graph<span style="color:#f92672">-&gt;</span>node_num;
</span></span><span style="display:flex;"><span>    graph<span style="color:#f92672">-&gt;</span>node_num<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(p2_idx<span style="color:#f92672">==-</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">strcpy</span>(graph<span style="color:#f92672">-&gt;</span>dict[graph<span style="color:#f92672">-&gt;</span>node_num], planet2);
</span></span><span style="display:flex;"><span>    p2_idx <span style="color:#f92672">=</span> graph<span style="color:#f92672">-&gt;</span>node_num;
</span></span><span style="display:flex;"><span>    graph<span style="color:#f92672">-&gt;</span>node_num<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  graph<span style="color:#f92672">-&gt;</span>flow[p1_idx][p2_idx] <span style="color:#f92672">=</span> weight;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">min</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(a<span style="color:#f92672">&gt;</span>b) <span style="color:#66d9ef">return</span> b;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> a;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>boolean <span style="color:#a6e22e">has_one_path_bfs</span>(Graph<span style="color:#f92672">*</span> graph, Queue<span style="color:#f92672">*</span> queue, boolean<span style="color:#f92672">*</span> visit, <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> path, <span style="color:#66d9ef">int</span> start, <span style="color:#66d9ef">int</span> end){
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">queue_insert</span>(queue, start);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">queue_is_empty</span>(queue)) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> cur_idx <span style="color:#f92672">=</span> <span style="color:#a6e22e">queue_pop</span>(queue);
</span></span><span style="display:flex;"><span>    visit[cur_idx] <span style="color:#f92672">=</span> TRUE;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(cur_idx<span style="color:#f92672">==</span>end) <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>graph<span style="color:#f92672">-&gt;</span>node_num; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>visit[i] <span style="color:#f92672">&amp;&amp;</span> graph<span style="color:#f92672">-&gt;</span>flow[cur_idx][i]<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">queue_insert</span>(queue, i);
</span></span><span style="display:flex;"><span>        path[i] <span style="color:#f92672">=</span> cur_idx;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">update_one_path_residual_dfs</span>(Graph<span style="color:#f92672">*</span> graph, <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> path, <span style="color:#66d9ef">int</span> cur_idx, <span style="color:#66d9ef">int</span> end, <span style="color:#66d9ef">int</span> last_num){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(cur_idx<span style="color:#f92672">==</span>end){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> last_num;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> next <span style="color:#f92672">=</span> path[cur_idx];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> min_flow <span style="color:#f92672">=</span> <span style="color:#a6e22e">update_one_path_residual_dfs</span>(graph, path, next, end, <span style="color:#a6e22e">min</span>(last_num, graph<span style="color:#f92672">-&gt;</span>flow[next][cur_idx]));
</span></span><span style="display:flex;"><span>  graph<span style="color:#f92672">-&gt;</span>flow[next][cur_idx] <span style="color:#f92672">-=</span> min_flow;
</span></span><span style="display:flex;"><span>  graph<span style="color:#f92672">-&gt;</span>flow[cur_idx][next] <span style="color:#f92672">+=</span> min_flow;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> min_flow;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ford_fulkerson</span>(Graph<span style="color:#f92672">*</span> graph){
</span></span><span style="display:flex;"><span>  Queue<span style="color:#f92672">*</span> queue <span style="color:#f92672">=</span> <span style="color:#a6e22e">queue_init</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> path[MAXN];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>graph<span style="color:#f92672">-&gt;</span>node_num; i<span style="color:#f92672">++</span>) path[i] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>  boolean visit[MAXN];
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">memset</span>(visit, FALSE, <span style="color:#66d9ef">sizeof</span>(visit));
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(<span style="color:#a6e22e">has_one_path_bfs</span>(graph, queue, visit, path, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>)){
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">update_one_path_residual_dfs</span>(graph, path, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, INF);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>graph<span style="color:#f92672">-&gt;</span>node_num; i<span style="color:#f92672">++</span>) path[i] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">queue_empty</span>(queue);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>(visit, FALSE, <span style="color:#66d9ef">sizeof</span>(visit));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">queue_delete</span>(queue);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">count_node_flow_sum</span>(Graph<span style="color:#f92672">*</span> graph, <span style="color:#66d9ef">int</span> idx){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>graph<span style="color:#f92672">-&gt;</span>node_num; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">+=</span> graph<span style="color:#f92672">-&gt;</span>flow[idx][i];
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> start[<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> end[<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> edge_num;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%s %s %d&#34;</span>, start, end, <span style="color:#f92672">&amp;</span>edge_num);
</span></span><span style="display:flex;"><span>  Graph<span style="color:#f92672">*</span> graph <span style="color:#f92672">=</span> <span style="color:#a6e22e">graph_init</span>(start, end, edge_num);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>edge_num; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> planet1[<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> planet2[<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> capacity;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%s %s %d&#34;</span>, planet1, planet2, <span style="color:#f92672">&amp;</span>capacity);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">graph_insert_edge</span>(graph, planet1, planet2, capacity);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> before <span style="color:#f92672">=</span> <span style="color:#a6e22e">count_node_flow_sum</span>(graph, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">ford_fulkerson</span>(graph);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> after <span style="color:#f92672">=</span> <span style="color:#a6e22e">count_node_flow_sum</span>(graph, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, before<span style="color:#f92672">-</span>after);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://novel2430.github.io/tags/fds-homework/">FDS Homework</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://novel2430.github.io/">My Web | Wei, Feng</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
