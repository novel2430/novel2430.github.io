<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Queue Using Two Stacks | My Web | Wei, Feng</title>
<meta name="keywords" content="FDS Homework">
<meta name="description" content="7-1 Queue Using Two Stacks A queue (FIFO structure) can be implemented by two stacks (LIFO structure) in the following way: Start from two empty stacks s1 and s2 When element e is enqueued, it is actually pushed onto s1 When we are supposed to dequeue, s2 is checked first. If s2 is empty, everything in s1 will be transferred to s2 by popping from s1 and immediately pushing onto">
<meta name="author" content="">
<link rel="canonical" href="https://novel2430.github.io/notes/queue-using-two-stacks/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.9c78afd72529c14d4d3c0fa583c3e82265e0d8a303d475223d3b37442260ba22.css" integrity="sha256-nHiv1yUpwU1NPA&#43;lg8PoImXg2KMD1HUiPTs3RCJguiI=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://novel2430.github.io/img/favicon/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://novel2430.github.io/img/favicon/favicon16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://novel2430.github.io/img/favicon/favicon32x32.png">
<link rel="apple-touch-icon" href="https://novel2430.github.io/img/favicon/apple-touch-icon.png">
<link rel="mask-icon" href="https://novel2430.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://novel2430.github.io/notes/queue-using-two-stacks/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:title" content="Queue Using Two Stacks" />
<meta property="og:description" content="7-1 Queue Using Two Stacks A queue (FIFO structure) can be implemented by two stacks (LIFO structure) in the following way: Start from two empty stacks s1 and s2 When element e is enqueued, it is actually pushed onto s1 When we are supposed to dequeue, s2 is checked first. If s2 is empty, everything in s1 will be transferred to s2 by popping from s1 and immediately pushing onto" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://novel2430.github.io/notes/queue-using-two-stacks/" /><meta property="article:section" content="notes" />
<meta property="article:published_time" content="2024-02-14T01:46:47+08:00" />
<meta property="article:modified_time" content="2024-02-14T01:46:47+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Queue Using Two Stacks"/>
<meta name="twitter:description" content="7-1 Queue Using Two Stacks A queue (FIFO structure) can be implemented by two stacks (LIFO structure) in the following way: Start from two empty stacks s1 and s2 When element e is enqueued, it is actually pushed onto s1 When we are supposed to dequeue, s2 is checked first. If s2 is empty, everything in s1 will be transferred to s2 by popping from s1 and immediately pushing onto"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://novel2430.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Queue Using Two Stacks",
      "item": "https://novel2430.github.io/notes/queue-using-two-stacks/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Queue Using Two Stacks",
  "name": "Queue Using Two Stacks",
  "description": "7-1 Queue Using Two Stacks A queue (FIFO structure) can be implemented by two stacks (LIFO structure) in the following way: Start from two empty stacks s1 and s2 When element e is enqueued, it is actually pushed onto s1 When we are supposed to dequeue, s2 is checked first. If s2 is empty, everything in s1 will be transferred to s2 by popping from s1 and immediately pushing onto",
  "keywords": [
    "FDS Homework"
  ],
  "articleBody": "7-1 Queue Using Two Stacks A queue (FIFO structure) can be implemented by two stacks (LIFO structure) in the following way:\nStart from two empty stacks s1 and s2\nWhen element e is enqueued, it is actually pushed onto s1\nWhen we are supposed to dequeue, s2 is checked first. If s2 is empty, everything in s1 will be transferred to s2 by popping from s1 and immediately pushing onto s2. Then we just pop from s2 – the top element of s2 must be the first one to enter s1 thus is the first element that was enqueued.\nAssume that each operation of push or pop takes 1 unit of time. You job is to tell the time taken for each dequeue.\nInput Specification: Each input file contains one test case. For each case, the first line gives a positive integer N (≤103), which are the number of operations. Then N lines follow, each gives an operation in the format\nOperation Element where Operation being I represents enqueue and O represents dequeue. For each I, Element is a positive integer that is no more than 106. No Element is given for O operations.\nIt is guaranteed that there is at least one O operation.\nOutput Specification: For each dequeue operation, print in a line the dequeued element and the unites of time taken to do this dequeue. The numbers in a line must be separated by 1 space, and there must be no extra space at the beginning or the end of the line.\nIn case that the queue is empty when dequeue is called, output in a line ERROR instead.\nSample Input: 10 I 20 I 32 O I 11 O O O I 100 I 66 O Sample Output: 20 5 32 1 11 3 ERROR 100 5 Code #include #include // Basic Struct typedef struct stack_node{ int values; struct stack_node* next; struct stack_node* before; }stack_node; typedef struct my_stack { stack_node* head; stack_node* top; }my_stack; typedef struct my_queue { my_stack* stack1; my_stack* stack2; int op_count; }my_queue; // Node op stack_node* node_init(int num){ stack_node* node = (stack_node*)malloc(sizeof(stack_node)); node-\u003evalues = num; node-\u003enext = NULL; node-\u003ebefore = NULL; return node; } void node_delete(stack_node* node){ if(node==NULL) return; free(node); node = NULL; } // Stack op my_stack* stack_init(){ my_stack* res = (my_stack*)malloc(sizeof(my_stack)); res-\u003ehead = node_init(0); res-\u003etop = res-\u003ehead; return res; } void stack_delete(my_stack* stack){ if(stack==NULL) return; stack_node* cur = stack-\u003ehead; while(cur != NULL){ stack_node* next_node = cur-\u003enext; node_delete(cur); cur = next_node; } free(stack); stack = NULL; } void stack_push(my_stack* stack, int num){ stack-\u003ehead-\u003evalues++; stack_node* node = node_init(num); stack-\u003etop-\u003enext = node; node-\u003ebefore = stack-\u003etop; stack-\u003etop = node; } int stack_pop(my_stack* stack){ stack-\u003ehead-\u003evalues--; int res = stack-\u003etop-\u003evalues; stack_node* old_top = stack-\u003etop; stack_node* new_top = stack-\u003etop-\u003ebefore; node_delete(old_top); stack-\u003etop = new_top; stack-\u003etop-\u003enext = NULL; return res; } int stack_is_empty(my_stack* stack){ if(stack==NULL || stack-\u003ehead!=stack-\u003etop){ return 0; } return 1; } // Queue op my_queue* queue_init(){ my_queue* res = (my_queue*)malloc(sizeof(my_queue)); res-\u003estack1 = stack_init(); res-\u003estack2 = stack_init(); res-\u003eop_count = 0; return res; } void queue_delete(my_queue* queue){ if(queue == NULL) return; stack_delete(queue-\u003estack1); stack_delete(queue-\u003estack2); free(queue); queue = NULL; } void queue_push(my_queue* queue, int num){ stack_push(queue-\u003estack1, num); } int queue_pop(my_queue* queue){ queue-\u003eop_count = 0; if(stack_is_empty(queue-\u003estack1) \u0026\u0026 stack_is_empty(queue-\u003estack2)) return -1; if(stack_is_empty(queue-\u003estack2)){ queue-\u003eop_count = queue-\u003estack1-\u003ehead-\u003evalues*2; while(!stack_is_empty(queue-\u003estack1)){ stack_push(queue-\u003estack2, stack_pop(queue-\u003estack1)); } } queue-\u003eop_count++; return stack_pop(queue-\u003estack2); } int main(){ int op_counts = 0; my_queue* queue = queue_init(); scanf(\"%d\", \u0026op_counts); int print_count = 0; for(int i=0; i\u003cop_counts; i++){ /* printf(\"Time : %d\\n\",i); */ getchar(); char op; scanf(\"%c\", \u0026op); if(op=='I'){ int num; scanf(\"%d\", \u0026num); queue_push(queue, num); } else if(op=='O'){ int num = queue_pop(queue); if(num==-1){ if(print_count\u003e0) printf(\"\\nERROR\"); else printf(\"ERROR\"); } else { if(print_count\u003e0) printf(\"\\n%d %d\",num, queue-\u003eop_count); else printf(\"%d %d\",num, queue-\u003eop_count); } print_count++; } } queue_delete(queue); return 0; } ",
  "wordCount" : "616",
  "inLanguage": "en",
  "datePublished": "2024-02-14T01:46:47+08:00",
  "dateModified": "2024-02-14T01:46:47+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://novel2430.github.io/notes/queue-using-two-stacks/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "My Web | Wei, Feng",
    "logo": {
      "@type": "ImageObject",
      "url": "https://novel2430.github.io/img/favicon/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://novel2430.github.io/" accesskey="h" title="My Web | Wei, Feng (Alt + H)">My Web | Wei, Feng</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://novel2430.github.io/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://novel2430.github.io/ideas/" title="Ideas">
                    <span>Ideas</span>
                </a>
            </li>
            <li>
                <a href="https://novel2430.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://novel2430.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://novel2430.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://novel2430.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://novel2430.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://novel2430.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Queue Using Two Stacks
    </h1>
    <div class="post-meta"><span title='2024-02-14 01:46:47 +0800 CST'>February 14, 2024</span>&nbsp;·&nbsp;2 min

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#7-1-queue-using-two-stacks" aria-label="7-1 Queue Using Two Stacks">7-1 Queue Using Two Stacks</a><ul>
                            
                    <li>
                        <a href="#input-specification" aria-label="Input Specification:">Input Specification:</a></li>
                    <li>
                        <a href="#output-specification" aria-label="Output Specification:">Output Specification:</a></li>
                    <li>
                        <a href="#sample-input" aria-label="Sample Input:">Sample Input:</a></li>
                    <li>
                        <a href="#sample-output" aria-label="Sample Output:">Sample Output:</a></li>
                    <li>
                        <a href="#code" aria-label="Code">Code</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h1 id="7-1-queue-using-two-stacks">7-1 Queue Using Two Stacks<a hidden class="anchor" aria-hidden="true" href="#7-1-queue-using-two-stacks">#</a></h1>
<p>A queue (FIFO structure) can be implemented by two stacks (LIFO structure) in the following way:</p>
<ol>
<li>
<p>Start from two empty stacks s<sub>1</sub> and s<sub>2</sub></p>
</li>
<li>
<p>When element <code>e</code> is enqueued, it is actually pushed onto s<sub>1</sub></p>
</li>
<li>
<p>When we are supposed to dequeue, s<sub>2</sub> is checked first. If s<sub>2</sub> is empty, everything in s<sub>1</sub> will be transferred to s<sub>2</sub> by popping from s<sub>1</sub> and immediately pushing onto s<sub>2</sub>. Then we just pop from s<sub>2</sub> &ndash; the top element of s<sub>2</sub> must be the first one to enter s<sub>1</sub> thus is the first element that was enqueued.</p>
</li>
</ol>
<p>Assume that each operation of push or pop takes 1 unit of time. You job is to tell the time taken for each dequeue.</p>
<h2 id="input-specification">Input Specification:<a hidden class="anchor" aria-hidden="true" href="#input-specification">#</a></h2>
<p>Each input file contains one test case. For each case, the first line gives a positive integer <code>N</code> (≤10<sup>3</sup>), which are the number of operations. Then <code>N</code> lines follow, each gives an operation in the format</p>
<pre tabindex="0"><code>Operation Element
</code></pre><p>where <code>Operation</code> being <code>I</code> represents enqueue and <code>O</code> represents dequeue. For each <code>I</code>, <code>Element</code> is a positive integer that is no more than 10<sup>6</sup>. No <code>Element</code> is given for <code>O</code> operations.</p>
<p>It is guaranteed that there is at least one <code>O</code> operation.</p>
<h2 id="output-specification">Output Specification:<a hidden class="anchor" aria-hidden="true" href="#output-specification">#</a></h2>
<p>For each dequeue operation, print in a line the dequeued element and the unites of time taken to do this dequeue. The numbers in a line must be separated by 1 space, and there must be no extra space at the beginning or the end of the line.</p>
<p>In case that the queue is empty when dequeue is called, output in a line <code>ERROR</code> instead.</p>
<h2 id="sample-input">Sample Input:<a hidden class="anchor" aria-hidden="true" href="#sample-input">#</a></h2>
<pre tabindex="0"><code>10
I 20
I 32
O
I 11
O
O
O
I 100
I 66
O
</code></pre><h2 id="sample-output">Sample Output:<a hidden class="anchor" aria-hidden="true" href="#sample-output">#</a></h2>
<pre tabindex="0"><code>20 5
32 1
11 3
ERROR
100 5
</code></pre><h2 id="code">Code<a hidden class="anchor" aria-hidden="true" href="#code">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Basic Struct
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> stack_node{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> values;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> stack_node<span style="color:#f92672">*</span> next;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> stack_node<span style="color:#f92672">*</span> before;
</span></span><span style="display:flex;"><span>}stack_node;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> my_stack {
</span></span><span style="display:flex;"><span>  stack_node<span style="color:#f92672">*</span> head;
</span></span><span style="display:flex;"><span>  stack_node<span style="color:#f92672">*</span> top;
</span></span><span style="display:flex;"><span>}my_stack;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> my_queue {
</span></span><span style="display:flex;"><span>  my_stack<span style="color:#f92672">*</span> stack1;
</span></span><span style="display:flex;"><span>  my_stack<span style="color:#f92672">*</span> stack2;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> op_count;
</span></span><span style="display:flex;"><span>}my_queue;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Node op
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>stack_node<span style="color:#f92672">*</span> <span style="color:#a6e22e">node_init</span>(<span style="color:#66d9ef">int</span> num){
</span></span><span style="display:flex;"><span>  stack_node<span style="color:#f92672">*</span> node <span style="color:#f92672">=</span> (stack_node<span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(stack_node));
</span></span><span style="display:flex;"><span>  node<span style="color:#f92672">-&gt;</span>values <span style="color:#f92672">=</span> num;
</span></span><span style="display:flex;"><span>  node<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  node<span style="color:#f92672">-&gt;</span>before <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> node;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">node_delete</span>(stack_node<span style="color:#f92672">*</span> node){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(node<span style="color:#f92672">==</span>NULL) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">free</span>(node);
</span></span><span style="display:flex;"><span>  node <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Stack op
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>my_stack<span style="color:#f92672">*</span> <span style="color:#a6e22e">stack_init</span>(){
</span></span><span style="display:flex;"><span>  my_stack<span style="color:#f92672">*</span> res <span style="color:#f92672">=</span> (my_stack<span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(my_stack));
</span></span><span style="display:flex;"><span>  res<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> <span style="color:#a6e22e">node_init</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  res<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> res<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">stack_delete</span>(my_stack<span style="color:#f92672">*</span> stack){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(stack<span style="color:#f92672">==</span>NULL) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>  stack_node<span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> stack<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(cur <span style="color:#f92672">!=</span> NULL){
</span></span><span style="display:flex;"><span>    stack_node<span style="color:#f92672">*</span> next_node <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">node_delete</span>(cur);
</span></span><span style="display:flex;"><span>    cur <span style="color:#f92672">=</span> next_node;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">free</span>(stack);
</span></span><span style="display:flex;"><span>  stack <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">stack_push</span>(my_stack<span style="color:#f92672">*</span> stack, <span style="color:#66d9ef">int</span> num){
</span></span><span style="display:flex;"><span>  stack<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">-&gt;</span>values<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>  stack_node<span style="color:#f92672">*</span> node <span style="color:#f92672">=</span> <span style="color:#a6e22e">node_init</span>(num);
</span></span><span style="display:flex;"><span>  stack<span style="color:#f92672">-&gt;</span>top<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>  node<span style="color:#f92672">-&gt;</span>before <span style="color:#f92672">=</span> stack<span style="color:#f92672">-&gt;</span>top;
</span></span><span style="display:flex;"><span>  stack<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">stack_pop</span>(my_stack<span style="color:#f92672">*</span> stack){
</span></span><span style="display:flex;"><span>  stack<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">-&gt;</span>values<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> stack<span style="color:#f92672">-&gt;</span>top<span style="color:#f92672">-&gt;</span>values;
</span></span><span style="display:flex;"><span>  stack_node<span style="color:#f92672">*</span> old_top <span style="color:#f92672">=</span> stack<span style="color:#f92672">-&gt;</span>top;
</span></span><span style="display:flex;"><span>  stack_node<span style="color:#f92672">*</span> new_top <span style="color:#f92672">=</span> stack<span style="color:#f92672">-&gt;</span>top<span style="color:#f92672">-&gt;</span>before;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">node_delete</span>(old_top);
</span></span><span style="display:flex;"><span>  stack<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> new_top;
</span></span><span style="display:flex;"><span>  stack<span style="color:#f92672">-&gt;</span>top<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">stack_is_empty</span>(my_stack<span style="color:#f92672">*</span> stack){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(stack<span style="color:#f92672">==</span>NULL <span style="color:#f92672">||</span> stack<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">!=</span>stack<span style="color:#f92672">-&gt;</span>top){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Queue op
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>my_queue<span style="color:#f92672">*</span> <span style="color:#a6e22e">queue_init</span>(){
</span></span><span style="display:flex;"><span>  my_queue<span style="color:#f92672">*</span> res <span style="color:#f92672">=</span> (my_queue<span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(my_queue));
</span></span><span style="display:flex;"><span>  res<span style="color:#f92672">-&gt;</span>stack1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">stack_init</span>();
</span></span><span style="display:flex;"><span>  res<span style="color:#f92672">-&gt;</span>stack2 <span style="color:#f92672">=</span> <span style="color:#a6e22e">stack_init</span>();
</span></span><span style="display:flex;"><span>  res<span style="color:#f92672">-&gt;</span>op_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">queue_delete</span>(my_queue<span style="color:#f92672">*</span> queue){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(queue <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">stack_delete</span>(queue<span style="color:#f92672">-&gt;</span>stack1);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">stack_delete</span>(queue<span style="color:#f92672">-&gt;</span>stack2);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">free</span>(queue);
</span></span><span style="display:flex;"><span>  queue <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">queue_push</span>(my_queue<span style="color:#f92672">*</span> queue, <span style="color:#66d9ef">int</span> num){
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">stack_push</span>(queue<span style="color:#f92672">-&gt;</span>stack1, num);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">queue_pop</span>(my_queue<span style="color:#f92672">*</span> queue){
</span></span><span style="display:flex;"><span>  queue<span style="color:#f92672">-&gt;</span>op_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">stack_is_empty</span>(queue<span style="color:#f92672">-&gt;</span>stack1) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">stack_is_empty</span>(queue<span style="color:#f92672">-&gt;</span>stack2))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">stack_is_empty</span>(queue<span style="color:#f92672">-&gt;</span>stack2)){
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>op_count <span style="color:#f92672">=</span> queue<span style="color:#f92672">-&gt;</span>stack1<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">-&gt;</span>values<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">stack_is_empty</span>(queue<span style="color:#f92672">-&gt;</span>stack1)){
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">stack_push</span>(queue<span style="color:#f92672">-&gt;</span>stack2, <span style="color:#a6e22e">stack_pop</span>(queue<span style="color:#f92672">-&gt;</span>stack1));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  queue<span style="color:#f92672">-&gt;</span>op_count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">stack_pop</span>(queue<span style="color:#f92672">-&gt;</span>stack2);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> op_counts <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  my_queue<span style="color:#f92672">*</span> queue <span style="color:#f92672">=</span> <span style="color:#a6e22e">queue_init</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>op_counts);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> print_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>op_counts; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* printf(&#34;Time : %d\n&#34;,i); */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">getchar</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> op;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%c&#34;</span>, <span style="color:#f92672">&amp;</span>op);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(op<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;I&#39;</span>){
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">int</span> num;
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>num);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">queue_push</span>(queue, num);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(op<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;O&#39;</span>){
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">int</span> num <span style="color:#f92672">=</span> <span style="color:#a6e22e">queue_pop</span>(queue);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span>(num<span style="color:#f92672">==-</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(print_count<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>) <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">ERROR&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;ERROR&#34;</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(print_count<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">%d %d&#34;</span>,num, queue<span style="color:#f92672">-&gt;</span>op_count);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d %d&#34;</span>,num, queue<span style="color:#f92672">-&gt;</span>op_count);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      print_count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  } 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">queue_delete</span>(queue);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://novel2430.github.io/tags/fds-homework/">FDS Homework</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://novel2430.github.io/">My Web | Wei, Feng</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
