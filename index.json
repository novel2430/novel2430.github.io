[{"content":"合成器, 效果器, 混音相关算法与开源实践 功能概述 图1. 三种算法在音乐工程中的示意图\n合成器 Synthesizer 合成器可以理解成一种特别的音源，由创作者调节参数做出独一无二的声音。与虚拟乐器(VSTi)不同的，合成器不是为了模仿已存在的乐器，而是根据创作者自身对乐曲的需求特别产生。早期合成器的声音，多为了渲染乐曲的氛围而生。到了电子音乐(EDM)被主流肯定的年代，合成器逐渐成为了歌曲的主角。\n合成器的原理，最简单的理解便是对波形的改造，可能将两个波叠加，相减，或是对单一波的形状调整，都能得到不一样的声音。\n效果器 Audio Effect 效果器主要目的便是对已有声音进行润色，其基础概念也是对声音的波形做调整。但与合成器不同的部份，主要有两点：其一，效果器的重点是对已存音色做微调，而非从0开始制造出音色，其二，它对音频波的改动是基于固定几种方式的，而这些方式得到的效果便是我们常听到的，混响，延迟等。\n混音 Mixing \u0026amp; Mastering 混音 Mixing\n混音是将所有单独录制的音轨（人声、鼓、吉他、贝斯、合成器等）进行平衡、调整、处理，使它们听起来协调，并最终形成一首完整的歌曲。\n在混音的阶段，也会活用上述效果器所带来的功能，但其目标非对单轨音色进行调整，而是着重在多轨音色的和谐。\n混音的目标:\n平衡音量（确保所有乐器在人耳中都能清楚地听到） 处理频率冲突（避免不同乐器的声音遮蔽） 调整声像（Panning）（使声音在立体声场中有良好的空间感） 控制动态范围（压缩/限制器，避免声音忽大忽小） 加入空间感（混响、延迟，让声音听起来自然） 母带 Mastering\n母带处理是对 混音好的歌曲 进行最后的调整，确保歌曲在所有播放设备上（耳机、手机、音箱、车载音响）都能有良好的听感，并符合行业标准的音量要求（如 Spotify、Apple Music 等的 LUFS 标准）。\n母带的目标:\n优化整体音量（提升到行业标准，而不会失真） 均衡整个频率范围（让高频清晰、低频扎实） 增强立体声宽度（使歌曲听起来更开阔） 确保动态范围合适（不会过度压缩，使音乐有起伏） 格式转换（导出适合 CD、流媒体、黑胶的版本） 合成器相关VST 在数字音乐制作中，合成器（Synthesizer） 是一种用于生成电子音色的工具，它可以模拟传统乐器的声音，也可以创造全新的、无法由自然乐器发出的音色。而 VST（Virtual Studio Technology） 则是一种插件格式，使得这些合成器可以作为软件运行在 DAW（数字音频工作站） 中，广泛应用于电子音乐、电影配乐、游戏音效等领域。\n知名合成器VST \u0026ndash; Serum\n合成器的基本原理 合成器的核心功能是 通过电子方式生成和控制声音。它主要依靠以下几个核心模块：\n(1) 振荡器 Oscillator 振荡器是合成器的音源部分，负责产生基本波形，如：\n正弦波（Sine Wave）：最纯净的波形，只有基频，听起来类似于简单的哨声。 锯齿波（Sawtooth Wave）：包含所有谐波成分，音色明亮，常用于弦乐合成。 方波（Square Wave）：仅包含奇次谐波，音色接近管风琴或电子乐中的主音。 三角波（Triangle Wave）：主要包含低阶奇次谐波，音色较柔和。 多个振荡器可以相互叠加，或通过调制（如 FM 合成、AM 合成）产生更复杂的波形。例如：\n波叠加合成（Additive Synthesis）：通过多个简单波形的叠加，构建出复杂音色。数学上可以通过傅立叶级数来描述，即任意周期信号都可以分解为多个正弦波的叠加。 减法合成（Subtractive Synthesis）：先生成丰富的波形，再通过滤波器削减部分频率成分，以获得特定的音色。 (2) 滤波器 Filter 滤波器用于调整音色的频谱特性，最常见的类型包括：\n低通滤波器（LPF, Low-Pass Filter）：允许低频通过，削减高频，使声音更柔和。 高通滤波器（HPF, High-Pass Filter）：允许高频通过，削减低频，使声音更清亮。 带通滤波器（BPF, Band-Pass Filter）：仅保留一定范围内的频率，适用于特定音效处理。 (3) 包络 Envelope 包络控制声音随时间的演变，最常见的是 ADSR（Attack-Decay-Sustain-Release）：\nAttack（起音）：声音从零到最大音量的时间。 Decay（衰减）：从最大音量下降到持续音量的时间。 Sustain（持续）：声音保持的稳定音量。 Release（释放）：声音从持续音量降至零的时间。 包络决定了声音的动态特性，例如模拟钢琴的短暂击弦或小提琴的渐进拉弓效果。\n(4) 低频振荡器 LFO, Low-Frequency Oscillator LFO 作用于其他参数，产生周期性的变化，例如：\n通过 LFO 控制音高，可以生成 颤音（Vibrato） 效果。 通过 LFO 控制音量，可以生成 抖音（Tremolo） 效果。 通过 LFO 控制滤波频率，可以生成 扫频（Wobble） 效果，广泛用于 Dubstep 音色设计。 合成器VST的主要合成方式 不同的合成器VST采用不同的声音合成方式，常见的包括：\n加法合成 Additive Synthesis 基于傅立叶级数的思想，将多个简单波形（如正弦波）叠加，形成复杂音色。例如，Harmor 采用这种方式来合成丰富的音色。\n减法合成 Subtractive Synthesis 通过滤波器对富含谐波的波形进行频率衰减，以塑造特定音色。Serum、Sylenth1、Massive 等主流合成器都采用此方法。\n频率调制合成 FM Synthesis 通过一个波形调制另一个波形的频率，以产生复杂的谐波结构。例如，Yamaha DX7 硬件合成器及其 VST 版本 FM8 采用此方法。\n采样合成 Sampling Synthesis 基于预录音色进行变调和处理，例如 Kontakt 采样库可以模拟真实乐器。\n波表合成 Wavetable Synthesis 基于波形表存储不同的波形，并允许动态切换，例如 Serum 提供了丰富的波表编辑功能。\n合成器与AI技术 - Synplant2 (2023) Synplant 是由 Sonic Charge 开发的一款软件合成器，不同于传统合成器依赖旋钮和参数调节，Synplant 采用遗传概念，允许用户通过种植和发展种子来探索和创造声音。\n这种方法提供了一种非线性的音色生成方式，使用户能够在实验过程中逐步发现不同的声音特性。\n在 Synplant 2 版本中，能利用人工智能分析音频样本，并生成匹配的合成音色。相比手动调节合成参数，这一功能可以在更短时间内获得接近目标的音色，同时保留一定的创造空间。此外，Synplant 2 还引入了 DNA 编辑器，允许用户深入修改声音的核心属性，包括包络、振荡器类型、滤波器等，以实现更精确的音色塑造。\nlink: https://soniccharge.com/synplant 开源合成器 减法合成器 Subtractive Synthesizers 特点：通过产生谐波丰富的波形（如锯齿波、方波等），然后使用滤波器削减特定频率成分，以塑造所需音色。\n案例：\nOB-XD - Oberheim emulation https://github.com/reales/OB-Xd monique-monosynth - Bass \u0026amp; Lead https://github.com/surge-synthesizer/monique-monosynth amsynth https://github.com/Amsynth/Amsynth 频率调制合成器 FM Synthesizers 特点：通过一个振荡器调制另一个振荡器的频率，产生复杂的谐波结构，适合创造金属质感或电钢琴等音色。\n案例：\nDexed - yamaha dx7 emulation https://github.com/asb2m10/dexed 波表合成器 Wavetable Synthesizers 特点：通过在不同波形之间进行插值，创造动态变化的音色，适用于复杂且富有运动感的声音设计。\n案例：\nSurge - Hybrid synthesizer / MPE compatible https://github.com/surge-synthesizer/surge Vital - spectral warping wavetable synth https://github.com/mtytel/vital Helm - 2 oscilator wavetable synthesizer https://github.com/mtytel/helm Yoshimi https://sourceforge.net/projects/yoshimi/ ZynAddSubFX https://sourceforge.net/projects/zynaddsubfx/ 模块化合成器 Modular Synthesizers 特点：由独立的模块（如振荡器、滤波器、包络等）组成，用户可以自由连接这些模块，构建自定义的信号路径，提供高度的灵活性和创造性。\n案例：\nVCV Rack - 免费的虚拟模块化合成器平台，模拟Eurorack系统，拥有丰富的第三方模块支持。 https://github.com/VCVRack/Rack 效果器VST 效果器（Audio Effects） 是音频处理中的关键工具，它们基于 数字信号处理（DSP, Digital Signal Processing），用于改变音频的频率特性、动态范围、空间感等。以下介绍常见的效果器算法，并结合真实音乐制作中的应用案例，帮助理解其作用和实现方式。\n均衡器 EQ, Equalization 作用: 调整音频信号的不同频率成分，使音色更加均衡或突出特定部分。\n主要算法 IIR 滤波器（如 Biquad、Butterworth）：计算量小，适用于实时均衡。 FIR 滤波器：相位响应更稳定，但计算量较大，适用于高精度处理。 FFT 频率均衡：直接在频域上调整振幅，可用于复杂的图形均衡器。 真实应用 流行音乐：许多流行歌曲在制作过程中都会使用 EQ 来增强人声清晰度，例如提升 3-5kHz 频段，使声音更加明亮。 现场演出：在音乐会或演唱会中，EQ 常用于抑制反馈和优化不同乐器的音色，以适应不同的环境。 压缩器 Compressor 作用: 调整音频的动态范围，使响亮部分降低、安静部分增强，使声音更加均衡。\n主要算法 峰值检测（Peak Detection）：适用于处理瞬态信号（如鼓声）。 RMS 计算：用于整体音量感知，使声音更平滑。 非线性增益映射：可实现 Soft-Knee 压缩，使过渡更自然。 真实应用 广播 \u0026amp; 播客：为了确保主播的声音在节目中保持均匀，不会因为说话音量变化而导致忽大忽小，通常会应用压缩器。 鼓组混音：在摇滚和流行音乐的制作中，压缩器常用于控制鼓的动态，使鼓声更有力、更紧凑。 混响 Reverb 作用: 模拟声音在不同空间中的反射，使声音更加自然或富有氛围感。\n主要算法 Schroeder 混响：使用 All-Pass 滤波器和延迟网络模拟基本房间混响。 反馈延迟网络（FDN）：通过多个反馈延迟叠加，创造更复杂的混响效果。 卷积混响（Convolution Reverb）：使用真实环境的脉冲响应（IR）进行计算，能够还原真实空间的声音特性。 真实应用 电影音效：在电影配乐和音效处理中，混响被用于创造空间感，使角色的声音更符合场景（如大教堂或洞穴）。 摇滚音乐：许多摇滚歌曲的人声或吉他部分都会加入混响，使声音更加丰满，增强空间感。 延迟 Delay 作用: 让音频信号在一定时间后重复出现，形成回声或节奏性重复效果。\n主要算法 基础延迟线（Delay Line）：存储音频信号并延迟播放，形成简单的回声。 反馈延迟（Feedback Delay）：延迟信号部分回传到输入，形成多次回声。 BBD（Bucket Brigade Delay）模拟：模拟老式模拟延迟效果，适用于复古音乐风格。 真实应用 电子音乐：许多电子音乐制作中都会使用节奏同步的延迟效果，使旋律更有层次感和律动感。 吉他效果：在吉他演奏中，延迟被广泛应用，形成 Slapback Delay 或 Ping-Pong Delay 以增加空间感。 失真 Distortion 作用: 改变音频信号的波形，增加谐波失真，使声音更加“粗糙”或“饱和”。\n主要算法 软削波（Soft Clipping）：温和的失真，模拟老式磁带饱和或电子管放大器的声音。 硬削波（Hard Clipping）：更激进的失真，常用于金属音乐和电子音乐。 波形整形（Wave Shaping）：使用非线性映射函数来创造不同风格的失真音色。 真实应用 摇滚 \u0026amp; 金属音乐：在电吉他的音色处理中，失真是必不可少的效果，使音色更具攻击性。\n电子音乐 \u0026amp; Lo-Fi：许多电子音乐和 Lo-Fi 风格的音乐会使用模拟饱和或失真效果，使声音听起来更温暖或复古。\n开源效果器 综合形效果器代表该项目实践了多个效果器算法，其中有些项目是对DSP专业知识书籍的实践试手，极具参考价值。\n综合型 Audio Effect\nhttps://github.com/juandagilc/Audio-Effects\nCollection of audio effects plugins implemented from the explanations in the book Audio Effects: Theory, Implementation and Application by Joshua D. Reiss and Andrew P. McPherson. Delay, Vibrato, Flanger, Chorus, EQ, Wah-Wah, Phaser, Tremolo, Compressor, Distortion\nSurge\nhttps://github.com/surge-synthesizer/surge Synth + Effect\nVital\nhttps://github.com/mtytel/vital Synth + Effect\nCalf\nhttps://github.com/calf-studio-gear/calf Delay, Reverb, EQ, Distortion, Compressor, Chorus, Phaser, Flanger,\nVSTPlugins\nhttps://github.com/keithhearne/VSTPlugins\nWill Pirkle (2012), Designing Audio Effect Plug-Ins in C++: With Digital Audio Signal Processing Theory. 1 Edition. Focal Press. Delay, Reverb\npulp-fiction\nhttps://github.com/enter-opy/pulp-fiction Delay, Chours, Flanger, Tremelo\nzam-plugins\nhttps://github.com/zamaudio/zam-plugins EQ, Compressor, Distortion, Delay\n均衡 ModEQ https://github.com/tobanteAudio/modEQ Mini-Series https://github.com/DISTRHO/Mini-Series 压缩 Squeezer https://github.com/mzuther/Squeezer 混响 Cloud Seed https://github.com/ValdemarOrn/CloudSeed MVerb https://github.com/DISTRHO/MVerb Dragonfly Reverb https://github.com/michaelwillis/dragonfly-reverb Reach https://github.com/Sinuslabs/Reach 延迟 Cocoa Delay https://github.com/tesselode/cocoa-delay Regrader https://github.com/igorski/regrader 失真 CHOW https://github.com/Chowdhury-DSP/CHOW Schrammel OJD https://github.com/JanosGit/Schrammel_OJD Sound of Music https://github.com/enter-opy/sound-of-music Smart Guitar Pedal - ML https://github.com/GuitarML/SmartGuitarPedal Temper https://github.com/creativeintent/temper ScorchCrafter Guitar FX https://sourceforge.net/projects/scorchcrafter/ 合唱 YK Chorus https://github.com/SpotlightKid/ykchorus 混音 Mixing \u0026amp; 母带 Mastering 在音乐制作中，混音（Mixing） 和 母带（Mastering） 是两个关键环节，它们确保音乐作品清晰、平衡，并符合商业发行的标准。\n混音（Mixing） 处理 多轨音频（人声、鼓、吉他、贝斯等），确保它们互相协调，避免频率冲突，使整体听感清晰。 母带（Mastering） 处理 最终混音文件，优化音质，让其适用于各种播放设备，并达到行业标准的响度。 混音阶段 Mixing Stage 混音的目标 是将多个音轨整合，使它们在频率、音量、动态范围、空间感等方面协调一致。常见步骤包括：\n增益调整 Gain Staging 在混音开始前，调整各音轨的输入增益，确保没有音轨过载失真，同时为后续处理留有动态余量。通常在 DAW 里使用 Fader（推子） 或 增益插件进行调整。\n声像 Panning 调整各音轨在立体声中的位置，使声音更加自然和宽广。例如，主音通常居中，伴奏吉他可以略向左右分散。使用 等功率（Equal Power Panning） 或 线性声像算法 确保声场均衡。\n均衡 EQ 使用均衡器调整频率分布，避免乐器之间的频率遮蔽。例如，削减低频来清理浑浊感，或者增加 8kHz 以上的高频，让人声音色更明亮。EQ 算法通常基于 IIR（无限脉冲响应）滤波器 或 FIR（有限脉冲响应）滤波器。\n动态处理 Compression 压缩器用于控制音轨的动态范围，使音量变化更加平稳。压缩器的核心算法涉及 RMS（均方根）检测、Attack/Release 时间计算、Soft Knee 过渡 等，使声音更具能量感。\n混响 \u0026amp; 延迟 Reverb \u0026amp; Delay 混响用于模拟空间感，使干音听起来更自然。延迟用于增强节奏感或制造立体空间。混响算法常见有 卷积混响（Convolution Reverb） 和 施罗德混响（Schroeder Reverb）。\n饱和 \u0026amp; 失真 Saturation \u0026amp; Distortion 通过磁带饱和或失真，给声音增加温暖感。此类插件常使用 非线性波形削波（Wave Shaping） 和 谐波倍增（Harmonic Exciter） 算法。\n混音阶段的最终输出 是一个 立体声 WAV 文件（44.1kHz/24-bit 或 48kHz/32-bit）\n母带阶段 Mastering Stage 母带处理的目标 是微调整个混音，使其在不同播放环境（耳机、车载音响、流媒体）下听感一致，并符合行业标准。核心步骤如下：\n均衡 Mastering EQ 微调整体音色，确保低频不过重，高频不过亮。使用 母带级别的 EQ，通常只做 小幅调整（+/- 1~3dB），避免破坏混音的原始平衡。\n多段压缩 Multiband Compression 使用多段压缩器分别处理低频、中频、高频的动态，使不同频段的音量更均衡。这通常使用 FFT 频率分解算法 来对频率段进行独立处理。\n限制器 Limiter 为了提高音量，使歌曲达到商业发布的标准，使用限制器。限制器基于 软/硬限幅（Soft/Hard Clipping）、Lookahead 预测 算法，确保最大音量不会超出 0dBFS。\n立体声增强 Stereo Imaging 通过 Mid/Side（M/S）处理 扩宽立体声宽度（如 iZotope Ozone Imager），让音乐听起来更开阔，但不过度扩展，以免兼容性问题。\n饱和 \u0026amp; 模拟色彩 Tape Saturation 通过模拟磁带增强温暖感，使数字音频更有模拟质感。这些插件通常模拟磁带录音机的 非线性响应和谐波失真。\n响度标准化 Loudness Normalization 现代流媒体平台（如 Spotify、Apple Music）要求音频符合 LUFS（Loudness Units Full Scale） 标准。通常使用 iZotope Insight、Youlean Loudness Meter 来测量和优化音量，使其符合 -14 LUFS（Spotify）或 -8 LUFS（电子舞曲）等行业标准。\n母带阶段的最终输出是 WAV 44.1kHz/16-bit（CD 质量）、WAV 48kHz/24-bit（流媒体）、MP3 320kbps（网络播放）。\n开源Mixing \u0026amp; Mastering VST 综合型 ZL-Audio ZLEqualizer: equalizer plugin https://github.com/ZL-Audio/ZLEqualizer ZLCompressor: compressor plugin https://github.com/ZL-Audio/ZLCompressor ZLSplitter: splitter plugin https://github.com/ZL-Audio/ZLSplitter ZLWarm: distortion/saturation plugin https://github.com/ZL-Audio/ZLWarm ZLLMakeup: loudness make-up plugin https://github.com/ZL-Audio/ZLLMakeup ZLLMatch: loudness matching plugin https://github.com/ZL-Audio/ZLLMatch ZLInflator: distortion/saturation plugin https://github.com/ZL-Audio/ZLInflator lsp-plugins https://github.com/lsp-plugins/lsp-plugin Gain Staging / Limiter JS Inflator https://github.com/Kiriki-liszt/JS_Inflator PeakEater https://github.com/vvvar/PeakEater Audio Analysis MultiMeter https://github.com/RealAlexZ/MultiMeter K-Meter https://github.com/mzuther/K-Meter traKmeter https://github.com/mzuther/traKmeter SPARTA https://github.com/leomccormack/SPARTA Panning binaural https://github.com/twoz/binaural-vst EQ EQ10Q - Parametric EQ https://sourceforge.net/projects/eq10q/ Luftikus - Analog-modeled EQ https://github.com/lkjbdsp/lkjb-plugins/tree/master/Luftikus/Source Frequalizer https://github.com/ffAudio/Frequalizer Compressor WIP Compressor Plugin https://github.com/DGriffin91/compressor-plugin Molot Lite https://github.com/magnetophon/molot-lite CTAGDRC https://github.com/p-hlp/CTAGDRC zam-plugins https://github.com/zamaudio/zam-plugins Reverb DF Zita Rev1 https://github.com/SpotlightKid/dfzitarev1 CloudReverb https://github.com/xunil-cloud/CloudReverb Room Reverb https://github.com/cvde/RoomReverb ","permalink":"https://novel2430.github.io/notes/open_source_vst/","summary":"\u003ch1 id=\"合成器-效果器-混音相关算法与开源实践\"\u003e合成器, 效果器, 混音相关算法与开源实践\u003c/h1\u003e\n\u003ch2 id=\"功能概述\"\u003e功能概述\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"https://github.com/novel2430/MyImage/blob/main/VST_01_01.png?raw=true\"\u003e\u003cbr\u003e\n图1. 三种算法在音乐工程中的示意图\u003c/p\u003e\n\u003ch3 id=\"合成器-synthesizer\"\u003e合成器 Synthesizer\u003c/h3\u003e\n\u003cp\u003e合成器可以理解成一种特别的\u003cstrong\u003e音源\u003c/strong\u003e，由创作者调节参数做出独一无二的声音。与虚拟乐器(VSTi)不同的，合成器不是为了模仿已存在的乐器，而是根据创作者自身对乐曲的需求特别产生。早期合成器的声音，多为了渲染\u003cstrong\u003e乐曲的氛围\u003c/strong\u003e而生。到了电子音乐(EDM)被主流肯定的年代，合成器逐渐成为了歌曲的主角。\u003cbr\u003e\n合成器的原理，最简单的理解便是对\u003cstrong\u003e波形\u003c/strong\u003e的改造，可能将两个波叠加，相减，或是对单一波的形状调整，都能得到不一样的声音。\u003c/p\u003e","title":"VST Introduction"},{"content":"ZJU考研分享 Part1 - 来内地考研? 那首先，就是关于考研的选择。\n城市选择: 生活成本 第一个你可能会好奇的就是城市的选择，浙江大学在杭州，杭州不像上海是一个节奏快速，举世闻名的大城市，最直观的比如说物价可能就会低一点。那对于杭州，我会以在这个地方的生活成本，还有我所知道在杭州的实习机会来跟各位分享。\n先来分享一下在杭州的生活成本，比如说浙大的话，研究生收入主要来源有两个，第一便是学校会稳定支付你每个月1300人民币，入学的第一学期可能会欠你几个月，但很快就会补上。第二，就是你选择的实验室给你的劳务费。这个劳务费是会根据实验室的不同，有多有少，但保底就是500元一个月，如果你比较常帮忙老师，或接了一些项目，那就有机会更多。但我也听说过，有些实验室太小，老师让你作一堆事情，但直到毕业你都领500。\n再来就是支出，首先就是吃饭跟水电，这两个我觉得很看个人，但只讲三餐，一天100人民币我觉得不难解决问题，水电的话，如果你住在学校宿舍，那就真的是非常非常少的开销，但如果你选择住在校外，那就会根据你住的房形来决定。刚好讲到校外住宿，我自己目前就是住在学校外面，那在我亲身经历，还有身边其他租房的朋友所言，浙大的几个校区边上，房租的range其实蛮大的，800到3000多的都有，我自己是没太多要求，所以选择了1400的租房。\n城市选择: 实习机会 再来关于城市选择，你可以考虑到的就是读书期间实习的机会。因为我自己的专业，未来在互连网公司待的机会比较高，所以我这张简报上主要都是互连网企业。\n阿里系相关的产业可以说是杭州的代表，先不论他们企业文化如何，我相信大部分的人如果有机会能去阿里，铁定是比较开心的。再来就是华为，老实说我之前真的以为华为没放岗位在杭州，直到本科快毕业的时候接到一些华为hr的电话，才知道也是有再招人的，然后他们hr也真的是很辛苦。\n剩下还有一些比较知名的公司我也放在了图中，至少我在今天来之前打开boss直聘，他们都有在杭州招互连网岗位的实习。题外话，如果喜欢外商公司的话，我记得zoom好像也是在杭州。\n专业选择 那现在来聊聊专业选择吧！就像一开始说的，我就读的专业是叫做设计学，但其实我本科念的专业是纯计算机科学，虽然他们两个都是属于计算机科学学院底下，但还是不一样的。而我会有现在的转变，一部分是我自己在本科阶段算是意识到自己可能不太适合纯粹的CS，尤其是把CS拿来做科研的话，估计导师会想掐死我。\n另一部分，也是对你们比较重要的部分，就是浙大已经好几年不在计算机科学专业上招港澳台研究生了，但这个意思不是说你是港澳台，你就不准进去，只是说面向港澳台考研的这项特别通道，不能报考浙大的计算机专业。你真的想去，你一直都可以选择跟内地学生一起考研竞争，当然这个成本可能就要自己好好考量了。\n但不能选计算机，那为何要去设计学呢？我因为本科阶段在作毕业论文的时候，刚好有机会可以稍微认识了我校设计学专业目前常干的事情，他们基本上都是在做AIGC相关的领域，那至少这个趋势，是符合社会发展的。如果讲到兴趣，我是真心对人工智能相关的数学理论，算法，兴趣不是很大，把AI抓过来让他作点奇怪的事情我比较感兴趣。虽然这样说有点不准确，但相较于传统CS，设计学比较多的正是思考要如何结合AI技术，结合几个领域，看看可不可整出新点花样。\nPart2 - 择校经验 再来要说的就是学校的选择。\n报考人数 我也顺便分享一下报考状况。去年浙江大学港澳台硕士的总报考人数我这边没有资料，我只知道设计学专业的状况。那我们当初是参加复式的人数一共就三个，包括我两个是浙大本校生，另一个是澳门大学的朋友，经过大概半天的复式，最后总录取人数也是三个，老实说我有点怀疑会不会是人太少的关系。\n设计学? 那我们浙大的设计学都在干嘛呢？我这边列出了6个领域，但这只是一部分，我知道存在的范围而已。我自己目前做的是音乐生成相关的领域，但我们实验室体量比较大，所以比如说古籍修复，字体设计这些领域也有不少人在做。数据洞察这是我朋友他们实验室主要的方向，而舞蹈生成则是之前参会看到其他学校做的，他们的成果其实让我印象蛮深刻的。\n所以可以看到，设计学主要的领域范围是真的很大，像我自己虽然求学阶段一直都是理工科，但我对文艺领域的兴趣向来都是比理工科大的，所以可以说设计学给了我一次机会去将两者融合。\nCoding? 另外需要强调的是，虽然专业名称为设计学，但这个专业还是属于计算机学院底下，所以如果具备一定的 coding 能力，对于面试，还有未来做研究的时候都会有很大的帮助。其他学校我不知道，但浙大设计学，工业设计等专业目前大方向都得跟人工智能沾上边，所以比如说简单的python最好还是要会。\n另外比如说一些应用开发的能力，不管是网页端、安卓端、IOS端能稍微知道一点会蛮好的，有时候可能老师接了什么项目然后你刚好缺钱，那估计会用上。\nPart2 - 考试经验 初试 初试的话，主要就三个科目，中华文化，数学，英文，因为我报考的是设计学，所以那个数学他的正式称呼应该是逻辑推理，但我觉得叫脑筋急转弯的比较恰当。\n个人感想，我身边大部分觉得头痛的应该是中华文化，尤其理工科生更是如此。但我在考试前有拿着考纲跟内地的朋友讨论，他是说感觉范围就是他们的高中语文，然后加上历史课。我自己的感觉也差不多，真的要准备可以多看看抢救国文大作战，我不知道你们现在还有再用这玩意吗？\n再来就是英文，我觉得依照台生的英文水准应该是不用太担心，我自己觉得跟学测难度差不多，所以可能文法要回忆一下会比较好。阿如果担心词汇量，就去背大陆的考研单词吧！\n复试 那关于复试，浙大设计学是有两个阶段，第一个是设计学专业课的笔试，第二个就是面试。这两个都是同一天举行的。对于专业课笔试，我觉得像我一样夸专业考的人可以从中国大学幕课网上去学习，像浙大就有不少能参考的课程在上面。\n那对于复试，我记得老师们主要会想问你的问题，就是围绕着你为什么要来这个专业念硕士，还有你的毕业论文是在干嘛。所以针对面试，可以复习并简短一下自己的毕业答辩的内容就好。\n其他准备 那最后针对考研的其他准备，我觉得最重要的就是体现你对学术的热情。比如像我的话就是在最后一年找个实验室进去打工，看看能不能混个专利或挂名小文章，再不行也能混脸熟。\n那如果你没有这个时间的话，也可以先去了解一下自己感兴趣的导师，他有做什么方向，然后让gpt 帮你看看文章帮你总结。做这些的主要目的，就是让你在面试的展示阶段有话可说，并且也能尽量老师询问你你有准备的话题。\n","permalink":"https://novel2430.github.io/ideas/zju_postgraduate_entrance_exam/","summary":"\u003ch1 id=\"zju考研分享\"\u003eZJU考研分享\u003c/h1\u003e\n\u003ch2 id=\"part1---来内地考研\"\u003ePart1 - 来内地考研?\u003c/h2\u003e\n\u003cp\u003e那首先，就是关于考研的选择。\u003c/p\u003e\n\u003ch3 id=\"城市选择-生活成本\"\u003e城市选择: 生活成本\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"image\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/novel2430/MyImage/refs/heads/main/ZJU_postgraduate_exam_04.png\"\u003e\n第一个你可能会好奇的就是城市的选择，浙江大学在杭州，杭州不像上海是一个节奏快速，举世闻名的大城市，最直观的比如说物价可能就会低一点。那对于杭州，我会以在这个地方的生活成本，还有我所知道在杭州的实习机会来跟各位分享。\u003c/p\u003e","title":"ZJU postgraduate entrance examination sharing"},{"content":"Some simple Wayfire custom keybind ScreenShot You can use grim and slurp to have screenshot function\ngrim\nscreenshot slurp\nselect a region Install grim and slurp\nyay -S grim slurp For example shell script\n# ~/.config/wayfire/scripts/screenshot.sh path=\u0026#34;/home/novel2430/Pictures/screenshot/\u0026#34; # \u0026lt;--- Where you want to save your screenshots now_date=$(date \u0026#39;+%Y%m%d-%H%M%S\u0026#39;) file_name=\u0026#34;${path}${now_date}.png\u0026#34; msg=\u0026#34;save as ${file_name}\u0026#34; case $1 in full) grim ${file_name} \u0026amp;\u0026amp; dunstify -a \u0026#34;Screenshot\u0026#34; \u0026#34;Full\u0026#34; \u0026#34;${msg}\u0026#34; -r 2003 ;; select) grim -g \u0026#34;$(slurp)\u0026#34; ${file_name} \u0026amp;\u0026amp; dunstify -a \u0026#34;Screenshot\u0026#34; \u0026#34;Select\u0026#34; \u0026#34;${msg}\u0026#34; -r 2003 ;; esac Clipboard Manager We need two packages: cliphist and wl-clipboard\ncliphist\nFor clipboard managing wl-clipboard\nFor copy and paste Install both\nyay -S cliphist wl-clipboard # ~/.config/wayfire/scripts/clipboard.sh cliphist list | wofi show --dmenu | cliphist decode | wl-copy Volume Control We used Pipewire and Wireplumber to control our audio, so we can use wpctl to control the volume\nIncrease volume wpctl set-volume -l 1.5 @DEFAULT_AUDIO_SINK@ 5%+ Decrease volume wpctl set-volume @DEFAULT_AUDIO_SINK@ 5%- Mute wpctl set-mute @DEFAULT_AUDIO_SINK@ toggle Commands above can use with \u0026lsquo;dunst\u0026rsquo;, so we can write a simple script\n# ~/.config/wayfire/scripts/volume.sh # \u0026lt;this_file\u0026gt; up ----\u0026gt; Increase Volume # \u0026lt;this_file\u0026gt; down ----\u0026gt; Decrease Volume # \u0026lt;this_file\u0026gt; mute ----\u0026gt; Toggle Mute sending () { volume=$(wpctl get-volume @DEFAULT_AUDIO_SINK@ | awk \u0026#39;{print $2}\u0026#39;) volume_scale=$(awk \u0026#39;{print $1*$2}\u0026#39; \u0026lt;\u0026lt;\u0026lt;\u0026#34;${volume} 100\u0026#34;) dunstify -a \u0026#34;ChangeVolume\u0026#34; -r 9993 -h int:value:\u0026#34;$volume_scale\u0026#34; -i \u0026#34;Vol $1\u0026#34; \u0026#34;Level : ${volume_scale}%\u0026#34; -t 2000 } case $1 in up) wpctl set-volume -l 1.5 @DEFAULT_AUDIO_SINK@ 5%+ \u0026amp;\u0026amp; sending $1 ;; down) wpctl set-volume @DEFAULT_AUDIO_SINK@ 5%- \u0026amp;\u0026amp; sending $1 ;; mute) wpctl set-mute @DEFAULT_AUDIO_SINK@ toggle if [[ \u0026#34;$(wpctl get-volume @DEFAULT_AUDIO_SINK@ | awk \u0026#39;{print $3}\u0026#39;)\u0026#34; = \u0026#34;[MUTED]\u0026#34; ]]; then dunstify -a \u0026#34;ChangeVolume\u0026#34; -i \u0026#34;Muted\u0026#34; \u0026#34;MUTE\u0026#34; -t 2000 -r 9993 else sending up fi ;; esac Brightness Control I prefer \u0026lsquo;brillo\u0026rsquo;\nInstall brillo\nyay -S brillo # ~/.config/wayfire/bright.sh function send() { bright=$(printf \u0026#34;%.0f\\n\u0026#34; $(brillo -G)) dunstify -a \u0026#34;ChangeBrightness\u0026#34; -r 9993 -h int:value:\u0026#34;$bright\u0026#34; -i \u0026#34;Brightness $1\u0026#34; \u0026#34;Level : ${bright}%\u0026#34; -t 2000 } case $1 in up) sudo brillo -u 150000 -q -A 3 send $1 ;; down) sudo brillo -u 150000 -q -U 3 send $1 ;; esac Screen Lock I prefer \u0026lsquo;swaylock-effetcs\u0026rsquo;\nyay -S swaylock-effetcs # ~/.config/wayfire/scripts/swaylock.sh swaylock \\ --screenshots \\ --clock \\ --indicator \\ --indicator-radius 100 \\ --indicator-thickness 7 \\ --effect-blur 7x5 \\ --effect-vignette 0.5:0.5 \\ --ring-color bb00cc \\ --key-hl-color 880033 \\ --line-color 00000000 \\ --inside-color 00000088 \\ --separator-color 00000000 \\ --grace 2 \\ --fade-in 0.2 ","permalink":"https://novel2430.github.io/notes/simple-wayfire-keybind/","summary":"\u003ch1 id=\"some-simple-wayfire-custom-keybind\"\u003eSome simple Wayfire custom keybind\u003c/h1\u003e\n\u003ch2 id=\"screenshot\"\u003eScreenShot\u003c/h2\u003e\n\u003cp\u003eYou can use \u003ccode\u003egrim\u003c/code\u003e and \u003ccode\u003eslurp\u003c/code\u003e to have screenshot function\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003egrim\u003cbr\u003e\nscreenshot\u003c/li\u003e\n\u003cli\u003eslurp\u003cbr\u003e\nselect a region\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eInstall grim and slurp\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eyay -S grim slurp\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eFor example shell script\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# ~/.config/wayfire/scripts/screenshot.sh\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epath\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;/home/novel2430/Pictures/screenshot/\u0026#34;\u003c/span\u003e   \u003cspan style=\"color:#75715e\"\u003e# \u0026lt;--- Where you want to save your screenshots\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enow_date\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003edate \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;+%Y%m%d-%H%M%S\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efile_name\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e${\u003c/span\u003epath\u003cspan style=\"color:#e6db74\"\u003e}${\u003c/span\u003enow_date\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e.png\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emsg\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;save as \u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e${\u003c/span\u003efile_name\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e $1 in\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  full\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    grim \u003cspan style=\"color:#e6db74\"\u003e${\u003c/span\u003efile_name\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e dunstify -a \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Screenshot\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Full\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e${\u003c/span\u003emsg\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e -r \u003cspan style=\"color:#ae81ff\"\u003e2003\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ;;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eselect\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    grim -g \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003eslurp\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e${\u003c/span\u003efile_name\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e dunstify -a \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Screenshot\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Select\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e${\u003c/span\u003emsg\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e -r \u003cspan style=\"color:#ae81ff\"\u003e2003\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ;;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eesac\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"clipboard-manager\"\u003eClipboard Manager\u003c/h2\u003e\n\u003cp\u003eWe need two packages: \u003ccode\u003ecliphist\u003c/code\u003e and \u003ccode\u003ewl-clipboard\u003c/code\u003e\u003c/p\u003e","title":"Simple Wayfire Keybind"},{"content":"Alpine Linux with Sway Bash, Text Editor Packages apk add vim bash Create Non Root User Packages apk add sudo shadow Command Add User useradd -m -G wheel -s /bin/bash \u0026lt;user_name\u0026gt; passwd \u0026lt;user_name\u0026gt; sudo file EDITOR=vim visudo # Make wheel group can use sudo Setup eudev setup-devd udev GPU Intel apk add mesa-dri-gallium AMD\nRead here Nvidia\nRead here PAM apk add linux-pam shadow-login Elogind apk add elogind polkit-elogind dbus rc-update add elogind rc-update add polkit rc-update add dbus Sway apk add sway Reboot After rebooting your computer, you should use your non-root userer to log in\nRun Sway You can test loginctl output first, the output should not contains any No session\nAfter testing, you can run Sway\ndbus-run-session -- sway ","permalink":"https://novel2430.github.io/notes/alpine-to-sway/","summary":"\u003ch1 id=\"alpine-linux-with-sway\"\u003eAlpine Linux with Sway\u003c/h1\u003e\n\u003ch2 id=\"bash-text-editor\"\u003eBash, Text Editor\u003c/h2\u003e\n\u003ch3 id=\"packages\"\u003ePackages\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapk add vim bash\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"create-non-root-user\"\u003eCreate Non Root User\u003c/h2\u003e\n\u003ch3 id=\"packages-1\"\u003ePackages\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapk add sudo shadow\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"command\"\u003eCommand\u003c/h3\u003e\n\u003ch4 id=\"add-user\"\u003eAdd User\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003euseradd -m -G wheel -s /bin/bash \u0026lt;user_name\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epasswd \u0026lt;user_name\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"sudo-file\"\u003esudo file\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eEDITOR\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003evim visudo\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Make wheel group can use sudo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"setup-eudev\"\u003eSetup eudev\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esetup-devd udev\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"gpu\"\u003eGPU\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eIntel\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapk add mesa-dri-gallium\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eAMD\u003cbr\u003e\nRead \u003ca href=\"https://wiki.alpinelinux.org/wiki/Radeon_Video\"\u003ehere\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eNvidia\u003cbr\u003e\nRead \u003ca href=\"https://wiki.alpinelinux.org/wiki/NVIDIA\"\u003ehere\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"pam\"\u003ePAM\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapk add linux-pam shadow-login\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"elogind\"\u003eElogind\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapk add elogind polkit-elogind dbus\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003erc-update add elogind\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003erc-update add polkit\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003erc-update add dbus\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"sway\"\u003eSway\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapk add sway\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"reboot\"\u003eReboot\u003c/h2\u003e\n\u003cp\u003eAfter rebooting your computer, you should use your non-root userer to log in\u003c/p\u003e","title":"Alpine to Sway"},{"content":"Alpine Linux(UEFI) Semi-Automatic Installation Enter Installation Your login username is root, password is empty\nCheck UEFI test -d /sys/firmware/efi \u0026amp;\u0026amp; echo UEFI || echo BIOS Keyboard Layout Answer some questions\nsetup-keymap ## answer \u0026#39;us\u0026#39; twice Hostname setup-hostname \u0026lt;your_hostname\u0026gt; Networking Alpine Linux\u0026rsquo;s wiki recommend you using ethernet to connect internet\nBut you can also use setup-interfaces to use wireless connection Answer some questions\nsetup-interfaces After the configuration\nrc-service networking start rc-update add networking boot Apk Repositories You can find all repositories mirrors in here\nEdit /etc/apk/repositories\nvi /etc/apk/repositories For Chinese user, you can use example below\n# /etc/apk/repositories ... https://mirrors.aliyun.com/alpine/latest-stable/main https://mirrors.aliyun.com/alpine/latest-stable/community Finally, update your repositories\napk update Timezone We need to install tzdata\napk add tzdata Set your region info\ninstall -Dm 0644 /usr/share/zoneinfo/\u0026lt;Region\u0026gt;/\u0026lt;Country\u0026gt; /etc/zoneinfo/\u0026lt;Region\u0026gt;/\u0026lt;Country\u0026gt; export TZ=\u0026#39;\u0026lt;Region\u0026gt;/\u0026lt;Country\u0026gt;\u0026#39; echo \u0026#34;export TZ=\u0026#39;$TZ\u0026#39;\u0026#34; \u0026gt;\u0026gt; /etc/profile.d/timezone.sh For Chinese user\ninstall -Dm 0644 /usr/share/zoneinfo/Asia/Shanghai /etc/zoneinfo/Asia/Shanghai export TZ=\u0026#39;Asia/Shanghai\u0026#39; echo \u0026#34;export TZ=\u0026#39;$TZ\u0026#39;\u0026#34; \u0026gt;\u0026gt; /etc/profile.d/timezone.sh Root password passwd SSH Answer some questions\nsetup-sshd NTP Answer some questions\nsetup-ntp Disk Useful Tools Install some useful packages\napk add cfdisk dosfstools e2fsprogs e2fsprogs-extra Partition (Optional)\nIf you wish your Alpine Linux live with other Linux distributions, you can share your existing boot and swap partitions to Alpine Linux\nList All Disks and Partitions fdisk -l Change Partition Table You can use cfdisk to do this step.\ncfdisk /dev/\u0026lt;your_disk\u0026gt; Partition Table Example\nmount point partition type recommend size /mnt/boot /dev/efi_boot_partition EFI \u0026gt;=300M [SWAP] /dev/swap_partition Linux Swap \u0026gt;=512M /mnt /dev/root_partition Linux Filesystem space left Partition Table Example (With Home Partition)\nmount point partition type recommend size /mnt/boot /dev/efi_boot_partition EFI \u0026gt;=300M [SWAP] /dev/swap_partition Linux Swap \u0026gt;=512M /mnt /dev/root_partition Linux Filesystem space left /mnt/home /dev/home_partition Linux Filesystem space left Format For Boot Partition mkfs.fat -F 32 -n ALPINEBOOT /dev/efi_boot_partition For Swap Partition mkswap /dev/swap_partition For Root Partition mkfs.ext4 -L ALPINEROOT /dev/root_partition For Home Partition (If you have) mkfs.ext4 -L ALPINEHOME /dev/home_partition Mount Mount Root Partition mount /dev/root_partition /mnt Mount Boot Partition mkdir /mnt/boot mount /dev/boot_partition /mnt/boot Mount Swap Partition swapon /dev/swap_partition Mount Home Partition (If you have) mkdir /mnt/home mount /dev/home_partition /mnt/home Install Basic Package I only want Alpine Linux! setup-disk -m sys /mnt You can reboot your system now\nI already have other Linux distribution, and they share same grub partition Setting BOOTLOADER=none in order to make the script avoiding grub installation\nBOOTLOADER=none setup-disk -m sys /mnt Then, you can create a menuentry in /mnt/boot/grub/custom.cfg\nYou can use blkid to find your root partition UUID\n# /mnt/boot/grub/custom.cfg menuentry \u0026#34;Alpine Linux\u0026#34; { ## \u0026lt;-- You can change the name search --no-floppy --fs-uuid --set=root 88D1-11D6 # You must chage Boot Partition UUID above linux /vmlinuz-lts root=UUID=8de6973a-4a8c-40ed-b710-c4e2b42d6b7a modules=sd-mod,usb-storage,ext4 quiet # You must chage Root Partition UUID above initrd /initramfs-lts } ","permalink":"https://novel2430.github.io/notes/basic-alpinelinux-install/","summary":"\u003ch1 id=\"alpine-linuxuefi-semi-automatic-installation\"\u003eAlpine Linux(UEFI) Semi-Automatic Installation\u003c/h1\u003e\n\u003ch2 id=\"enter-installation\"\u003eEnter Installation\u003c/h2\u003e\n\u003cp\u003eYour login username is \u003ccode\u003eroot\u003c/code\u003e, password is empty\u003c/p\u003e\n\u003ch2 id=\"check-uefi\"\u003eCheck UEFI\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etest -d /sys/firmware/efi \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e echo UEFI \u003cspan style=\"color:#f92672\"\u003e||\u003c/span\u003e echo BIOS\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"keyboard-layout\"\u003eKeyboard Layout\u003c/h2\u003e\n\u003cp\u003eAnswer some questions\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esetup-keymap\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e## answer \u0026#39;us\u0026#39; twice\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"hostname\"\u003eHostname\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esetup-hostname \u0026lt;your_hostname\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"networking\"\u003eNetworking\u003c/h2\u003e\n\u003cp\u003eAlpine Linux\u0026rsquo;s wiki recommend you using ethernet to connect internet\u003cbr\u003e\nBut you can also use \u003ccode\u003esetup-interfaces\u003c/code\u003e to use wireless connection\nAnswer some questions\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esetup-interfaces\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eAfter the configuration\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003erc-service networking start\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003erc-update add networking boot\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"apk-repositories\"\u003eApk Repositories\u003c/h2\u003e\n\u003cp\u003eYou can find all repositories mirrors in \u003ca href=\"https://mirrors.alpinelinux.org/\"\u003ehere\u003c/a\u003e\u003cbr\u003e\nEdit \u003ccode\u003e/etc/apk/repositories\u003c/code\u003e\u003c/p\u003e","title":"Basic AlpineLinux (UEFI) Install"},{"content":"Applications on Wayfire Setup Wayfire Basic Environment [ App Menu ] (wofi) yay -S wofi # ~/.config/wayfire.ini ... # Start your launcher # https://hg.sr.ht/~scoopta/wofi # Note: Add mode=run or mode=drun to ~/.config/wofi/config. # You can also specify the mode with --show option. binding_launcher = \u0026lt;super\u0026gt; KEY_D # \u0026lt;-- Change key binding command_launcher = wofi --show drun # \u0026lt;-- Change exec command ... [ Web Browser ] (firefox) yay -S firefox Now you can use Wofi to open Firefox\n[ Notification ] (dunst) yay -S dunst libnotify Dunst\u0026rsquo;s config file =\u0026gt; ~/.config/dunst/dunstrc\nmkdir ~/.config/dunst cp /etc/dunst/dunstrc ~/.config/dunst/dunstrc Change notification app to dunst\n# ~/.config/wayfire.ini ... # Notifications # https://wayland.emersion.fr/mako/ notifications = mako # \u0026lt;-- change to dunst ... After restarting Wayfire, you can try sending notification\ndunstify \u0026#34;hello!\u0026#34; [ Autostart Script ] You can store your script anywhere, but I prefer store it in ~/.config/wayfire/autostart.sh\nmkdir ~/.config/wayfire touch ~/.config/wayfire/autostart.sh chmod +x ~/.config/wayfire/autostart.sh You need to specify script in ~/.config/wayfire.ini\n# ~/.config/wayfire.ini ... # Startup commands ───────────────────────────────────────────────────────────── [autostart] # Automatically start background and panel. # Set to false if you want to override the default clients. autostart_wf_shell = true # \u0026lt;-- You can set false my_autostart = ~/.config/wayfire/autostart.sh # \u0026lt;-- Add this line ... [ Wallpaper ] (swaybg) yay -S swaybg Our wallpaper should execute during Wayfire starting process, so we need to execute swaybg command in our autostart script.\n# ~/.config/wayfire/autostart.sh ### Wallpaper swaybg -i \u0026lt;your_wallpaper\u0026gt; \u0026amp; [ XDG-DESKTOP-PORTAL and Audio] yay -S xdg-desktop-portal xdg-desktop-portal-wlr xdg-desktop-portal-gtk The main reason setting up xdg-desktop-portal is to using desktop recorder such as Obs Studio\nSo, we need to start xdg-desktop-portal service and audio service in autostart script.\n# ~/.config/wayfire/autostart.sh ... ### XDG-DESKTOP-PORTAL dbus-update-activation-environment --systemd WAYLAND_DISPLAY XDG_CURRENT_DESKTOP=sway systemctl --user stop pipewire pipewire-pulse wireplumber xdg-desktop-portal xdg-desktop-portal-wlr xdg-desktop-portal-gtk systemctl --user start pipewire pipewire-pulse wireplumber xdg-desktop-portal xdg-desktop-portal-wlr xdg-desktop-portal-gtk For xdg-desktop-portal service, you can install obs-studio and try desktop recording\nFor audio service, you can run wpctl status and check the ouput.\n# Ouput of \u0026#39;wpctl status\u0026#39; ... Audio |- Devices: | ... |- Sinks: | * \u0026lt;something_here\u0026gt; ... [vol: 1.00] ... [ Bar ] (waybar) yay -S waybar You may need some special fonts to show icon.\n# Nerd Fonts - Ubuntu yay -S ttf-ubuntu-nerd You can copy two default config files in any place you want\ncp /etc/xdg/waybar/config.jsonc ~/.config/wayfire/waybar-config.jsonc cp /etc/xdg/waybar/style.css ~/.config/wayfire/waybar-style.css Put waybar command in autostart script\n# ~/.config/wayfire/autostart.sh ... ### Waybar waybar -c \u0026lt;your_waybar_config\u0026gt; -s \u0026lt;your_waybar_style\u0026gt; \u0026amp; [ Network Applet ] (network-manager-applet) network-manager-applet is a small tool to configure your network connection in GUI\nyay -S network-manager-applet Add command in your autostart script\n# ~/.config/wayfire/autostart.sh ... ### NetworkManager Applet nm-applet \u0026amp; [ Audio Control ] (pavucontrol) pavucontrol is a small tool to configure your audio optput device in GUI\nyay -S pavucontrol [ Bluetooth ] (bluez bluez-obex blueman) yay -S bluez bluez-obex blueman Enable bluez service\nsystemctl enable bluetooth.service systemctl start bluetooth.service Edit your autostart script\n# ~/.config/wayfire/autostart.sh ... ### Bluetooth systemctl --user restart dbus-org.bluez.obex.service systemctl --user restart blueman-applet.service Edit your Dunst\u0026rsquo;s config file (For bluetooth message actions)\n# ~/.config/dunst/dunstrc ... ### Misc/Advanced ### # dmenu path. dmenu = /usr/bin/wofi -dmenu # \u0026lt;-- Change here to wofi ... By default, mouse middle click event triggers notify action\n# ~/.config/dunst/dunstrc ... ### mouse # Defines list of actions for each mouse event # Possible values are: # * none: Don\u0026#39;t do anything. # * do_action: Invoke the action determined by the action_name rule. If there is no # such action, open the context menu. # * open_url: If the notification has exactly one url, open it. If there are multiple # ones, open the context menu. # * close_current: Close current notification. # * close_all: Close all notifications. # * context: Open context menu for the notification. # * context_all: Open context menu for all notifications. # These values can be strung together for each mouse event, and # will be executed in sequence. mouse_left_click = close_current mouse_middle_click = do_action, close_current # \u0026lt;-- Here mouse_right_click = close_all ... (For Chinese User) [ Fcitx5 ] You may want read wiki link\n# For Pinyin yay -S fcitx5 fcitx5-qt fcitx5-gtk fcitx5-chinese-addons fcitx5-configtool # For Chewing yay -S fcitx5 fcitx5-qt fcitx5-gtk fcitx5-chinese-addons fcitx5-configtool fcitx5-chewing You can edit your ~/.bashrc (For Bash User) or ~/.zshrc (For Zsh User) to add fcitx5 environment variables\n# ~/.bashrc ... export GTK_IM_MODULE=\u0026#34;fcitx\u0026#34; export QT_IM_MODULE=\u0026#34;fcitx\u0026#34; export XMODIFIERS=\u0026#34;@im=fcitx\u0026#34; export SDL_IM_MODULE=\u0026#34;fcitx\u0026#34; export INPUT_METHOD=\u0026#34;fcitx\u0026#34; Do not forget source ~/.bashrc or source ~/.zshrc\nEdit your wayfire config to enable input method plugin\n# ~/.config/wayfire.ini ... # List of plugins to be enabled. # See the Configuration document for a complete list. plugins = \\ alpha \\ animate \\ autostart \\ command \\ cube \\ decoration \\ expo \\ fast-switcher \\ fisheye \\ foreign-toplevel \\ grid \\ gtk-shell \\ idle \\ invert \\ move \\ oswitch \\ place \\ resize \\ switcher \\ vswitch \\ wayfire-shell \\ window-rules \\ wm-actions \\ wobbly \\ wrot \\ zoom \\ input-method-v1 # \u0026lt;-- add this line Finally, add Fcitx5 in your autostart script\n# ~/.config/wayfire/autostart.sh ... ### Fcitx5 fcitx5 --replace -d \u0026amp; ","permalink":"https://novel2430.github.io/notes/basic-wayfire-applications/","summary":"\u003ch1 id=\"applications-on-wayfire\"\u003eApplications on Wayfire\u003c/h1\u003e\n\u003ch2 id=\"setup-wayfire-basic-environment\"\u003eSetup Wayfire Basic Environment\u003c/h2\u003e\n\u003ch3 id=\"-app-menu--wofi\"\u003e[ App Menu ] (wofi)\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eyay -S wofi\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# ~/.config/wayfire.ini\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ...\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Start your launcher\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# https://hg.sr.ht/~scoopta/wofi\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Note: Add mode=run or mode=drun to ~/.config/wofi/config.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# You can also specify the mode with --show option.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ebinding_launcher \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u0026lt;super\u0026gt; KEY_D \u003cspan style=\"color:#75715e\"\u003e# \u0026lt;-- Change key binding\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecommand_launcher \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e wofi --show drun \u003cspan style=\"color:#75715e\"\u003e# \u0026lt;-- Change exec command\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ...\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"-web-browser--firefox\"\u003e[ Web Browser ] (firefox)\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eyay -S firefox\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow you can use \u003ccode\u003eWofi\u003c/code\u003e to open \u003ccode\u003eFirefox\u003c/code\u003e\u003c/p\u003e","title":"Basic Wayfire Applications"},{"content":"Basic ArchLinux(UEFI) + WayFire Install Basic Arch Install [ Check UEFI or BIOS ] ls /sys/firmware/efi/efivars If the directory not exist, you are not in UEFI mode.\n[ Internet ] Check system activate internet interface ip link For Ethernet (DHCP) Good to go!\nFor WiFi (iwd) enter interactive prompt\niwctl list all wifi device\n[iwd] device list select the device you want to use, i.e: wlan0\nand start scanning\n[iwd] station \u0026lt;device\u0026gt; scan after scanning, you can list all available networks\n[iwd] station \u0026lt;device\u0026gt; get-networks connect one network\n[iwd] station \u0026lt;device\u0026gt; connect \u0026lt;network-name\u0026gt; leave iwclt\n[iwd] exit Ping test ping archlinux.org [ Update System Time ] timedatectl set-ntp true [ Partition ] List All Disks and Partitions fdisk -l Change Partition Table You can use cfdisk to do this step.\ncfdisk /dev/\u0026lt;your_disk\u0026gt; Partition Table Example\nmount point partition type recommend size /mnt/boot /dev/efi_boot_partition EFI \u0026gt;=300M [SWAP] /dev/swap_partition Linux Swap \u0026gt;=512M /mnt /dev/root_partition Linux Filesystem space left Partition Table Example (With Home Partition)\nmount point partition type recommend size /mnt/boot /dev/efi_boot_partition EFI \u0026gt;=300M [SWAP] /dev/swap_partition Linux Swap \u0026gt;=512M /mnt /dev/root_partition Linux Filesystem space left /mnt/home /dev/home_partition Linux Filesystem space left Format Partitions For Boot Partition mkfs.fat -F 32 -n ARCHBOOT /dev/efi_boot_partition For Swap Partition mkswap /dev/swap_partition For Root Partition mkfs.ext4 -L ARCHROOT /dev/root_partition For Home Partition (If you have) mkfs.ext4 -L ARCHHOME /dev/home_partition Mount Partitions Mount Root Partition mount /dev/disk/by-label/ARCHROOT /mnt Mount Boot Partition mkdir /mnt/boot mount /dev/disk/by-label/ARCHBOOT /mnt/boot Mount Swap Partition swapon /dev/swap_partition Mount Home Partition (If you have) mkdir /mnt/home mount /dev/disk/by-label/ARCHHOME /mnt/home [ Install Basic Package ] (Optional) Setup Mirrorlist edit /etc/pacman.d/mirrorlist file\nExample For Chinese User:\n# /etc/pacman.d/mirrorlist Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch Install Packages pacstrap /mnt base linux linux-firmware networkmanager vim man-db man-pages texinfo base, linux, linux-firmware\nmust install\nnetworkmanager\nfor internet\nvim\ntext editor, or you can choose nano\nman-db, man-pages, texinfo\nFor man page\n[ Generate Fstab ] genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab [ Chroot to System ] arch-chroot /mnt [ Timezone ] ln -sf /usr/share/zoneinfo/\u0026lt;Your_Region\u0026gt;/\u0026lt;Your_City\u0026gt; /etc/localtime Example For Chinese User:\nln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime run hwclock to generate /etc/adjtime\nhwclock --systohc [ Locale ] edit the file /etc/locale.gen, uncomment en_US.UTF-8 UTF-8 run locale-gen to generate locale info locale-gen build /etc/locale.conf file, set the variable LANG # /etc/locale.conf LANG=en_US.UTF-8 [ Host Name ] build /etc/hostname file\n# /etc/hostname \u0026lt;your_host_name\u0026gt; [ Set Root User Password ] passwd [ Enable NetworkManager Service ] systemctl enable NetworkManager.service We are now in chroot, so we do not need to start NetworkManager service. After bootloader installed and reboot to system, the NetworkManager will start automatically.\n[ Install Microcode ] For AMD User pacman -S amd-ucode For Intel User pacman -S intel-ucode [ Install Grub ] pacman -S grub efibootmgr (Optional) os-prober \u0026ndash; For Dual Boot pacman -S os-prober If you want dual boot with Windows OS, you may need ntfs-3g\npacman -S ntfs-3g [ Messing with GRUB :( ] I only need LINUX! (No Dual Boot) install grub on your boot partition # command below is for x86_64 user # you can find more info in https://wiki.archlinux.org/title/GRUB grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB generate /boot/grub/grub.cfg grub-mkconfig -o /boot/grub/grub.cfg I cannot leave windows\u0026hellip; (Dual Boot) NOTE: Setup Dual Booting always has many problems, the following guidance is only for reference.\ninstall grub on your boot partition # command below is for x86_64 user # you can find more info in https://wiki.archlinux.org/title/GRUB grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB edit /etc/default/grub # /etc/default/grub ... # Probing for other operating systems is disabled for security reasons. Read # documentation on GRUB_DISABLE_OS_PROBER, if still want to enable this # functionality install os-prober and uncomment to detect and include other # operating systems. GRUB_DISABLE_OS_PROBER=false # \u0026lt;-- Uncomment this Line generate /boot/grub/grub.cfg grub-mkconfig -o /boot/grub/grub.cfg # You must make sure os-prober find your windowsOS boot partition [ Reboot ] leave chroot exit umount /mnt umount -R /mnt swapoff swapoff /dev/swap_partition shutdown shutdown now reboot your computer\n(Make sure you unplugged your Arch Linux Installer USB drive)\nIf everything go well, you will see GRUB menu after booting. Setup Basic Destop Environment [ Root Login ] We only have user root right now, use root account to log in\n[ Check Internet ] Normally, NetworkManager.service will start automatically, you can use ping to check your internet connection\n# ping example ping archlinux.org You can use nmtui to configure your connection\n[ Neofetch ] \u0026lt;\u0026ndash; VERY IMPORTANT!!! pacman -S neofetch neofetch If you don\u0026rsquo;t hava neofetch, you are not using Arch :)\n[ GPU Card ] If you are not using NVIDIA card, GOOOOOOD!!\nI\u0026rsquo;m not familiar with AMD gpu\u0026hellip;Please read wiki!\nonly Nvidia pacman -S mesa-utils nvidia nvidia-utils (Optional) You may need nvtop to be coooool(?)\npacman -S nvtop After the installation, you need to reboot you computer\nonly AMD Please read the wiki (AMD GPU) first :)\nlink\npacman -S mesa mesa-utils For Vulkan support\npacman -S vulkan-radeon Intel+NVIDIA Please read the wiki (INTEL GPU) first :)\nlink\nFor our Intel card (with Vulkan)\npacman -S mesa mesa-utils vulkan-intel For our Nvidia card :(\npacman -S mesa-utils nvidia nvidia-utils nvidia-prime (Optional) You may need nvtop to be coooool(?)\npacman -S nvtop You can use prime-run \u0026lt;command\u0026gt; to run stuff on Nvidia card\nAfter the installation, you need to reboot you computer\n[ Audio ] Install Some Basic Packages pacman -S alsa-utils alsa-firmware sof-firmware alsa-ucm-conf Pipewire and Wireplumber pacman -S pipewire wireplumber pipewire-pulse [ Sudo ] Install Sudo pacman -S sudo Create one normal user useradd -m -G wheel -s /bin/bash \u0026lt;new_user_name\u0026gt; set this user\u0026rsquo;s password\npasswd \u0026lt;new_user_name\u0026gt; Edit sudo file edit file\nEDITOR=vim visudo uncomment one line in sudo file\n# In visudo ... ### ### User privilege specification ### root ALL=(ALL:ALL) ALL ## Uncomment to allow members of group wheel to execute any command %wheel ALL=(ALL:ALL) ALL # \u0026lt;-- uncomment this line ... Log out user root After installed Sudo, now we can use new user account to do stuff\nexit (For Chinese User) [ Clash ] We need a good way to Love GFW \u0026hellip;\nsudo pacman -S curl clash You can use curl to get your config.yaml\ncd \u0026lt;your_clash_directory\u0026gt; curl https://gitee.com/mirrors/Pingtunnel/raw/master/GeoLite2-Country.mmdb \u0026gt; ./Country.mmdb curl \u0026lt;your_sub_url\u0026gt; \u0026gt; ./config.yaml Edit clash systemd unit\nsudo vim /etc/systemd/user/clash.service # /etc/systemd/user/clash.service [Unit] Description=Clash, Good Way to Love GFW After=network.target [Service] Type=simple Restart=on-abort ExecStart=/usr/bin/clash -d \u0026lt;your_clash_directory\u0026gt; [Install] WantedBy=multi-user.target Reload Daemon\nsystemctl --user daemon-reload Start Clash Service\nsystemctl --user start clash.service Check Clash Service\nsystemctl --user status clash.service Set Clash as your current system porxy\nexport http_proxy=http://127.0.0.1:7890 export https_proxy=http://127.0.0.1:7890 [ YAY (AUR Helper) ] link\nsudo pacman -S --needed git base-devel git clone https://aur.archlinux.org/yay.git cd yay makepkg -si After installed yay, we can use yay -S 'package' instead of sudo pacman -S 'package'\n(For Chinese User) [ Chinese Fonts ] yay -S wqy-zenhei [ Wayfire ] install wayland packages yay -S wayland wayland-protocals xorg-xwayland install wayfire yay -S wayfire install basic font (For terminal emulator) yay -S ttf-dejavu install terminal emulator There are many terminal emulators on arch, such as Alacritty, Kitty, Foot \u0026hellip;\n# I prefer foot yay -S foot download default config file curl https://raw.githubusercontent.com/WayfireWM/wayfire/master/wayfire.ini \u0026gt; ~/.config/wayfire.ini set default terminal emulator edit ~/.config/wayfire.ini\n# ~/.config/wayfire.ini ... # Applications ───────────────────────────────────────────────────────────────── [command] # Start a terminal # https://github.com/alacritty/alacritty binding_terminal = \u0026lt;super\u0026gt; KEY_ENTER command_terminal = alacritty # \u0026lt;-- Change Here ... Run Wayfire wayfire If you use QEMU to run wayfire\nWLR_RENDERER_ALLOW_SOFTWARE=1 wayfire ","permalink":"https://novel2430.github.io/notes/basic-archlinux-wayfire-install/","summary":"\u003ch1 id=\"basic-archlinuxuefi--wayfire-install\"\u003eBasic ArchLinux(UEFI) + WayFire Install\u003c/h1\u003e\n\u003ch2 id=\"basic-arch-install\"\u003eBasic Arch Install\u003c/h2\u003e\n\u003ch3 id=\"-check-uefi-or-bios-\"\u003e[ Check UEFI or BIOS ]\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003els /sys/firmware/efi/efivars\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIf the directory not exist, you are not in UEFI mode.\u003c/p\u003e\n\u003ch3 id=\"-internet-\"\u003e[ Internet ]\u003c/h3\u003e\n\u003ch4 id=\"check-system-activate-internet-interface\"\u003eCheck system activate internet interface\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eip link\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"for-ethernet-dhcp\"\u003eFor Ethernet (DHCP)\u003c/h4\u003e\n\u003cp\u003eGood to go!\u003c/p\u003e\n\u003ch4 id=\"for-wifi-iwd\"\u003eFor WiFi (iwd)\u003c/h4\u003e\n\u003cp\u003eenter interactive prompt\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eiwctl\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003elist all wifi device\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eiwd\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e device list\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eselect the device you want to use, i.e: wlan0\u003cbr\u003e\nand start scanning\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eiwd\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e station \u0026lt;device\u0026gt; scan\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eafter scanning, you can list all available networks\u003c/p\u003e","title":"Basic Archlinux Wayfire Install"},{"content":"Song - Cozy A little song for my ex.\nI hope you can be happy even when I\u0026rsquo;m not with you 🫠 ","permalink":"https://novel2430.github.io/ideas/cozy/","summary":"\u003ch1 id=\"song---cozy\"\u003eSong - Cozy\u003c/h1\u003e\n\u003cp\u003eA little song for my ex.\u003cbr\u003e\nI hope you can be happy even when I\u0026rsquo;m not with you 🫠\n\u003cimg alt=\"img\" loading=\"lazy\" src=\"https://cloud.yejsgk.top/f/eZT0/20231225232420_small.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003caudio controls src=\"https://cloud.yejsgk.top/f/4jha/Cozy.mp3\"\u003e\u003c/audio\u003e\u003c/p\u003e","title":"Cozy"},{"content":"7-1 Replacement Selection When the input is much too large to fit into memory, we have to do external sorting instead of internal sorting. One of the key steps in external sorting is to generate sets of sorted records (also called runs) with limited internal memory. The simplest method is to read as many records as possible into the memory, and sort them internally, then write the resulting run back to some tape. The size of each run is the same as the capacity of the internal memory.\nReplacement Selection sorting algorithm was described in 1965 by Donald Knuth. Notice that as soon as the first record is written to an output tape, the memory it used becomes available for another record. Assume that we are sorting in ascending order, if the next record is not smaller than the record we have just output, then it can be included in the run.\nFor example, suppose that we have a set of input { 81, 94, 11, 96, 12, 99, 35 }, and our memory can sort 3 records only. By the simplest method we will obtain three runs: { 11, 81, 94 }, { 12, 96, 99 } and { 35 }. According to the replacement selection algorithm, we would read and sort the first 3 records { 81, 94, 11 } and output 11 as the smallest one. Then one space is available so 96 is read in and will join the first run since it is larger than 11. Now we have { 81, 94, 96 }. After 81 is out, 12 comes in but it must belong to the next run since it is smaller than 81. Hence we have { 94, 96, 12 } where 12 will stay since it belongs to the next run. When 94 is out and 99 is in, since 99 is larger than 94, it must belong to the first run. Eventually we will obtain two runs: the first one contains { 11, 81, 94, 96, 99 } and the second one contains { 12, 35 }.\nYour job is to implement this replacement selection algorithm.\nInput Specification: Each input file contains several test cases. The first line gives two positive integers N (≤105) and M (\u0026lt;N/2), which are the total number of records to be sorted, and the capacity of the internal memory. Then N numbers are given in the next line, all in the range of int. All the numbers in a line are separated by a space.\nOutput Specification: For each test case, print in each line a run (in ascending order) generated by the replacement selection algorithm. All the numbers in a line must be separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line.\nSample Input: 13 3 81 94 11 96 12 99 17 35 28 58 41 75 15 Sample Output: 11 81 94 96 99 12 17 28 35 41 58 75 15 Code #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MAXN 500000 typedef enum Boolean{FALSE, TRUE} Boolean ; typedef int DataValue ; typedef struct Heap{ DataValue nodes[MAXN]; int size; }Heap; Heap* heap_init(){ Heap* res = (Heap*)malloc(sizeof(Heap)); res-\u0026gt;size = 0; return res; }; void heap_delete(Heap* heap){ if(heap==NULL) return; free(heap); heap = NULL; } void swap(Heap* heap, int idx1, int idx2){ if(heap==NULL) return; DataValue tmp = heap-\u0026gt;nodes[idx1]; heap-\u0026gt;nodes[idx1] = heap-\u0026gt;nodes[idx2]; heap-\u0026gt;nodes[idx2] = tmp; } int min_idx(Heap* heap, int idx1, int idx2){ if(heap-\u0026gt;nodes[idx1] \u0026lt; heap-\u0026gt;nodes[idx2]) return idx1; return idx2; } void heap_insert(Heap* heap, DataValue data){ if(heap==NULL) return; heap-\u0026gt;size++; heap-\u0026gt;nodes[heap-\u0026gt;size] = data; for(int idx=heap-\u0026gt;size; idx\u0026gt;1; idx=idx/2){ DataValue cur = heap-\u0026gt;nodes[idx]; DataValue parent = heap-\u0026gt;nodes[idx/2]; if(parent\u0026gt;cur) swap(heap, idx, idx/2); else break; } } DataValue heap_pop(Heap* heap){ DataValue res = heap-\u0026gt;nodes[1]; swap(heap, 1, heap-\u0026gt;size); for(int idx=1; idx*2\u0026lt;heap-\u0026gt;size; ){ int next_idx = idx; if(idx*2+1\u0026lt;heap-\u0026gt;size){ next_idx = min_idx(heap, idx*2, idx*2+1); } else if(heap-\u0026gt;nodes[idx]\u0026gt;heap-\u0026gt;nodes[idx*2]){ next_idx = idx*2; } if(heap-\u0026gt;nodes[idx] \u0026gt; heap-\u0026gt;nodes[next_idx]) swap(heap, idx, next_idx); else break; idx = next_idx; } heap-\u0026gt;size--; return res; } Boolean heap_is_empty(Heap* heap){ if(heap-\u0026gt;size==0) return TRUE; return FALSE; } void replacement_selection(int* arr, int size, int capacity){ Heap* heap1 = heap_init(); Heap* heap2 = heap_init(); for(int i=0; i\u0026lt;size\u0026amp;\u0026amp;i\u0026lt;capacity; i++) heap_insert(heap1, arr[i]); int cur_idx = capacity; while(!heap_is_empty(heap1) || !heap_is_empty(heap2)){ int print_num_count = 0; int flag = 0; while(!heap_is_empty(heap1)){ int cur_min = heap_pop(heap1); flag = 1; if(cur_idx \u0026lt; size){ int cur_num = arr[cur_idx++]; if(cur_min \u0026lt; cur_num) heap_insert(heap1, cur_num); else heap_insert(heap2, cur_num); } if(print_num_count++ \u0026gt; 0) printf(\u0026#34; \u0026#34;); printf(\u0026#34;%d\u0026#34;, cur_min); } if(flag) printf(\u0026#34;\\n\u0026#34;); print_num_count = 0; flag = 0; while(!heap_is_empty(heap2)){ flag = 1; int cur_min = heap_pop(heap2); if(cur_idx \u0026lt; size){ int cur_num = arr[cur_idx++]; if(cur_min \u0026lt; cur_num) heap_insert(heap2, cur_num); else heap_insert(heap1, cur_num); } if(print_num_count++ \u0026gt; 0) printf(\u0026#34; \u0026#34;); printf(\u0026#34;%d\u0026#34;, cur_min); } if(flag) printf(\u0026#34;\\n\u0026#34;); } heap_delete(heap1); heap_delete(heap2); } int main(int argc, char *argv[]){ int size, capacity; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;size, \u0026amp;capacity); int arr[MAXN]; for(int i=0; i\u0026lt;size; i++){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;arr[i]); } replacement_selection(arr, size, capacity); return 0; } ","permalink":"https://novel2430.github.io/notes/replacement-selection/","summary":"\u003ch1 id=\"7-1-replacement-selection\"\u003e7-1 Replacement Selection\u003c/h1\u003e\n\u003cp\u003eWhen the input is much too large to fit into memory, we have to do \u003cstrong\u003eexternal sorting\u003c/strong\u003e instead of internal sorting. One of the key steps in external sorting is to generate sets of sorted records (also called runs) with limited internal memory. The simplest method is to read as many records as possible into the memory, and sort them internally, then write the resulting run back to some tape. The size of each run is the same as the capacity of the internal memory.\u003cbr\u003e\n\u003cstrong\u003eReplacement Selection\u003c/strong\u003e sorting algorithm was described in 1965 by Donald Knuth. Notice that as soon as the first record is written to an output tape, the memory it used becomes available for another record. Assume that we are sorting in ascending order, if the next record is not smaller than the record we have just output, then it can be included in the run.\u003cbr\u003e\nFor example, suppose that we have a set of input { 81, 94, 11, 96, 12, 99, 35 }, and our memory can sort 3 records only. By the simplest method we will obtain three runs: { 11, 81, 94 }, { 12, 96, 99 } and { 35 }. According to the replacement selection algorithm, we would read and sort the first 3 records { 81, 94, 11 } and output 11 as the smallest one. Then one space is available so 96 is read in and will join the first run since it is larger than 11. Now we have { 81, 94, 96 }. After 81 is out, 12 comes in but it must belong to the next run since it is smaller than 81. Hence we have { 94, 96, 12 } where 12 will stay since it belongs to the next run. When 94 is out and 99 is in, since 99 is larger than 94, it must belong to the \u003cstrong\u003efirst run\u003c/strong\u003e. Eventually we will obtain two runs: the first one contains { 11, 81, 94, 96, 99 } and the second one contains { 12, 35 }.\u003cbr\u003e\nYour job is to implement this replacement selection algorithm.\u003c/p\u003e","title":"Replacement Selection"},{"content":"7-1 Queue Using Two Stacks A queue (FIFO structure) can be implemented by two stacks (LIFO structure) in the following way:\nStart from two empty stacks s1 and s2\nWhen element e is enqueued, it is actually pushed onto s1\nWhen we are supposed to dequeue, s2 is checked first. If s2 is empty, everything in s1 will be transferred to s2 by popping from s1 and immediately pushing onto s2. Then we just pop from s2 \u0026ndash; the top element of s2 must be the first one to enter s1 thus is the first element that was enqueued.\nAssume that each operation of push or pop takes 1 unit of time. You job is to tell the time taken for each dequeue.\nInput Specification: Each input file contains one test case. For each case, the first line gives a positive integer N (≤103), which are the number of operations. Then N lines follow, each gives an operation in the format\nOperation Element where Operation being I represents enqueue and O represents dequeue. For each I, Element is a positive integer that is no more than 106. No Element is given for O operations.\nIt is guaranteed that there is at least one O operation.\nOutput Specification: For each dequeue operation, print in a line the dequeued element and the unites of time taken to do this dequeue. The numbers in a line must be separated by 1 space, and there must be no extra space at the beginning or the end of the line.\nIn case that the queue is empty when dequeue is called, output in a line ERROR instead.\nSample Input: 10 I 20 I 32 O I 11 O O O I 100 I 66 O Sample Output: 20 5 32 1 11 3 ERROR 100 5 Code #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // Basic Struct typedef struct stack_node{ int values; struct stack_node* next; struct stack_node* before; }stack_node; typedef struct my_stack { stack_node* head; stack_node* top; }my_stack; typedef struct my_queue { my_stack* stack1; my_stack* stack2; int op_count; }my_queue; // Node op stack_node* node_init(int num){ stack_node* node = (stack_node*)malloc(sizeof(stack_node)); node-\u0026gt;values = num; node-\u0026gt;next = NULL; node-\u0026gt;before = NULL; return node; } void node_delete(stack_node* node){ if(node==NULL) return; free(node); node = NULL; } // Stack op my_stack* stack_init(){ my_stack* res = (my_stack*)malloc(sizeof(my_stack)); res-\u0026gt;head = node_init(0); res-\u0026gt;top = res-\u0026gt;head; return res; } void stack_delete(my_stack* stack){ if(stack==NULL) return; stack_node* cur = stack-\u0026gt;head; while(cur != NULL){ stack_node* next_node = cur-\u0026gt;next; node_delete(cur); cur = next_node; } free(stack); stack = NULL; } void stack_push(my_stack* stack, int num){ stack-\u0026gt;head-\u0026gt;values++; stack_node* node = node_init(num); stack-\u0026gt;top-\u0026gt;next = node; node-\u0026gt;before = stack-\u0026gt;top; stack-\u0026gt;top = node; } int stack_pop(my_stack* stack){ stack-\u0026gt;head-\u0026gt;values--; int res = stack-\u0026gt;top-\u0026gt;values; stack_node* old_top = stack-\u0026gt;top; stack_node* new_top = stack-\u0026gt;top-\u0026gt;before; node_delete(old_top); stack-\u0026gt;top = new_top; stack-\u0026gt;top-\u0026gt;next = NULL; return res; } int stack_is_empty(my_stack* stack){ if(stack==NULL || stack-\u0026gt;head!=stack-\u0026gt;top){ return 0; } return 1; } // Queue op my_queue* queue_init(){ my_queue* res = (my_queue*)malloc(sizeof(my_queue)); res-\u0026gt;stack1 = stack_init(); res-\u0026gt;stack2 = stack_init(); res-\u0026gt;op_count = 0; return res; } void queue_delete(my_queue* queue){ if(queue == NULL) return; stack_delete(queue-\u0026gt;stack1); stack_delete(queue-\u0026gt;stack2); free(queue); queue = NULL; } void queue_push(my_queue* queue, int num){ stack_push(queue-\u0026gt;stack1, num); } int queue_pop(my_queue* queue){ queue-\u0026gt;op_count = 0; if(stack_is_empty(queue-\u0026gt;stack1) \u0026amp;\u0026amp; stack_is_empty(queue-\u0026gt;stack2)) return -1; if(stack_is_empty(queue-\u0026gt;stack2)){ queue-\u0026gt;op_count = queue-\u0026gt;stack1-\u0026gt;head-\u0026gt;values*2; while(!stack_is_empty(queue-\u0026gt;stack1)){ stack_push(queue-\u0026gt;stack2, stack_pop(queue-\u0026gt;stack1)); } } queue-\u0026gt;op_count++; return stack_pop(queue-\u0026gt;stack2); } int main(){ int op_counts = 0; my_queue* queue = queue_init(); scanf(\u0026#34;%d\u0026#34;, \u0026amp;op_counts); int print_count = 0; for(int i=0; i\u0026lt;op_counts; i++){ /* printf(\u0026#34;Time : %d\\n\u0026#34;,i); */ getchar(); char op; scanf(\u0026#34;%c\u0026#34;, \u0026amp;op); if(op==\u0026#39;I\u0026#39;){ int num; scanf(\u0026#34;%d\u0026#34;, \u0026amp;num); queue_push(queue, num); } else if(op==\u0026#39;O\u0026#39;){ int num = queue_pop(queue); if(num==-1){ if(print_count\u0026gt;0) printf(\u0026#34;\\nERROR\u0026#34;); else printf(\u0026#34;ERROR\u0026#34;); } else { if(print_count\u0026gt;0) printf(\u0026#34;\\n%d %d\u0026#34;,num, queue-\u0026gt;op_count); else printf(\u0026#34;%d %d\u0026#34;,num, queue-\u0026gt;op_count); } print_count++; } } queue_delete(queue); return 0; } ","permalink":"https://novel2430.github.io/notes/queue-using-two-stacks/","summary":"\u003ch1 id=\"7-1-queue-using-two-stacks\"\u003e7-1 Queue Using Two Stacks\u003c/h1\u003e\n\u003cp\u003eA queue (FIFO structure) can be implemented by two stacks (LIFO structure) in the following way:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eStart from two empty stacks s\u003csub\u003e1\u003c/sub\u003e and s\u003csub\u003e2\u003c/sub\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWhen element \u003ccode\u003ee\u003c/code\u003e is enqueued, it is actually pushed onto s\u003csub\u003e1\u003c/sub\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWhen we are supposed to dequeue, s\u003csub\u003e2\u003c/sub\u003e is checked first. If s\u003csub\u003e2\u003c/sub\u003e is empty, everything in s\u003csub\u003e1\u003c/sub\u003e will be transferred to s\u003csub\u003e2\u003c/sub\u003e by popping from s\u003csub\u003e1\u003c/sub\u003e and immediately pushing onto s\u003csub\u003e2\u003c/sub\u003e. Then we just pop from s\u003csub\u003e2\u003c/sub\u003e \u0026ndash; the top element of s\u003csub\u003e2\u003c/sub\u003e must be the first one to enter s\u003csub\u003e1\u003c/sub\u003e thus is the first element that was enqueued.\u003c/p\u003e","title":"Queue Using Two Stacks"},{"content":"7-1 Hashing - Hard Version Given a hash table of size N, we can define a hash function H(x)=x%N. Suppose that the linear probing is used to solve collisions, we can easily obtain the status of the hash table with a given sequence of input numbers.\nHowever, now you are asked to solve the reversed problem: reconstruct the input sequence from the given status of the hash table. Whenever there are multiple choices, the smallest number is always taken.\nInput Specification: Each input file contains one test case. For each test case, the first line contains a positive integer N (≤1000), which is the size of the hash table. The next line contains N integers, separated by a space. A negative integer represents an empty cell in the hash table. It is guaranteed that all the non-negative integers are distinct in the table.\nOutput Specification: For each test case, print a line that contains the input sequence, with the numbers separated by a space. Notice that there must be no extra space at the end of each line.\nSample Input: 11 33 1 13 12 34 38 27 22 32 -1 21 Sample Output: 1 13 12 21 33 34 38 27 22 32 Code #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MAXN 1000 typedef enum Boolean {FALSE, TRUE} Boolean ; typedef struct Node{ int value; int before_count; int after_count; struct Node* after[MAXN]; }Node ; typedef struct Heap{ int size; Node* nodes[MAXN]; }Heap ; Node* node_init(int value){ Node* res = (Node*)malloc(sizeof(Node)); res-\u0026gt;value = value; res-\u0026gt;after_count = 0; res-\u0026gt;before_count = 0; return res; } void node_delete(Node* node){ if(node==NULL) return; free(node); node = NULL; } void node_add_after(Node* cur, Node* after){ if(cur==NULL || after==NULL) return; cur-\u0026gt;after[cur-\u0026gt;after_count] = after; cur-\u0026gt;after_count++; after-\u0026gt;before_count++; } Heap* heap_init(){ Heap* res = (Heap*)malloc(sizeof(Heap)); res-\u0026gt;size = 0; return res; } void heap_delete(Heap* heap){ if(heap==NULL) return; for(int i=0; i\u0026lt;heap-\u0026gt;size; i++) node_delete(heap-\u0026gt;nodes[i]); free(heap); heap = NULL; } Boolean heap_is_empty(Heap* heap){ if(heap-\u0026gt;size==0) return TRUE; return FALSE; } int min_idx(Heap* heap, int idx1, int idx2){ if(heap-\u0026gt;nodes[idx1]-\u0026gt;value \u0026lt; heap-\u0026gt;nodes[idx2]-\u0026gt;value) return idx1; return idx2; } void swap(Heap* heap, int idx1, int idx2){ Node* tmp = heap-\u0026gt;nodes[idx1]; heap-\u0026gt;nodes[idx1] = heap-\u0026gt;nodes[idx2]; heap-\u0026gt;nodes[idx2] = tmp; } void heap_insert(Heap* heap, Node* node){ if(heap==NULL || node==NULL) return; heap-\u0026gt;nodes[heap-\u0026gt;size] = node; for(int i=heap-\u0026gt;size; i\u0026gt;0; i=(i-1)/2){ Node* cur = heap-\u0026gt;nodes[i]; Node* father = heap-\u0026gt;nodes[(i-1)/2]; if(cur-\u0026gt;value \u0026gt;= father-\u0026gt;value) break; swap(heap, i, (i-1)/2); } heap-\u0026gt;size++; } Node* heap_pop(Heap* heap){ if(heap==NULL || heap-\u0026gt;size==0) return NULL; heap-\u0026gt;size--; Node* res = heap-\u0026gt;nodes[0]; swap(heap, 0, heap-\u0026gt;size); int next = 0; for(int i=0; i*2+1\u0026lt;heap-\u0026gt;size; i=next){ if(i*2+2 \u0026lt; heap-\u0026gt;size) next = min_idx(heap, i*2+1, i*2+2); else next = i*2+1; if(heap-\u0026gt;nodes[i]-\u0026gt;value \u0026lt;= heap-\u0026gt;nodes[next]-\u0026gt;value) break; swap(heap, i, next); } return res; } void build_node_reletions(Node* nodes[MAXN], int size){ for(int i=0; i\u0026lt;size; i++){ Node* cur = nodes[i]; if(cur==NULL) continue; int dist = i - cur-\u0026gt;value%size; if(dist \u0026lt; 0) dist = size + dist; for(int ii=cur-\u0026gt;value%size; ii\u0026lt;(cur-\u0026gt;value%size)+dist; ii++){ int idx = ii%size; node_add_after(nodes[idx], cur); } } } void build_input_seq(Node* nodes[MAXN], int size){ Heap* heap = heap_init(); for(int i=0; i\u0026lt;size; i++){ if(nodes[i]==NULL) continue; if(nodes[i]-\u0026gt;before_count==0) heap_insert(heap, nodes[i]); } int count = 0; while(!heap_is_empty(heap)){ Node* cur = heap_pop(heap); for(int i=0; i\u0026lt;cur-\u0026gt;after_count; i++){ cur-\u0026gt;after[i]-\u0026gt;before_count--; if(cur-\u0026gt;after[i]-\u0026gt;before_count==0) heap_insert(heap, cur-\u0026gt;after[i]); } if(count \u0026gt; 0) printf(\u0026#34; \u0026#34;); printf(\u0026#34;%d\u0026#34;, cur-\u0026gt;value); count++; } heap_delete(heap); } int main(int argc, char *argv[]){ int size; Node* nodes[MAXN]; scanf(\u0026#34;%d\u0026#34;, \u0026amp;size); for(int i=0; i\u0026lt;size; i++){ int tmp; scanf(\u0026#34;%d\u0026#34;, \u0026amp;tmp); if(tmp\u0026lt;0) nodes[i] = NULL; else nodes[i] = node_init(tmp); } build_node_reletions(nodes, size); build_input_seq(nodes, size); return 0; } ","permalink":"https://novel2430.github.io/notes/hashing-hard-version/","summary":"\u003ch1 id=\"7-1-hashing---hard-version\"\u003e7-1 Hashing - Hard Version\u003c/h1\u003e\n\u003cp\u003eGiven a hash table of size N, we can define a hash function \u003ccode\u003eH(x)=x%N\u003c/code\u003e. Suppose that the linear probing is used to solve collisions, we can easily obtain the status of the hash table with a given sequence of input numbers.\u003cbr\u003e\nHowever, now you are asked to solve the reversed problem: reconstruct the input sequence from the given status of the hash table. Whenever there are multiple choices, the smallest number is always taken.\u003c/p\u003e","title":"Hashing Hard Version"},{"content":"7-1 Insertion or Heap Sort According to Wikipedia:\nInsertion sort iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.\nHeap sort divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. it involves the use of a heap data structure rather than a linear-time search to find the maximum.\nNow given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using?\nInput Specification: Each input file contains one test case. For each case, the first line gives a positive integer N (≤100). Then in the next line, N integers are given as the initial sequence. The last line contains the partially sorted sequence of the N numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space.\nOutput Specification: For each test case, print in the first line either \u0026ldquo;Insertion Sort\u0026rdquo; or \u0026ldquo;Heap Sort\u0026rdquo; to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resulting sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.\nSample Input 1: 10 3 1 2 8 7 5 9 4 6 0 1 2 3 7 8 5 9 4 6 0 Sample Output 1: Insertion Sort 1 2 3 5 7 8 9 4 6 0 Sample Input 2: 10 3 1 2 8 7 5 9 4 6 0 6 4 5 1 0 3 2 7 8 9 Sample Output 2: Heap Sort 5 4 3 1 0 2 6 7 8 9 Code #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MAXN 1000 typedef enum SortType{ INSERTION, HEAP }SortType ; SortType get_sort_type(int* arr, int* orig, int size){ if(arr[0]\u0026lt;arr[1]) return INSERTION; return HEAP; } void swap(int* arr, int idx1, int idx2){ int tmp = arr[idx1]; arr[idx1] = arr[idx2]; arr[idx2] = tmp; } int max_idx(int* arr, int idx1, int idx2){ if(arr[idx1]\u0026gt;arr[idx2]) return idx1; return idx2; } void do_sort(SortType type, int* arr, int size){ if(type==INSERTION){ int idx = 0; for(int i=0; i\u0026lt;size-1; i++){ if(arr[i]\u0026gt;arr[i+1]){ idx = i+1; break; } } for(int i=idx; i\u0026gt;0; i--){ if(arr[i]\u0026lt;arr[i-1]){ swap(arr, i, i-1); } } } else{ int max = arr[0]; int heap_size = 0; for(int i=0; i\u0026lt;size; i++){ if(arr[i]\u0026gt;max){ heap_size = i; break; } } heap_size--; swap(arr, 0, heap_size); for(int start=0, next=start; start*2+1\u0026lt;heap_size; start=next){ if(2*(start+1) \u0026lt; heap_size){ next = max_idx(arr, start*2+1, 2*(start+1)); } else{ next = start*2 + 1; } if(arr[start]\u0026gt;arr[next]) break; swap(arr, start, next); } } for(int i=0; i\u0026lt;size; i++){ if(i\u0026gt;0) printf(\u0026#34; \u0026#34;); printf(\u0026#34;%d\u0026#34;, arr[i]); if(i==size-1) printf(\u0026#34;\\n\u0026#34;); } } int main(int argc, char *argv[]){ int size; int arr[MAXN]; int orig[MAXN]; scanf(\u0026#34;%d\u0026#34;, \u0026amp;size); for(int i=0; i\u0026lt;size; i++){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;orig[i]); } for(int i=0; i\u0026lt;size; i++){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;arr[i]); } switch(get_sort_type(arr, orig, size)){ case INSERTION: printf(\u0026#34;Insertion Sort\\n\u0026#34;); do_sort(INSERTION, arr, size); break; case HEAP: printf(\u0026#34;Heap Sort\\n\u0026#34;); do_sort(HEAP, arr, size); break; default: break; } return 0; } ","permalink":"https://novel2430.github.io/notes/insertion-or-heap-sort/","summary":"\u003ch1 id=\"7-1-insertion-or-heap-sort\"\u003e7-1 Insertion or Heap Sort\u003c/h1\u003e\n\u003cp\u003eAccording to Wikipedia:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eInsertion sort\u003c/strong\u003e iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHeap sort\u003c/strong\u003e divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. it involves the use of a heap data structure rather than a linear-time search to find the maximum.\u003c/p\u003e","title":"Insertion or Heap Sort"},{"content":"6-1 Iterative Mergesort How would you implement mergesort without using recursion?\nThe idea of iterative mergesort is to start from N sorted sublists of length 1, and each time to merge a pair of adjacent sublists until one sorted list is obtained. You are supposed to implement the key function of merging.\nFormat of functions: void merge_pass( ElementType list[], ElementType sorted[], int N, int length ); The function merge_pass performs one pass of the merge sort that merges adjacent pairs of sublists from list into sorted. N is the number of elements in the list and length is the length of the sublists.\nSample program of judge: #include \u0026lt;stdio.h\u0026gt; #define ElementType int #define MAXN 100 void merge_pass( ElementType list[], ElementType sorted[], int N, int length ); void output( ElementType list[], int N ) { int i; for (i=0; i\u0026lt;N; i++) printf(\u0026#34;%d \u0026#34;, list[i]); printf(\u0026#34;\\n\u0026#34;); } void merge_sort( ElementType list[], int N ) { ElementType extra[MAXN]; /* the extra space required */ int length = 1; /* current length of sublist being merged */ while( length \u0026lt; N ) { merge_pass( list, extra, N, length ); /* merge list into extra */ output( extra, N ); length *= 2; merge_pass( extra, list, N, length ); /* merge extra back to list */ output( list, N ); length *= 2; } } int main() { int N, i; ElementType A[MAXN]; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); for (i=0; i\u0026lt;N; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;A[i]); merge_sort(A, N); output(A, N); return 0; } /* Your function will be put here */ Sample Input: 10 8 7 9 2 3 5 1 6 4 0 Sample Output: 7 8 2 9 3 5 1 6 0 4 2 7 8 9 1 3 5 6 0 4 1 2 3 5 6 7 8 9 0 4 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 Code #include \u0026lt;stdio.h\u0026gt; #define ElementType int #define MAXN 100 void merge_pass( ElementType list[], ElementType sorted[], int N, int length ); void output( ElementType list[], int N ) { int i; for (i=0; i\u0026lt;N; i++) printf(\u0026#34;%d \u0026#34;, list[i]); printf(\u0026#34;\\n\u0026#34;); } void merge_sort( ElementType list[], int N ) { ElementType extra[MAXN]; /* the extra space required */ int length = 1; /* current length of sublist being merged */ while( length \u0026lt; N ) { merge_pass( list, extra, N, length ); /* merge list into extra */ output( extra, N ); length *= 2; merge_pass( extra, list, N, length ); /* merge extra back to list */ output( list, N ); length *= 2; } } int main() { int N, i; ElementType A[MAXN]; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); for (i=0; i\u0026lt;N; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;A[i]); merge_sort(A, N); output(A, N); return 0; } /* Your function will be put here */ int min(int x, int y) { return x \u0026lt; y ? x : y; } void merge_pass( ElementType list[], ElementType sorted[], int N, int length ){ for(int start=0; start\u0026lt;N; start+=length*2){ int cur_idx = start; int start1 = start; int end1 = min(start+length, N); int start2 = end1; int end2 = min(start+length*2, N); while(start1\u0026lt;end1 \u0026amp;\u0026amp; start2\u0026lt;end2){ if(list[start1]\u0026gt;list[start2]){ sorted[cur_idx++] = list[start2++]; } else{ sorted[cur_idx++] = list[start1++]; } } while(start1\u0026lt;end1){ sorted[cur_idx++] = list[start1++]; } while(start2\u0026lt;end2){ sorted[cur_idx++] = list[start2++]; } } } ","permalink":"https://novel2430.github.io/notes/iterative-mergesort/","summary":"\u003ch1 id=\"6-1-iterative-mergesort\"\u003e6-1 Iterative Mergesort\u003c/h1\u003e\n\u003cp\u003eHow would you implement mergesort without using recursion?\u003c/p\u003e\n\u003cp\u003eThe idea of iterative mergesort is to start from N sorted sublists of length 1, and each time to merge a pair of adjacent sublists until one sorted list is obtained. You are supposed to implement the key function of merging.\u003c/p\u003e\n\u003ch2 id=\"format-of-functions\"\u003eFormat of functions:\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emerge_pass\u003c/span\u003e( ElementType list[], ElementType sorted[], \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e N, \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e length );\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe function \u003ccode\u003emerge_pass\u003c/code\u003e performs one pass of the merge sort that merges adjacent pairs of sublists from \u003ccode\u003elist\u003c/code\u003e into \u003ccode\u003esorted\u003c/code\u003e. \u003ccode\u003eN\u003c/code\u003e is the number of elements in the \u003ccode\u003elist\u003c/code\u003e and length is the \u003ccode\u003elength\u003c/code\u003e of the sublists.\u003c/p\u003e","title":"Iterative Mergesort"},{"content":"6-1 Strongly Connected Components Write a program to find the strongly connected components in a digraph.\nFormat of functions: void StronglyConnectedComponents( Graph G, void (*visit)(Vertex V) ); where Graph is defined as the following:\ntypedef struct VNode *PtrToVNode; struct VNode { Vertex Vert; PtrToVNode Next; }; typedef struct GNode *Graph; struct GNode { int NumOfVertices; int NumOfEdges; PtrToVNode *Array; }; Here void (*visit)(Vertex V) is a function parameter that is passed into StronglyConnectedComponents to handle (print with a certain format) each vertex that is visited. The function StronglyConnectedComponents is supposed to print a return after each component is found.\nSample program of judge: #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MaxVertices 10 /* maximum number of vertices */ typedef int Vertex; /* vertices are numbered from 0 to MaxVertices-1 */ typedef struct VNode *PtrToVNode; struct VNode { Vertex Vert; PtrToVNode Next; }; typedef struct GNode *Graph; struct GNode { int NumOfVertices; int NumOfEdges; PtrToVNode *Array; }; Graph ReadG(); /* details omitted */ void PrintV( Vertex V ) { printf(\u0026#34;%d \u0026#34;, V); } void StronglyConnectedComponents( Graph G, void (*visit)(Vertex V) ); int main() { Graph G = ReadG(); StronglyConnectedComponents( G, PrintV ); return 0; } /* Your function will be put here */ Sample Input (for the graph shown in the figure): 4 5 0 1 1 2 2 0 3 1 3 2 Sample Output: 3 1 2 0 Note: The output order does not matter. That is, a solution like\n0 1 2 3 is also considered correct.\nCode Tarjan #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MaxVertices 10 /* maximum number of vertices */ typedef int Vertex; /* vertices are numbered from 0 to MaxVertices-1 */ typedef struct VNode *PtrToVNode; struct VNode { Vertex Vert; PtrToVNode Next; }; typedef struct GNode *Graph; struct GNode { int NumOfVertices; int NumOfEdges; PtrToVNode *Array; }; Graph ReadG(); /* details omitted */ void PrintV( Vertex V ) { printf(\u0026#34;%d \u0026#34;, V); } void StronglyConnectedComponents( Graph G, void (*visit)(Vertex V) ); int main() { Graph G = ReadG(); StronglyConnectedComponents( G, PrintV ); return 0; } PtrToVNode ptr_node_init(Vertex v){ PtrToVNode res = (PtrToVNode)malloc(sizeof(struct VNode)); res-\u0026gt;Vert = v; res-\u0026gt;Next = NULL; return res; } Graph ReadG(){ Graph res = (Graph)malloc(sizeof(struct GNode)); int vertice_num, edge_num; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;vertice_num, \u0026amp;edge_num); res-\u0026gt;NumOfVertices = vertice_num; res-\u0026gt;NumOfEdges = edge_num; res-\u0026gt;Array = (PtrToVNode*)malloc(sizeof(PtrToVNode)*res-\u0026gt;NumOfVertices); for(int i=0; i\u0026lt;vertice_num; i++) res-\u0026gt;Array[i] = NULL; for(int i=0; i\u0026lt;edge_num; i++){ int v1, v2; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;v1, \u0026amp;v2); PtrToVNode node = ptr_node_init(v2); if(res-\u0026gt;Array[v1]==NULL) res-\u0026gt;Array[v1] = node; else{ node-\u0026gt;Next = res-\u0026gt;Array[v1]; res-\u0026gt;Array[v1] = node; } } return res; } /* Your function will be put here */ typedef enum Boolean {FALSE, TRUE} Boolean ; typedef int StackVal; ; typedef struct Stack{ int max_size; int cur_top; StackVal* array; } Stack; Stack* stack_init(int max){ Stack* res = (Stack*)malloc(sizeof(Stack)); res-\u0026gt;max_size = max; res-\u0026gt;cur_top = -1; res-\u0026gt;array = (StackVal*)malloc(sizeof(StackVal)*res-\u0026gt;max_size); return res; } Boolean stack_is_empty(Stack* stack){ if(stack-\u0026gt;cur_top==-1) return TRUE; return FALSE; } void stack_insert(Stack* stack, StackVal val){ stack-\u0026gt;cur_top++; stack-\u0026gt;array[stack-\u0026gt;cur_top] = val; } StackVal stack_pop(Stack* stack){ int res = stack-\u0026gt;array[stack-\u0026gt;cur_top]; stack-\u0026gt;cur_top--; return res; } StackVal stack_peak(Stack* stack){ int res = stack-\u0026gt;array[stack-\u0026gt;cur_top]; return res; } void stack_empty(Stack* stack){ while(!stack_is_empty(stack)){ stack_pop(stack); } } int min(int a, int b){ if(a \u0026lt; b) return a; return b; } void tarjan(Graph G, Stack* stack, int* dfn, int* low, Boolean* in_stack, int cur_idx, int* visit_count, void (*visit)(Vertex V)){ dfn[cur_idx] = *visit_count; low[cur_idx] = *visit_count; (*visit_count)++; stack_insert(stack, cur_idx); in_stack[cur_idx] = TRUE; for(PtrToVNode cur=G-\u0026gt;Array[cur_idx]; cur!=NULL; cur=cur-\u0026gt;Next){ if(dfn[cur-\u0026gt;Vert]\u0026lt;0){ tarjan(G, stack, dfn, low, in_stack, cur-\u0026gt;Vert, visit_count, visit); low[cur_idx] = min(low[cur_idx], low[cur-\u0026gt;Vert]); } else if(in_stack[cur-\u0026gt;Vert]){ low[cur_idx] = min(low[cur_idx], dfn[cur-\u0026gt;Vert]); } } if(low[cur_idx]==dfn[cur_idx]){ while(!stack_is_empty(stack)){ int stack_top = stack_pop(stack); in_stack[stack_top] = FALSE; visit(stack_top); if(cur_idx==stack_top) break; } printf(\u0026#34;\\n\u0026#34;); } } void StronglyConnectedComponents( Graph G, void (*visit)(Vertex V) ){ Stack* stack = stack_init(G-\u0026gt;NumOfVertices); int dfn[G-\u0026gt;NumOfVertices]; int low[G-\u0026gt;NumOfVertices]; Boolean in_stack[G-\u0026gt;NumOfVertices]; for(int i=0; i\u0026lt;G-\u0026gt;NumOfVertices; i++){ dfn[i] = -1; low[i] = -1; in_stack[i] = FALSE; } for(int i=0; i\u0026lt;G-\u0026gt;NumOfVertices; i++){ int visit_count = 0; if(dfn[i]==-1) tarjan(G, stack, dfn, low, in_stack, i, \u0026amp;visit_count, visit); stack_empty(stack); } } Code Kosaraju #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MaxVertices 10 /* maximum number of vertices */ typedef int Vertex; /* vertices are numbered from 0 to MaxVertices-1 */ typedef struct VNode *PtrToVNode; struct VNode { Vertex Vert; PtrToVNode Next; }; typedef struct GNode *Graph; struct GNode { int NumOfVertices; int NumOfEdges; PtrToVNode *Array; }; Graph ReadG(); /* details omitted */ void PrintV( Vertex V ) { printf(\u0026#34;%d \u0026#34;, V); } void StronglyConnectedComponents( Graph G, void (*visit)(Vertex V) ); int main() { Graph G = ReadG(); StronglyConnectedComponents( G, PrintV ); return 0; } PtrToVNode ptr_node_init(Vertex v){ PtrToVNode res = (PtrToVNode)malloc(sizeof(struct VNode)); res-\u0026gt;Vert = v; res-\u0026gt;Next = NULL; return res; } Graph ReadG(){ Graph res = (Graph)malloc(sizeof(struct GNode)); int vertice_num, edge_num; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;vertice_num, \u0026amp;edge_num); res-\u0026gt;NumOfVertices = vertice_num; res-\u0026gt;NumOfEdges = edge_num; res-\u0026gt;Array = (PtrToVNode*)malloc(sizeof(PtrToVNode)*res-\u0026gt;NumOfVertices); for(int i=0; i\u0026lt;vertice_num; i++) res-\u0026gt;Array[i] = NULL; for(int i=0; i\u0026lt;edge_num; i++){ int v1, v2; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;v1, \u0026amp;v2); PtrToVNode node = ptr_node_init(v2); if(res-\u0026gt;Array[v1]==NULL) res-\u0026gt;Array[v1] = node; else{ node-\u0026gt;Next = res-\u0026gt;Array[v1]; res-\u0026gt;Array[v1] = node; } } return res; } /* Your function will be put here */ typedef enum Boolean {FALSE, TRUE} Boolean ; typedef int StackVal; ; typedef struct Stack{ int max_size; int cur_top; StackVal* array; } Stack; Stack* stack_init(int max){ Stack* res = (Stack*)malloc(sizeof(Stack)); res-\u0026gt;max_size = max; res-\u0026gt;cur_top = -1; res-\u0026gt;array = (StackVal*)malloc(sizeof(StackVal)*res-\u0026gt;max_size); return res; } Boolean stack_is_empty(Stack* stack){ if(stack-\u0026gt;cur_top==-1) return TRUE; return FALSE; } void stack_insert(Stack* stack, StackVal val){ stack-\u0026gt;cur_top++; stack-\u0026gt;array[stack-\u0026gt;cur_top] = val; } StackVal stack_pop(Stack* stack){ int res = stack-\u0026gt;array[stack-\u0026gt;cur_top]; stack-\u0026gt;cur_top--; return res; } StackVal stack_peak(Stack* stack){ int res = stack-\u0026gt;array[stack-\u0026gt;cur_top]; return res; } void stack_empty(Stack* stack){ while(!stack_is_empty(stack)){ stack_pop(stack); } } int min(int a, int b){ if(a \u0026lt; b) return a; return b; } Graph build_graph_inverse(Graph graph){ Graph res = (Graph)malloc(sizeof(struct GNode)); res-\u0026gt;NumOfEdges = graph-\u0026gt;NumOfEdges; res-\u0026gt;NumOfVertices = graph-\u0026gt;NumOfVertices; res-\u0026gt;Array = (PtrToVNode*)malloc(sizeof(PtrToVNode)*res-\u0026gt;NumOfVertices); for(int i=0; i\u0026lt;res-\u0026gt;NumOfVertices; i++) res-\u0026gt;Array[i] = NULL; for(int i=0; i\u0026lt;res-\u0026gt;NumOfVertices; i++){ for(PtrToVNode cur = graph-\u0026gt;Array[i]; cur!=NULL; cur=cur-\u0026gt;Next){ int v1 = cur-\u0026gt;Vert; int v2 = i; PtrToVNode node = (PtrToVNode)malloc(sizeof(struct VNode)); node-\u0026gt;Vert = v2; node-\u0026gt;Next = NULL; if(res-\u0026gt;Array[v1]==NULL) res-\u0026gt;Array[v1] = node; else{ node-\u0026gt;Next = res-\u0026gt;Array[v1]; res-\u0026gt;Array[v1] = node; } } } return res; } void kosaraju_first_dfs(Graph graph, Stack* stack, Boolean* visit, Boolean* in_stack, int cur_idx){ if(visit[cur_idx]) return; visit[cur_idx] = TRUE; for(PtrToVNode cur=graph-\u0026gt;Array[cur_idx]; cur!=NULL; cur=cur-\u0026gt;Next){ kosaraju_first_dfs(graph, stack, visit, in_stack, cur-\u0026gt;Vert); } stack_insert(stack, cur_idx); in_stack[cur_idx] = TRUE; } void kosaraju_second_dfs(Graph graph, Boolean* visit, Boolean* in_stack, int cur_idx, void (*print_visit)(Vertex V)){ if(visit[cur_idx] || !in_stack[cur_idx]) return; visit[cur_idx] = TRUE; print_visit(cur_idx); for(PtrToVNode cur=graph-\u0026gt;Array[cur_idx]; cur!=NULL; cur=cur-\u0026gt;Next){ kosaraju_second_dfs(graph, visit, in_stack, cur-\u0026gt;Vert, print_visit); } } void kosaraju(Graph graph, Boolean* is_visit, int start, void (*visit)(Vertex V)){ Graph inverse_graph = build_graph_inverse(graph); Stack* stack = stack_init(graph-\u0026gt;NumOfVertices); Boolean is_visit_2[graph-\u0026gt;NumOfVertices]; Boolean in_stack[graph-\u0026gt;NumOfVertices]; for(int i=0; i\u0026lt;graph-\u0026gt;NumOfVertices; i++) is_visit_2[i] = FALSE; for(int i=0; i\u0026lt;graph-\u0026gt;NumOfVertices; i++) in_stack[i] = FALSE; kosaraju_first_dfs(graph, stack, is_visit, in_stack, start); while(!stack_is_empty(stack)){ int stack_top = stack_pop(stack); if(is_visit_2[stack_top]) continue; kosaraju_second_dfs(inverse_graph, is_visit_2, in_stack, stack_top, visit); printf(\u0026#34;\\n\u0026#34;); } } void StronglyConnectedComponents( Graph G, void (*visit)(Vertex V) ){ Boolean is_visit[G-\u0026gt;NumOfVertices]; for(int i=0; i\u0026lt;G-\u0026gt;NumOfVertices; i++) is_visit[i] = FALSE; for(int i=0; i\u0026lt;G-\u0026gt;NumOfVertices; i++){ if(is_visit[i]) continue; kosaraju(G, is_visit, i, visit); } } ","permalink":"https://novel2430.github.io/notes/strongly-connected-components/","summary":"\u003ch1 id=\"6-1-strongly-connected-components\"\u003e6-1 Strongly Connected Components\u003c/h1\u003e\n\u003cp\u003eWrite a program to find the strongly connected components in a digraph.\u003c/p\u003e\n\u003ch2 id=\"format-of-functions\"\u003eFormat of functions:\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eStronglyConnectedComponents\u003c/span\u003e( Graph G, \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e (\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003evisit)(Vertex V) );\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003ewhere \u003ccode\u003eGraph\u003c/code\u003e is defined as the following:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e VNode \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ePtrToVNode;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e VNode {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Vertex Vert;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    PtrToVNode Next;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e GNode \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eGraph;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e GNode {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e NumOfVertices;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e NumOfEdges;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    PtrToVNode \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eArray;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eHere \u003ccode\u003evoid (*visit)(Vertex V)\u003c/code\u003e is a function parameter that is passed into \u003ccode\u003eStronglyConnectedComponents\u003c/code\u003e to handle (print with a certain format) each vertex that is visited. The function \u003ccode\u003eStronglyConnectedComponents\u003c/code\u003e is supposed to print a return after each component is found.\u003c/p\u003e","title":"Strongly Connected Components"},{"content":"Uniqueness of MST Given any weighted undirected graph, there exists at least one minimum spanning tree (MST) if the graph is connected. Sometimes the MST may not be unique though. Here you are supposed to calculate the minimum total weight of the MST, and also tell if it is unique or not.\nInput Specification: Each input file contains one test case. Each case starts with a line containing 2 numbers N (≤ 500), and M, which are the total number of vertices, and the number of edges, respectively. Then M lines follow, each describes an edge by 3 integers:\nV1 V2 Weight where V1 and V2 are the two ends of the edge (the vertices are numbered from 1 to N), and Weight is the positive weight on that edge. It is guaranteed that the total weight of the graph will not exceed 230.\nOutput Specification: For each test case, first print in a line the total weight of the minimum spanning tree if there exists one, or else print No MST instead. Then if the MST exists, print in the next line Yes if the tree is unique, or No otherwise. There there is no MST, print the number of connected components instead.\nSample Input 1: 5 7 1 2 6 5 1 1 2 3 4 3 4 3 4 1 7 2 4 2 4 5 5 Sample Output 1: 11 Yes Sample Input 2: 4 5 1 2 1 2 3 1 3 4 2 4 1 2 3 1 3 Sample Output 2: 4 No Sample Input 3: 5 5 1 2 1 2 3 1 3 4 2 4 1 2 3 1 3 Sample Output 3: No MST 2 Code Prim #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define MAXN 2000 #define MAXE 150000 typedef enum { FALSE, TRUE } boolean; typedef enum { UNIQUE, PLURAL, NONE } ResType; typedef struct Edge{ int v1; int v2; int weight; }Edge ; typedef struct Graph{ int node_num; int edge_num; Edge* weights[MAXN][MAXN]; Edge* MST_edges[MAXE]; }Graph ; typedef struct HeapNode{ Edge* edge; int to; }HeapNode ; typedef struct Heap{ int size; HeapNode* value[MAXE]; }Heap ; void swap(int pos1, int pos2, Heap* H){ HeapNode* tmp = H-\u0026gt;value[pos1]; H-\u0026gt;value[pos1] = H-\u0026gt;value[pos2]; H-\u0026gt;value[pos2] = tmp; } int min_idx(int idx1, int idx2, Heap* H){ if(H-\u0026gt;value[idx1]-\u0026gt;edge-\u0026gt;weight \u0026lt; H-\u0026gt;value[idx2]-\u0026gt;edge-\u0026gt;weight) return idx1; return idx2; } Heap* heap_init(){ Heap* res = (Heap*)malloc(sizeof(Heap)); res-\u0026gt;size = 0; return res; } void heap_node_delete(HeapNode* node){ if(node==NULL) return; free(node); node = NULL; } boolean heap_is_empty(Heap* heap){ if(heap-\u0026gt;size==0) return TRUE; else return FALSE; } void heap_delete(Heap* heap){ if(heap==NULL) return; for(int i=1; i\u0026lt;=heap-\u0026gt;size; i++){ heap_node_delete(heap-\u0026gt;value[i]); } free(heap); heap = NULL; } HeapNode heap_pop_min(Heap* heap){ HeapNode* res = heap-\u0026gt;value[1]; heap-\u0026gt;value[1] = heap-\u0026gt;value[heap-\u0026gt;size]; heap-\u0026gt;size--; for(int pos=1, child_idx; pos*2\u0026lt;=heap-\u0026gt;size; pos=child_idx){ int val = heap-\u0026gt;value[pos]-\u0026gt;edge-\u0026gt;weight; if(pos*2+1 \u0026lt;= heap-\u0026gt;size) child_idx = min_idx(pos*2, pos*2+1, heap); else child_idx = pos*2; if(heap-\u0026gt;value[child_idx]-\u0026gt;edge-\u0026gt;weight \u0026lt; val) swap(pos, child_idx, heap); else break; } HeapNode node; node.edge = res-\u0026gt;edge; node.to = res-\u0026gt;to; heap_node_delete(res); return node; } void heap_insert(Heap* heap, Edge* edge, int to){ if(heap==NULL) return; HeapNode* new_node = (HeapNode*)malloc(sizeof(HeapNode)); new_node-\u0026gt;edge = edge; new_node-\u0026gt;to = to; heap-\u0026gt;value[heap-\u0026gt;size+1] = new_node; heap-\u0026gt;size++; for(int pos=heap-\u0026gt;size,parent_idx; pos\u0026gt;1; pos=parent_idx){ int val = heap-\u0026gt;value[pos]-\u0026gt;edge-\u0026gt;weight; if(pos%2==0) parent_idx = pos/2; else parent_idx = (pos-1)/2; if(heap-\u0026gt;value[parent_idx]-\u0026gt;edge-\u0026gt;weight\u0026gt;val) swap(pos, parent_idx, heap); else break; } } Graph* graph_init(int node_num, int edge_num){ Graph* res = (Graph*)malloc(sizeof(Graph)); res-\u0026gt;node_num = node_num; res-\u0026gt;edge_num = edge_num; for(int i=0; i\u0026lt;node_num; i++){ for(int j=0; j\u0026lt;node_num; j++) res-\u0026gt;weights[i][j] = NULL; } return res; } void graph_insert_edge(Graph* graph, int v1, int v2, int weight){ Edge* edge = (Edge*)malloc(sizeof(Edge)); edge-\u0026gt;v1 = v1; edge-\u0026gt;v2 = v2; edge-\u0026gt;weight = weight; graph-\u0026gt;weights[v1-1][v2-1] = edge; graph-\u0026gt;weights[v2-1][v1-1] = edge; } ResType find_mst(Graph* graph, Heap* heap, boolean* visit, int start_idx, int* mst_val, int* mst_edge_count){ visit[start_idx] = TRUE; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ if(graph-\u0026gt;weights[start_idx][i]!=NULL){ heap_insert(heap, graph-\u0026gt;weights[start_idx][i], i); } } while(!heap_is_empty(heap)){ HeapNode min = heap_pop_min(heap); Edge* edge = min.edge; if(visit[min.to]) continue; visit[min.to] = TRUE; (*mst_val) += min.edge-\u0026gt;weight; graph-\u0026gt;MST_edges[(*mst_edge_count)++] = edge; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ if(!visit[i] \u0026amp;\u0026amp; graph-\u0026gt;weights[min.to][i]!=NULL){ heap_insert(heap, graph-\u0026gt;weights[min.to][i], i); } } } if((*mst_edge_count)!=graph-\u0026gt;node_num-1) return NONE; return UNIQUE; } int find_tree_count(Graph* graph, Heap* heap, boolean* visit){ int res = 1; int mst_val = 0; int mst_edge_count = 0; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ if(!visit[i]){ find_mst(graph, heap, visit, i, \u0026amp;mst_val, \u0026amp;mst_edge_count); res++; } } return res; } ResType tree_unique(Graph* graph, Heap* heap, int min_mst_val, int mst_edge_count){ boolean visit[MAXN]; for(int ii=0; ii\u0026lt;mst_edge_count; ii++){ Edge* cannot_use_edge = graph-\u0026gt;MST_edges[ii]; memset(visit, FALSE, sizeof(visit)); visit[0] = TRUE; int mst_val = 0; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ if(graph-\u0026gt;weights[0][i]!=NULL){ heap_insert(heap, graph-\u0026gt;weights[0][i], i); } } while(!heap_is_empty(heap)){ HeapNode min = heap_pop_min(heap); Edge* edge = min.edge; if(visit[min.to] || edge==cannot_use_edge) continue; visit[min.to] = TRUE; mst_val += edge-\u0026gt;weight; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ if(!visit[i] \u0026amp;\u0026amp; graph-\u0026gt;weights[min.to][i]!=NULL){ heap_insert(heap, graph-\u0026gt;weights[min.to][i], i); } } } if(mst_val==min_mst_val) return PLURAL; } return UNIQUE; } ResType prim(Graph* graph, int* mst_val, int* tree_count){ int mst_edge_count = 0; Heap* heap = heap_init(); boolean visit[MAXN]; memset(visit, FALSE, sizeof(visit)); ResType res = find_mst(graph, heap, visit, 0, mst_val, \u0026amp;mst_edge_count); if(res==NONE){ (*tree_count) = find_tree_count(graph, heap, visit); } else{ res = tree_unique(graph, heap, *mst_val, mst_edge_count); } heap_delete(heap); return res; } int main(int argc, char *argv[]){ int node_num, edge_num; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;node_num, \u0026amp;edge_num); Graph* graph = graph_init(node_num, edge_num); for(int i=0; i\u0026lt;edge_num; i++){ int v1, v2, weight; scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;v1, \u0026amp;v2, \u0026amp;weight); graph_insert_edge(graph, v1, v2, weight); } int mst_val = 0; int tree_count = 0; ResType res = prim(graph, \u0026amp;mst_val, \u0026amp;tree_count); switch (res) { case UNIQUE: printf(\u0026#34;%d\\nYes\\n\u0026#34;, mst_val); break; case PLURAL: printf(\u0026#34;%d\\nNo\\n\u0026#34;, mst_val); break; case NONE: printf(\u0026#34;No MST\\n%d\\n\u0026#34;, tree_count); break; default: break; } return 0; } Code Kruskal Normal #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define MAXN 150000 typedef enum { FALSE, TRUE } boolean; typedef enum { UNIQUE, PLURAL, NONE } ResType; typedef struct Node{ int val; struct Node* parent; }Node ; typedef struct Edge{ Node* v1; Node* v2; int weight; }Edge ; typedef struct Graph{ int node_num; int edge_num; Edge* edges[MAXN]; Node* nodes[MAXN]; }Graph ; Node* node_init(int val){ Node* res = (Node*)malloc(sizeof(Node)); res-\u0026gt;val = val; res-\u0026gt;parent = res; return res; } Node* node_find_parent(Node* node){ if(node == node-\u0026gt;parent) return node; node-\u0026gt;parent = node_find_parent(node-\u0026gt;parent); return node-\u0026gt;parent; } boolean node_is_same_set(Node* node1, Node* node2){ Node* n1_parent = node_find_parent(node1); Node* n2_parent = node_find_parent(node2); if(n1_parent==n2_parent) return TRUE; return FALSE; } void node_union(Node* node1, Node* node2){ node_find_parent(node1)-\u0026gt;parent = node_find_parent(node2); } Graph* graph_init(int node_num, int edge_num){ Graph* res = (Graph*)malloc(sizeof(Graph)); res-\u0026gt;node_num = node_num; res-\u0026gt;edge_num = edge_num; for(int i=0; i\u0026lt;res-\u0026gt;node_num; i++){ res-\u0026gt;nodes[i] = node_init(i+1); } return res; } void graph_insert_edge(Graph* graph, int idx, int v1, int v2, int weight){ graph-\u0026gt;edges[idx] = (Edge*)malloc(sizeof(Edge)); graph-\u0026gt;edges[idx]-\u0026gt;v1 = graph-\u0026gt;nodes[v1-1]; graph-\u0026gt;edges[idx]-\u0026gt;v2 = graph-\u0026gt;nodes[v2-1];; graph-\u0026gt;edges[idx]-\u0026gt;weight = weight; } void merge_sort_conquer(Edge** arr, Edge** tmp, int low, int mid, int high){ int start_1 = low; int end_1 = mid; int start_2 = mid+1; int end_2 = high; int idx = 0; while(start_1\u0026lt;=end_1 \u0026amp;\u0026amp; start_2\u0026lt;=end_2){ if(arr[start_1]-\u0026gt;weight \u0026lt; arr[start_2]-\u0026gt;weight){ tmp[idx++] = arr[start_1++]; } else{ tmp[idx++] = arr[start_2++]; } } while(start_1 \u0026lt;= end_1){ tmp[idx++] = arr[start_1++]; } while(start_2 \u0026lt;= end_2){ tmp[idx++] = arr[start_2++]; } idx = 0; while(low \u0026lt;= high){ arr[low++] = tmp[idx++]; } } void merge_sort_divide(Edge** arr, Edge** tmp, int low, int high){ if(low\u0026lt;high){ int mid = (low+high)/2; merge_sort_divide(arr, tmp, low, mid); merge_sort_divide(arr, tmp, mid+1, high); merge_sort_conquer(arr, tmp, low, mid, high); } } void merge_sort_edge(Graph* graph){ Edge* tmp[MAXN]; merge_sort_divide(graph-\u0026gt;edges, tmp, 0, graph-\u0026gt;edge_num-1); } ResType kruskal(Graph* graph, int* mst_val){ int mst_edge_count = 0; // find MST Edge* MST_edge[MAXN]; for(int i=0; i\u0026lt;graph-\u0026gt;edge_num\u0026amp;\u0026amp;mst_edge_count\u0026lt;graph-\u0026gt;node_num-1; i++){ Edge* cur_edge = graph-\u0026gt;edges[i]; if(!node_is_same_set(cur_edge-\u0026gt;v1, cur_edge-\u0026gt;v2)){ (*mst_val) += cur_edge-\u0026gt;weight; MST_edge[mst_edge_count++] = cur_edge; node_union(cur_edge-\u0026gt;v1, cur_edge-\u0026gt;v2); } } if(mst_edge_count!=graph-\u0026gt;node_num-1) return NONE; // find SMST for(int i=0; i\u0026lt;mst_edge_count; i++){ int sum_SMST = 0; for(int ii=0; ii\u0026lt;graph-\u0026gt;node_num; ii++) graph-\u0026gt;nodes[ii]-\u0026gt;parent = graph-\u0026gt;nodes[ii]; for(int j=0; j\u0026lt;graph-\u0026gt;edge_num; j++){ Edge* cur_edge = graph-\u0026gt;edges[j]; if(cur_edge==MST_edge[i]) continue; if(!node_is_same_set(cur_edge-\u0026gt;v1, cur_edge-\u0026gt;v2)){ sum_SMST += cur_edge-\u0026gt;weight; node_union(cur_edge-\u0026gt;v1, cur_edge-\u0026gt;v2); } } if(sum_SMST==(*mst_val)) return PLURAL; } return UNIQUE; } int graph_count_set(Graph* graph){ int res = 0; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ if(graph-\u0026gt;nodes[i]-\u0026gt;parent==graph-\u0026gt;nodes[i]) res++; } return res; } int main(int argc, char *argv[]){ int node_num, edge_num; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;node_num, \u0026amp;edge_num); Graph* graph = graph_init(node_num, edge_num); for(int i=0; i\u0026lt;edge_num; i++){ int v1, v2, weight; scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;v1, \u0026amp;v2, \u0026amp;weight); graph_insert_edge(graph, i, v1, v2, weight); } merge_sort_edge(graph); int mst_val = 0; ResType res = kruskal(graph, \u0026amp;mst_val); switch (res) { case UNIQUE: printf(\u0026#34;%d\\nYes\\n\u0026#34;, mst_val); break; case PLURAL: printf(\u0026#34;%d\\nNo\\n\u0026#34;, mst_val); break; case NONE: printf(\u0026#34;No MST\\n%d\\n\u0026#34;, graph_count_set(graph)); break; default: break; } return 0; } Code Kruskal Better #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define MAXN 150000 typedef enum { FALSE, TRUE } boolean; typedef enum { UNIQUE, PLURAL, NONE } ResType; typedef struct Node{ int val; struct Node* parent; }Node ; typedef struct Edge{ Node* v1; Node* v2; int weight; }Edge ; typedef struct Graph{ int node_num; int edge_num; Edge* edges[MAXN]; Node* nodes[MAXN]; }Graph ; Node* node_init(int val){ Node* res = (Node*)malloc(sizeof(Node)); res-\u0026gt;val = val; res-\u0026gt;parent = res; return res; } Node* node_find_parent(Node* node){ if(node == node-\u0026gt;parent) return node; node-\u0026gt;parent = node_find_parent(node-\u0026gt;parent); return node-\u0026gt;parent; } boolean node_is_same_set(Node* node1, Node* node2){ Node* n1_parent = node_find_parent(node1); Node* n2_parent = node_find_parent(node2); if(n1_parent==n2_parent) return TRUE; return FALSE; } void node_union(Node* node1, Node* node2){ node_find_parent(node1)-\u0026gt;parent = node_find_parent(node2); } Graph* graph_init(int node_num, int edge_num){ Graph* res = (Graph*)malloc(sizeof(Graph)); res-\u0026gt;node_num = node_num; res-\u0026gt;edge_num = edge_num; for(int i=0; i\u0026lt;res-\u0026gt;node_num; i++){ res-\u0026gt;nodes[i] = node_init(i+1); } return res; } void graph_insert_edge(Graph* graph, int idx, int v1, int v2, int weight){ graph-\u0026gt;edges[idx] = (Edge*)malloc(sizeof(Edge)); graph-\u0026gt;edges[idx]-\u0026gt;v1 = graph-\u0026gt;nodes[v1-1]; graph-\u0026gt;edges[idx]-\u0026gt;v2 = graph-\u0026gt;nodes[v2-1];; graph-\u0026gt;edges[idx]-\u0026gt;weight = weight; } void merge_sort_conquer(Edge** arr, Edge** tmp, int low, int mid, int high){ int start_1 = low; int end_1 = mid; int start_2 = mid+1; int end_2 = high; int idx = 0; while(start_1\u0026lt;=end_1 \u0026amp;\u0026amp; start_2\u0026lt;=end_2){ if(arr[start_1]-\u0026gt;weight \u0026lt; arr[start_2]-\u0026gt;weight){ tmp[idx++] = arr[start_1++]; } else{ tmp[idx++] = arr[start_2++]; } } while(start_1 \u0026lt;= end_1){ tmp[idx++] = arr[start_1++]; } while(start_2 \u0026lt;= end_2){ tmp[idx++] = arr[start_2++]; } idx = 0; while(low \u0026lt;= high){ arr[low++] = tmp[idx++]; } } void merge_sort_divide(Edge** arr, Edge** tmp, int low, int high){ if(low\u0026lt;high){ int mid = (low+high)/2; merge_sort_divide(arr, tmp, low, mid); merge_sort_divide(arr, tmp, mid+1, high); merge_sort_conquer(arr, tmp, low, mid, high); } } void merge_sort_edge(Graph* graph){ Edge* tmp[MAXN]; merge_sort_divide(graph-\u0026gt;edges, tmp, 0, graph-\u0026gt;edge_num-1); } ResType kruskal(Graph* graph, int* mst_val){ int mst_edge_count = 0; // find MST int flag = 0; for(int i=0; i\u0026lt;graph-\u0026gt;edge_num\u0026amp;\u0026amp;mst_edge_count\u0026lt;graph-\u0026gt;node_num-1; i++){ Edge* cur_edge = graph-\u0026gt;edges[i]; if(!node_is_same_set(cur_edge-\u0026gt;v1, cur_edge-\u0026gt;v2)){ for(int j=i+1; flag==0\u0026amp;\u0026amp;j\u0026lt;graph-\u0026gt;edge_num\u0026amp;\u0026amp;graph-\u0026gt;edges[j]-\u0026gt;weight==cur_edge-\u0026gt;weight; j++){ Edge* edge = graph-\u0026gt;edges[j]; if(node_is_same_set(cur_edge-\u0026gt;v1, edge-\u0026gt;v1) \u0026amp;\u0026amp; node_is_same_set(cur_edge-\u0026gt;v2, edge-\u0026gt;v2)){ flag = 1; break; } if(node_is_same_set(cur_edge-\u0026gt;v1, edge-\u0026gt;v2) \u0026amp;\u0026amp; node_is_same_set(cur_edge-\u0026gt;v2, edge-\u0026gt;v1)){ flag = 1; break; } } (*mst_val) += cur_edge-\u0026gt;weight; mst_edge_count++; node_union(cur_edge-\u0026gt;v1, cur_edge-\u0026gt;v2); } } if(mst_edge_count!=graph-\u0026gt;node_num-1) return NONE; if(flag) return PLURAL; return UNIQUE; } int graph_count_set(Graph* graph){ int res = 0; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ if(graph-\u0026gt;nodes[i]-\u0026gt;parent==graph-\u0026gt;nodes[i]) res++; } return res; } int main(int argc, char *argv[]){ int node_num, edge_num; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;node_num, \u0026amp;edge_num); Graph* graph = graph_init(node_num, edge_num); for(int i=0; i\u0026lt;edge_num; i++){ int v1, v2, weight; scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;v1, \u0026amp;v2, \u0026amp;weight); graph_insert_edge(graph, i, v1, v2, weight); } merge_sort_edge(graph); int mst_val = 0; ResType res = kruskal(graph, \u0026amp;mst_val); switch (res) { case UNIQUE: printf(\u0026#34;%d\\nYes\\n\u0026#34;, mst_val); break; case PLURAL: printf(\u0026#34;%d\\nNo\\n\u0026#34;, mst_val); break; case NONE: printf(\u0026#34;No MST\\n%d\\n\u0026#34;, graph_count_set(graph)); break; default: break; } return 0; } ","permalink":"https://novel2430.github.io/notes/uniqueness-of-mst/","summary":"\u003ch1 id=\"uniqueness-of-mst\"\u003eUniqueness of MST\u003c/h1\u003e\n\u003cp\u003eGiven any weighted undirected graph, there exists at least one minimum spanning tree (MST) if the graph is connected. Sometimes the MST may not be unique though. Here you are supposed to calculate the minimum total weight of the MST, and also tell if it is unique or not.\u003c/p\u003e\n\u003ch2 id=\"input-specification\"\u003eInput Specification:\u003c/h2\u003e\n\u003cp\u003eEach input file contains one test case. Each case starts with a line containing 2 numbers N (≤ 500), and M, which are the total number of vertices, and the number of edges, respectively. Then M lines follow, each describes an edge by 3 integers:\u003c/p\u003e","title":"Uniqueness of MST"},{"content":"Universal Travel Sites After finishing her tour around the Earth, CYLL is now planning a universal travel sites development project. After a careful investigation, she has a list of capacities of all the satellite transportation stations in hand. To estimate a budget, she must know the minimum capacity that a planet station must have to guarantee that every space vessel can dock and download its passengers on arrival.\nInput Specification: Each input file contains one test case. For each case, the first line contains the names of the source and the destination planets, and a positive integer N (≤500). Then N lines follow, each in the format: source[i] destination[i] capacity[i] where source[i] and destination[i] are the names of the satellites and the two involved planets, and capacity[i] \u0026gt; 0 is the maximum number of passengers that can be transported at one pass from source[i] to destination[i]. Each name is a string of 3 uppercase characters chosen from {A-Z}, e.g., ZJU. Note that the satellite transportation stations have no accommodation facilities for the passengers. Therefore none of the passengers can stay. Such a station will not allow arrivals of space vessels that contain more than its own capacity. It is guaranteed that the list contains neither the routes to the source planet nor that from the destination planet.\nOutput Specification: For each test case, just print in one line the minimum capacity that a planet station must have to guarantee that every space vessel can dock and download its passengers on arrival.\nSample Input: EAR MAR 11 EAR AAA 300 EAR BBB 400 AAA BBB 100 AAA CCC 400 AAA MAR 300 BBB DDD 400 AAA DDD 400 DDD AAA 100 CCC MAR 400 DDD CCC 200 DDD MAR 300 Sample Output: 700 Code Dinic // USING DINIC #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define MAXN 2000 #define INF 0x3f3f3f3f typedef enum { FALSE, TRUE } boolean; typedef struct Graph{ int edge_num; int node_num; int flow[MAXN][MAXN]; char dict[MAXN][4]; }Graph ; typedef struct QueueNode{ int val; struct QueueNode* next; }QueueNode ; typedef struct Queue{ QueueNode* head; QueueNode* tail; }Queue ; QueueNode* queue_node_init(int val){ QueueNode* res = (QueueNode*)malloc(sizeof(QueueNode)); res-\u0026gt;val = val; res-\u0026gt;next = NULL; return res; } Queue* queue_init(){ Queue* res = (Queue*)malloc(sizeof(Queue)); res-\u0026gt;head = queue_node_init(0); res-\u0026gt;tail = res-\u0026gt;head; return res; } void queue_insert(Queue* queue, int val){ QueueNode* node = queue_node_init(val); queue-\u0026gt;tail-\u0026gt;next = node; queue-\u0026gt;tail = node; queue-\u0026gt;head-\u0026gt;val++; } int queue_pop(Queue* queue){ int res = -1; QueueNode* cur = queue-\u0026gt;head-\u0026gt;next; if(cur!=NULL){ res = cur-\u0026gt;val; queue-\u0026gt;head-\u0026gt;next = cur-\u0026gt;next; if(cur==queue-\u0026gt;tail){ queue-\u0026gt;tail = queue-\u0026gt;head; } free(cur); cur = NULL; queue-\u0026gt;head-\u0026gt;val--; } return res; } void queue_delete(Queue* queue){ QueueNode* cur = queue-\u0026gt;head; while(cur!=NULL){ QueueNode* tmp = cur; cur = cur-\u0026gt;next; free(tmp); tmp = NULL; } free(queue); queue = NULL; } boolean queue_is_empty(Queue* queue){ if(queue-\u0026gt;head==queue-\u0026gt;tail) return TRUE; return FALSE; } Graph* graph_init(char* start, char* end, int edge_num){ Graph* res = (Graph*)malloc(sizeof(Graph)); res-\u0026gt;edge_num = 2; res-\u0026gt;node_num = edge_num; memset(res-\u0026gt;flow, 0, sizeof(res-\u0026gt;flow)); strcpy(res-\u0026gt;dict[0], start); strcpy(res-\u0026gt;dict[1], end); return res; } void graph_insert_edge(Graph* graph, char* planet1, char* planet2, int weight){ int p1_idx = -1; int p2_idx = -1; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ if(strcmp(graph-\u0026gt;dict[i], planet1)==0){ p1_idx = i; } if(strcmp(graph-\u0026gt;dict[i], planet2)==0){ p2_idx = i; } } if(p1_idx==-1){ strcpy(graph-\u0026gt;dict[graph-\u0026gt;node_num], planet1); p1_idx = graph-\u0026gt;node_num; graph-\u0026gt;node_num++; } if(p2_idx==-1){ strcpy(graph-\u0026gt;dict[graph-\u0026gt;node_num], planet2); p2_idx = graph-\u0026gt;node_num; graph-\u0026gt;node_num++; } graph-\u0026gt;flow[p1_idx][p2_idx] = weight; } int min(int a, int b){ if(a\u0026gt;b) return b; return a; } int count_node_flow_sum(Graph* graph, int idx){ int res = 0; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ res += graph-\u0026gt;flow[idx][i]; } return res; } void build_level_graph_bfs(int* level, Graph* graph){ Queue* queue = queue_init(); queue_insert(queue, 0); level[0] = 1; while(!queue_is_empty(queue)){ int cur_idx = queue_pop(queue); for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ if(level[i]==0 \u0026amp;\u0026amp; graph-\u0026gt;flow[cur_idx][i]\u0026gt;0){ queue_insert(queue, i); level[i] = level[cur_idx]+1; } } } queue_delete(queue); } int find_blocking_flow_dfs(Graph* graph, int* level, int cur_idx, int last_flow){ if(cur_idx==1){ // meet end return last_flow; } int res = 0; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ if(level[i]==level[cur_idx]+1 \u0026amp;\u0026amp; graph-\u0026gt;flow[cur_idx][i]\u0026gt;0){ int flow = find_blocking_flow_dfs(graph, level, i, min(last_flow-res, graph-\u0026gt;flow[cur_idx][i])); graph-\u0026gt;flow[cur_idx][i] -= flow; graph-\u0026gt;flow[i][cur_idx] += flow; res += flow; } } return res; } void dinic(Graph* graph){ int level[MAXN]; while(1){ // build level graph memset(level, 0, sizeof(level)); build_level_graph_bfs(level, graph); // find blocking flow in level graph // \u0026amp; // update residual graph if(!find_blocking_flow_dfs(graph, level, 0, INF)){ // No blocking flow then break break; } } } int main(int argc, char *argv[]){ char start[4]; char end[4]; int edge_num; scanf(\u0026#34;%s %s %d\u0026#34;, start, end, \u0026amp;edge_num); Graph* graph = graph_init(start, end, edge_num); for(int i=0; i\u0026lt;edge_num; i++){ char planet1[4]; char planet2[4]; int capacity; scanf(\u0026#34;%s %s %d\u0026#34;, planet1, planet2, \u0026amp;capacity); graph_insert_edge(graph, planet1, planet2, capacity); } int before = count_node_flow_sum(graph, 0); dinic(graph); int after = count_node_flow_sum(graph, 0); printf(\u0026#34;%d\\n\u0026#34;, before-after); return 0; } Code Ford Fulkerson #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define MAXN 2000 #define INF 0x3f3f3f3f typedef enum { FALSE, TRUE } boolean; typedef struct Graph{ int edge_num; int node_num; int flow[MAXN][MAXN]; char dict[MAXN][4]; }Graph ; typedef struct QueueNode{ int val; struct QueueNode* next; }QueueNode ; typedef struct Queue{ QueueNode* head; QueueNode* tail; }Queue ; QueueNode* queue_node_init(int val){ QueueNode* res = (QueueNode*)malloc(sizeof(QueueNode)); res-\u0026gt;val = val; res-\u0026gt;next = NULL; return res; } Queue* queue_init(){ Queue* res = (Queue*)malloc(sizeof(Queue)); res-\u0026gt;head = queue_node_init(0); res-\u0026gt;tail = res-\u0026gt;head; return res; } void queue_insert(Queue* queue, int val){ QueueNode* node = queue_node_init(val); queue-\u0026gt;tail-\u0026gt;next = node; queue-\u0026gt;tail = node; queue-\u0026gt;head-\u0026gt;val++; } int queue_pop(Queue* queue){ int res = -1; QueueNode* cur = queue-\u0026gt;head-\u0026gt;next; if(cur!=NULL){ res = cur-\u0026gt;val; queue-\u0026gt;head-\u0026gt;next = cur-\u0026gt;next; if(cur==queue-\u0026gt;tail){ queue-\u0026gt;tail = queue-\u0026gt;head; } free(cur); cur = NULL; queue-\u0026gt;head-\u0026gt;val--; } return res; } void queue_delete(Queue* queue){ QueueNode* cur = queue-\u0026gt;head; while(cur!=NULL){ QueueNode* tmp = cur; cur = cur-\u0026gt;next; free(tmp); tmp = NULL; } free(queue); queue = NULL; } void queue_empty(Queue* queue){ QueueNode* cur = queue-\u0026gt;head-\u0026gt;next; while(cur!=NULL){ QueueNode* tmp = cur; cur = cur-\u0026gt;next; free(tmp); tmp = NULL; } queue-\u0026gt;tail = queue-\u0026gt;head; } boolean queue_is_empty(Queue* queue){ if(queue-\u0026gt;head==queue-\u0026gt;tail) return TRUE; return FALSE; } Graph* graph_init(char* start, char* end, int edge_num){ Graph* res = (Graph*)malloc(sizeof(Graph)); res-\u0026gt;edge_num = 2; res-\u0026gt;node_num = edge_num; memset(res-\u0026gt;flow, 0, sizeof(res-\u0026gt;flow)); strcpy(res-\u0026gt;dict[0], start); strcpy(res-\u0026gt;dict[1], end); return res; } void graph_insert_edge(Graph* graph, char* planet1, char* planet2, int weight){ int p1_idx = -1; int p2_idx = -1; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ if(strcmp(graph-\u0026gt;dict[i], planet1)==0){ p1_idx = i; } if(strcmp(graph-\u0026gt;dict[i], planet2)==0){ p2_idx = i; } } if(p1_idx==-1){ strcpy(graph-\u0026gt;dict[graph-\u0026gt;node_num], planet1); p1_idx = graph-\u0026gt;node_num; graph-\u0026gt;node_num++; } if(p2_idx==-1){ strcpy(graph-\u0026gt;dict[graph-\u0026gt;node_num], planet2); p2_idx = graph-\u0026gt;node_num; graph-\u0026gt;node_num++; } graph-\u0026gt;flow[p1_idx][p2_idx] = weight; } int min(int a, int b){ if(a\u0026gt;b) return b; return a; } boolean has_one_path_bfs(Graph* graph, Queue* queue, boolean* visit, int* path, int start, int end){ queue_insert(queue, start); while (!queue_is_empty(queue)) { int cur_idx = queue_pop(queue); visit[cur_idx] = TRUE; if(cur_idx==end) return TRUE; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ if(!visit[i] \u0026amp;\u0026amp; graph-\u0026gt;flow[cur_idx][i]\u0026gt;0){ queue_insert(queue, i); path[i] = cur_idx; } } } return FALSE; } int update_one_path_residual_dfs(Graph* graph, int* path, int cur_idx, int end, int last_num){ if(cur_idx==end){ return last_num; } int next = path[cur_idx]; int min_flow = update_one_path_residual_dfs(graph, path, next, end, min(last_num, graph-\u0026gt;flow[next][cur_idx])); graph-\u0026gt;flow[next][cur_idx] -= min_flow; graph-\u0026gt;flow[cur_idx][next] += min_flow; return min_flow; } void ford_fulkerson(Graph* graph){ Queue* queue = queue_init(); int path[MAXN]; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++) path[i] = i; boolean visit[MAXN]; memset(visit, FALSE, sizeof(visit)); int count = 0; while(has_one_path_bfs(graph, queue, visit, path, 0, 1)){ update_one_path_residual_dfs(graph, path, 1, 0, INF); for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++) path[i] = i; queue_empty(queue); memset(visit, FALSE, sizeof(visit)); } queue_delete(queue); } int count_node_flow_sum(Graph* graph, int idx){ int res = 0; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ res += graph-\u0026gt;flow[idx][i]; } return res; } int main(int argc, char *argv[]){ char start[4]; char end[4]; int edge_num; scanf(\u0026#34;%s %s %d\u0026#34;, start, end, \u0026amp;edge_num); Graph* graph = graph_init(start, end, edge_num); for(int i=0; i\u0026lt;edge_num; i++){ char planet1[4]; char planet2[4]; int capacity; scanf(\u0026#34;%s %s %d\u0026#34;, planet1, planet2, \u0026amp;capacity); graph_insert_edge(graph, planet1, planet2, capacity); } int before = count_node_flow_sum(graph, 0); ford_fulkerson(graph); int after = count_node_flow_sum(graph, 0); printf(\u0026#34;%d\\n\u0026#34;, before-after); return 0; } ","permalink":"https://novel2430.github.io/notes/universal-travel-sites/","summary":"\u003ch1 id=\"universal-travel-sites\"\u003eUniversal Travel Sites\u003c/h1\u003e\n\u003cp\u003eAfter finishing her tour around the Earth, CYLL is now planning a universal travel sites development project. After a careful investigation, she has a list of capacities of all the satellite transportation stations in hand. To estimate a budget, she must know the minimum capacity that a planet station must have to guarantee that every space vessel can dock and download its passengers on arrival.\u003c/p\u003e\n\u003ch2 id=\"input-specification\"\u003eInput Specification:\u003c/h2\u003e\n\u003cp\u003eEach input file contains one test case. For each case, the first line contains the names of the source and the destination planets, and a positive integer N (≤500). Then N lines follow, each in the format: \u003ccode\u003esource[i]\u003c/code\u003e \u003ccode\u003edestination[i]\u003c/code\u003e \u003ccode\u003ecapacity[i]\u003c/code\u003e where \u003ccode\u003esource[i]\u003c/code\u003e and \u003ccode\u003edestination[i]\u003c/code\u003e are the names of the satellites and the two involved planets, and \u003ccode\u003ecapacity[i]\u003c/code\u003e \u0026gt; 0 is the maximum number of passengers that can be transported at one pass from \u003ccode\u003esource[i]\u003c/code\u003e to \u003ccode\u003edestination[i]\u003c/code\u003e. Each name is a string of 3 uppercase characters chosen from {A-Z}, e.g., ZJU.\nNote that the satellite transportation stations have no accommodation facilities for the passengers. Therefore none of the passengers can stay. Such a station will not allow arrivals of space vessels that contain more than its own capacity. It is guaranteed that the list contains neither the routes to the source planet nor that from the destination planet.\u003c/p\u003e","title":"Universal Travel Sites"},{"content":"7-1 Hamiltonian Cycle The \u0026ldquo;Hamilton cycle problem\u0026rdquo; is to find a simple cycle that contains every vertex in a graph. Such a cycle is called a \u0026ldquo;Hamiltonian cycle\u0026rdquo;.\nIn this problem, you are supposed to tell if a given cycle is a Hamiltonian cycle.\nInput Specification: Each input file contains one test case. For each case, the first line contains 2 positive integers N (2\u0026lt;N≤200), the number of vertices, and M, the number of edges in an undirected graph. Then M lines follow, each describes an edge in the format Vertex1 Vertex2, where the vertices are numbered from 1 to N. The next line gives a positive integer K which is the number of queries, followed by K lines of queries, each in the format:\nn V1 V2 \u0026hellip; Vn\nwhere n is the number of vertices in the list, and Vi\u0026rsquo;s are the vertices on a path.\nOutput Specification: For each query, print in a line YES if the path does form a Hamiltonian cycle, or NO if not.\nSample Input: 6 10 6 2 3 4 1 5 2 5 3 1 4 1 1 6 6 3 1 2 4 5 6 7 5 1 4 3 6 2 5 6 5 1 4 3 6 2 9 6 2 1 6 3 4 5 2 6 4 1 2 5 1 7 6 1 3 4 5 2 6 7 6 1 2 5 4 3 1 Sample Output: YES NO NO NO YES NO Code #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int graph[300][300]; void graph_init(){ for(int i=0; i\u0026lt;300; i++){ for(int j=0; j\u0026lt;300; j++) graph[i][j] = 0; } } int is_seq_ok(int* seq, int size, int total_size){ if(size-1!=total_size || seq[0]!=seq[size-1] ) return 0; int node[total_size+1]; for(int i=0; i\u0026lt;total_size+1; i++) node[i] = 0; node[seq[0]] = 1; for(int i=1; i\u0026lt;size; i++){ if(i\u0026lt;size-1){ if(node[seq[i]]) return 0; node[seq[i]] = 1; } if(graph[seq[i-1]][seq[i]] == 0) { return 0; } } return 1; } int main(int argc, char *argv[]){ graph_init(); int total_size, edge_size; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;total_size, \u0026amp;edge_size); for(int i=0; i\u0026lt;edge_size; i++){ int n1, n2; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n1, \u0026amp;n2); graph[n1][n2] = 1; graph[n2][n1] = 1; } int case_count; scanf(\u0026#34;%d\u0026#34;, \u0026amp;case_count); for(int i=0; i\u0026lt;case_count; i++){ int seq_size; scanf(\u0026#34;%d\u0026#34;, \u0026amp;seq_size); int seq[seq_size]; for(int j=0; j\u0026lt;seq_size; j++){ int num; scanf(\u0026#34;%d\u0026#34;, \u0026amp;num); seq[j] = num; } if(is_seq_ok(seq, seq_size, total_size)) printf(\u0026#34;YES\\n\u0026#34;); else printf(\u0026#34;NO\\n\u0026#34;); } } ","permalink":"https://novel2430.github.io/notes/hamiltonian-cycle/","summary":"\u003ch1 id=\"7-1-hamiltonian-cycle\"\u003e7-1 Hamiltonian Cycle\u003c/h1\u003e\n\u003cp\u003eThe \u0026ldquo;Hamilton cycle problem\u0026rdquo; is to find a simple cycle that contains every vertex in a graph. Such a cycle is called a \u0026ldquo;Hamiltonian cycle\u0026rdquo;.\u003c/p\u003e\n\u003cp\u003eIn this problem, you are supposed to tell if a given cycle is a Hamiltonian cycle.\u003c/p\u003e\n\u003ch2 id=\"input-specification\"\u003eInput Specification:\u003c/h2\u003e\n\u003cp\u003eEach input file contains one test case. For each case, the first line contains 2 positive integers N (2\u0026lt;N≤200), the number of vertices, and M, the number of edges in an undirected graph. Then M lines follow, each describes an edge in the format \u003ccode\u003eVertex1 Vertex2\u003c/code\u003e, where the vertices are numbered from 1 to N. The next line gives a positive integer K which is the number of queries, followed by K lines of queries, each in the format:\u003cbr\u003e\nn V\u003csub\u003e1\u003c/sub\u003e V\u003csub\u003e2\u003c/sub\u003e \u0026hellip; V\u003csub\u003en\u003c/sub\u003e\u003cbr\u003e\nwhere n is the number of vertices in the list, and V\u003csub\u003ei\u003c/sub\u003e\u0026rsquo;s are the vertices on a path.\u003c/p\u003e","title":"Hamiltonian Cycle"},{"content":"6-1 Is Topological Order Write a program to test if a give sequence Seq is a topological order of a given graph Graph.\nFormat of functions: bool IsTopSeq( LGraph Graph, Vertex Seq[] ); where LGraph is defined as the following:\ntypedef struct AdjVNode *PtrToAdjVNode; struct AdjVNode{ Vertex AdjV; PtrToAdjVNode Next; }; typedef struct Vnode{ PtrToAdjVNode FirstEdge; } AdjList[MaxVertexNum]; typedef struct GNode *PtrToGNode; struct GNode{ int Nv; int Ne; AdjList G; }; typedef PtrToGNode LGraph; The function IsTopSeq must return true if Seq does correspond to a topological order; otherwise return false.\nNote: Although the vertices are numbered from 1 to MaxVertexNum, they are indexed from 0 in the LGraph structure.\nSample program of judge: #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef enum {false, true} bool; #define MaxVertexNum 10 /* maximum number of vertices */ typedef int Vertex; /* vertices are numbered from 1 to MaxVertexNum */ typedef struct AdjVNode *PtrToAdjVNode; struct AdjVNode{ Vertex AdjV; PtrToAdjVNode Next; }; typedef struct Vnode{ PtrToAdjVNode FirstEdge; } AdjList[MaxVertexNum]; typedef struct GNode *PtrToGNode; struct GNode{ int Nv; int Ne; AdjList G; }; typedef PtrToGNode LGraph; LGraph ReadG(); /* details omitted */ bool IsTopSeq( LGraph Graph, Vertex Seq[] ); int main() { int i, j, N; Vertex Seq[MaxVertexNum]; LGraph G = ReadG(); scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); for (i=0; i\u0026lt;N; i++) { for (j=0; j\u0026lt;G-\u0026gt;Nv; j++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;Seq[j]); if ( IsTopSeq(G, Seq)==true ) printf(\u0026#34;yes\\n\u0026#34;); else printf(\u0026#34;no\\n\u0026#34;); } return 0; } /* Your function will be put here */ Sample Input (for the graph shown in the figure): 6 8 1 2 1 3 5 2 5 4 2 3 2 6 3 4 6 4 5 1 5 2 3 6 4 5 1 2 6 3 4 5 1 2 3 6 4 5 2 1 6 3 4 1 2 3 4 5 6 Sample Output: yes yes yes no no Code #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef enum {false, true} bool; #define MaxVertexNum 10 /* maximum number of vertices */ typedef int Vertex; /* vertices are numbered from 1 to MaxVertexNum */ typedef struct AdjVNode *PtrToAdjVNode; struct AdjVNode{ Vertex AdjV; PtrToAdjVNode Next; }; typedef struct Vnode{ PtrToAdjVNode FirstEdge; } AdjList[MaxVertexNum]; typedef struct GNode *PtrToGNode; struct GNode{ int Nv; int Ne; AdjList G; }; typedef PtrToGNode LGraph; LGraph ReadG(); /* details omitted */ bool IsTopSeq( LGraph Graph, Vertex Seq[] ); int main() { int i, j, N; Vertex Seq[MaxVertexNum]; LGraph G = ReadG(); scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); for (i=0; i\u0026lt;N; i++) { for (j=0; j\u0026lt;G-\u0026gt;Nv; j++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;Seq[j]); if ( IsTopSeq(G, Seq)==true ) printf(\u0026#34;yes\\n\u0026#34;); else printf(\u0026#34;no\\n\u0026#34;); } return 0; } /* Your function will be put here */ bool IsTopSeq( LGraph Graph, Vertex Seq[] ){ int in_degree[1000]; PtrToAdjVNode t_node; for(int i=0;i\u0026lt;=Graph-\u0026gt;Nv;i++) in_degree[i]=0; for(int i=0;i\u0026lt;Graph-\u0026gt;Nv;i++){ t_node=Graph-\u0026gt;G[i].FirstEdge; while (t_node){ in_degree[t_node-\u0026gt;AdjV] = in_degree[t_node-\u0026gt;AdjV] + 1; t_node=t_node-\u0026gt;Next; } } for(int i=0;i\u0026lt;Graph-\u0026gt;Nv;i++){ if(in_degree[Seq[i]-1]!=0) return false; else{ t_node=Graph-\u0026gt;G[Seq[i]-1].FirstEdge; while(t_node){ in_degree[t_node-\u0026gt;AdjV] = in_degree[t_node-\u0026gt;AdjV] - 1; t_node=t_node-\u0026gt;Next; } } } return true; } ","permalink":"https://novel2430.github.io/notes/is-topological-order/","summary":"\u003ch1 id=\"6-1-is-topological-order\"\u003e6-1 Is Topological Order\u003c/h1\u003e\n\u003cp\u003eWrite a program to test if a give sequence \u003ccode\u003eSeq\u003c/code\u003e is a topological order of a given graph \u003ccode\u003eGraph\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"format-of-functions\"\u003eFormat of functions:\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eIsTopSeq\u003c/span\u003e( LGraph Graph, Vertex Seq[] );\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003ewhere \u003ccode\u003eLGraph\u003c/code\u003e is defined as the following:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e AdjVNode \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ePtrToAdjVNode; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e AdjVNode{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Vertex AdjV;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    PtrToAdjVNode Next;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e Vnode{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    PtrToAdjVNode FirstEdge;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e} AdjList[MaxVertexNum];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e GNode \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ePtrToGNode;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e GNode{  \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e Nv;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e Ne;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    AdjList G;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e PtrToGNode LGraph;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe function \u003ccode\u003eIsTopSeq\u003c/code\u003e must return \u003ccode\u003etrue\u003c/code\u003e if \u003ccode\u003eSeq\u003c/code\u003e does correspond to a topological order; otherwise return \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e","title":"Is Topological Order"},{"content":"7-1 File Transfer We have a network of computers and a list of bi-directional connections. Each of these connections allows a file transfer from one computer to another. Is it possible to send a file from any computer on the network to any other?\nInput Specification: Each input file contains one test case. For each test case, the first line contains N (2≤N≤104), the total number of computers in a network. Each computer in the network is then represented by a positive integer between 1 and N. Then in the following lines, the input is given in the format:\nI c1 c2 where I stands for inputting a connection between c1 and c2; or\nC c1 c2 where C stands for checking if it is possible to transfer files between c1 and c2; or\nS where S stands for stopping this case.\nOutput Specification: For each C case, print in one line the word \u0026ldquo;yes\u0026rdquo; or \u0026ldquo;no\u0026rdquo; if it is possible or impossible to transfer files between c1 and c2, respectively. At the end of each case, print in one line \u0026ldquo;The network is connected.\u0026rdquo; if there is a path between any pair of computers; or \u0026ldquo;There are k components.\u0026rdquo; where k is the number of connected components in this network.\nSample Input 1: 5 C 3 2 I 3 2 C 1 5 I 4 5 I 2 4 C 3 5 S Sample Output 1: no no yes There are 2 components. Sample Input 2: 5 C 3 2 I 3 2 C 1 5 I 4 5 I 2 4 C 3 5 I 1 3 C 1 5 S Sample Output 2: no no yes yes The network is connected. Code #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define true 1 #define false 0 typedef struct Node{ struct Node* parent; }Node ; // Node op Node* node_init(){ Node* res = (Node*)malloc(sizeof(Node)); res-\u0026gt;parent = res; return res; } Node* node_check_father(Node* node){ if(node-\u0026gt;parent == node) return node; node-\u0026gt;parent = node_check_father(node-\u0026gt;parent); return node-\u0026gt;parent; } Node* node_check_father_non_recursice(Node* node){ // find root Node* root = node; while(root-\u0026gt;parent!=root) root = root-\u0026gt;parent; // set root Node* cur = node; while(cur!=root){ Node* tmp = cur-\u0026gt;parent; cur-\u0026gt;parent = root; cur = tmp; } return root; } void node_build_connect(Node* n1, Node* n2){ if(n1==NULL || n2==NULL) return; node_check_father(n1)-\u0026gt;parent = node_check_father(n2); } int node_is_connect(Node* n1, Node* n2){ Node* n1_father = node_check_father(n1); Node* n2_father = node_check_father(n2); if(n1_father==n2_father) return true; return false; } int count_components(Node** nodes, int size){ int count = 0; for(int i=0; i\u0026lt;size; i++){ if(nodes[i]-\u0026gt;parent==nodes[i]) count++; } return count; } int main(int argc, char *argv[]){ int size; scanf(\u0026#34;%d\u0026#34;, \u0026amp;size); Node* nodes[size]; for(int i=0; i\u0026lt;size; i++) nodes[i] = node_init(); while(1){ getchar(); char op; scanf(\u0026#34;%c\u0026#34;, \u0026amp;op); if(op==\u0026#39;S\u0026#39;) break; int n1, n2; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n1, \u0026amp;n2); if(op==\u0026#39;C\u0026#39;){ if(node_is_connect(nodes[n1-1], nodes[n2-1])){ printf(\u0026#34;yes\\n\u0026#34;); } else printf(\u0026#34;no\\n\u0026#34;); } else if(op==\u0026#39;I\u0026#39;){ node_build_connect(nodes[n1-1], nodes[n2-1]); } } int count = count_components(nodes, size); if(count==1) printf(\u0026#34;The network is connected.\\n\u0026#34;); else printf(\u0026#34;There are %d components.\\n\u0026#34;, count); } ","permalink":"https://novel2430.github.io/notes/file-transfer/","summary":"\u003ch1 id=\"7-1-file-transfer\"\u003e7-1 File Transfer\u003c/h1\u003e\n\u003cp\u003eWe have a network of computers and a list of bi-directional connections. Each of these connections allows a file transfer from one computer to another. Is it possible to send a file from any computer on the network to any other?\u003c/p\u003e\n\u003ch2 id=\"input-specification\"\u003eInput Specification:\u003c/h2\u003e\n\u003cp\u003eEach input file contains one test case. For each test case, the first line contains N (2≤N≤10\u003csup\u003e4\u003c/sup\u003e), the total number of computers in a network. Each computer in the network is then represented by a positive integer between 1 and N. Then in the following lines, the input is given in the format:\u003c/p\u003e","title":"File Transfer"},{"content":"7-1 Complete Binary Search Tree A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:\nThe left subtree of a node contains only nodes with keys less than the node\u0026rsquo;s key. The right subtree of a node contains only nodes with keys greater than or equal to the node\u0026rsquo;s key. Both the left and right subtrees must also be binary search trees. A Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right. Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST.\nInput Specification: Each input file contains one test case. For each case, the first line contains a positive integer N (≤1000). Then N distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000.\nOutput Specification: For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.\nSample Input: 10 1 2 3 4 5 6 7 8 9 0 Sample Output: 6 3 8 1 5 7 9 0 2 4 Code #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // Merge Sort void merge_sort_help(int* arr, int* tmp, int low_idx, int high_idx){ if(low_idx\u0026gt;=high_idx) return; int mid = (low_idx + high_idx)/2; merge_sort_help(arr, tmp, low_idx, mid); merge_sort_help(arr, tmp, mid+1, high_idx); int start1 = low_idx; int end1 = mid; int start2 = mid+1; int end2 = high_idx; int cur_idx = start1; while(cur_idx\u0026lt;=high_idx){ if(arr[start1] \u0026lt; arr[start2] \u0026amp;\u0026amp; start1\u0026lt;=end1){ tmp[cur_idx] = arr[start1++]; } else if(arr[start1] \u0026gt;= arr[start2] \u0026amp;\u0026amp; start2\u0026lt;=end2){ tmp[cur_idx] = arr[start2++]; } else if (start1\u0026gt;end1) { tmp[cur_idx] = arr[start2++]; } else if (start2\u0026gt;end2) { tmp[cur_idx] = arr[start1++]; } cur_idx++; } for(int i=low_idx; i\u0026lt;=high_idx; i++){ arr[i] = tmp[i]; } } void merge_sort(int* arr, int size){ int* tmp = (int*)malloc(sizeof(int)*size); merge_sort_help(arr, tmp, 0, size-1); } // Build Tree Layer print void get_tree_layer_help(int* inorder, int n, int size, int* cur_idx, int* layer){ if(n\u0026gt;=size) return; get_tree_layer_help(inorder, 2*n+1, size, cur_idx, layer); layer[n] = inorder[(*cur_idx)++]; get_tree_layer_help(inorder, 2*(n+1), size, cur_idx, layer); } int* get_tree_layer(int* inorder, int size){ int* tmp = (int*)malloc(sizeof(int)*size); int base_idx = 0; get_tree_layer_help(inorder, 0, size, \u0026amp;base_idx, tmp); return tmp; } int main(int argc, char *argv[]){ int count; scanf(\u0026#34;%d\u0026#34;, \u0026amp;count); int nums[count]; for(int i=0; i\u0026lt;count; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;nums[i]); merge_sort(nums, count); int* res = get_tree_layer(nums, count); for(int i=0; i\u0026lt;count; i++){ if(i\u0026gt;0) printf(\u0026#34; \u0026#34;); printf(\u0026#34;%d\u0026#34;, res[i]); } return 0; } ","permalink":"https://novel2430.github.io/notes/complete-binart-search-tree/","summary":"\u003ch1 id=\"7-1-complete-binary-search-tree\"\u003e7-1 Complete Binary Search Tree\u003c/h1\u003e\n\u003cp\u003eA Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe left subtree of a node contains only nodes with keys less than the node\u0026rsquo;s key.\u003c/li\u003e\n\u003cli\u003eThe right subtree of a node contains only nodes with keys greater than or equal to the node\u0026rsquo;s key.\u003c/li\u003e\n\u003cli\u003eBoth the left and right subtrees must also be binary search trees.\nA Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNow given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST.\u003c/p\u003e","title":"Complete Binart Search Tree"},{"content":"6-1 Percolate Up and Down Write the routines to do a \u0026ldquo;percolate up\u0026rdquo; and a \u0026ldquo;percolate down\u0026rdquo; in a binary min-heap.\nFormat of functions: void PercolateUp( int p, PriorityQueue H ); void PercolateDown( int p, PriorityQueue H ); where int p is the position of the element, and PriorityQueue is defined as the following:\ntypedef struct HeapStruct *PriorityQueue; struct HeapStruct { ElementType *Elements; int Capacity; int Size; }; Sample program of judge: #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef int ElementType; #define MinData -1 typedef struct HeapStruct *PriorityQueue; struct HeapStruct { ElementType *Elements; int Capacity; int Size; }; PriorityQueue Initialize( int MaxElements ); /* details omitted */ void PercolateUp( int p, PriorityQueue H ); void PercolateDown( int p, PriorityQueue H ); void Insert( ElementType X, PriorityQueue H ) { int p = ++H-\u0026gt;Size; H-\u0026gt;Elements[p] = X; PercolateUp( p, H ); } ElementType DeleteMin( PriorityQueue H ) { ElementType MinElement; MinElement = H-\u0026gt;Elements[1]; H-\u0026gt;Elements[1] = H-\u0026gt;Elements[H-\u0026gt;Size--]; PercolateDown( 1, H ); return MinElement; } int main() { int n, i, op, X; PriorityQueue H; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); H = Initialize(n); for ( i=0; i\u0026lt;n; i++ ) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;op); switch( op ) { case 1: scanf(\u0026#34;%d\u0026#34;, \u0026amp;X); Insert(X, H); break; case 0: printf(\u0026#34;%d \u0026#34;, DeleteMin(H)); break; } } printf(\u0026#34;\\nInside H:\u0026#34;); for ( i=1; i\u0026lt;=H-\u0026gt;Size; i++ ) printf(\u0026#34; %d\u0026#34;, H-\u0026gt;Elements[i]); return 0; } /* Your function will be put here */ Sample Input: 9 1 10 1 5 1 2 0 1 9 1 1 1 4 0 0 Sample Output: 2 1 4 Inside H: 5 10 9 Code #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef int ElementType; #define MinData -1 typedef struct HeapStruct *PriorityQueue; struct HeapStruct { ElementType *Elements; int Capacity; int Size; }; PriorityQueue Initialize( int MaxElements ); /* details omitted */ void PercolateUp( int p, PriorityQueue H ); void PercolateDown( int p, PriorityQueue H ); void Insert( ElementType X, PriorityQueue H ) { int p = ++H-\u0026gt;Size; H-\u0026gt;Elements[p] = X; PercolateUp( p, H ); } ElementType DeleteMin( PriorityQueue H ) { ElementType MinElement; MinElement = H-\u0026gt;Elements[1]; H-\u0026gt;Elements[1] = H-\u0026gt;Elements[H-\u0026gt;Size--]; PercolateDown( 1, H ); return MinElement; } int main() { int n, i, op, X; PriorityQueue H; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); H = Initialize(n); for ( i=0; i\u0026lt;n; i++ ) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;op); switch( op ) { case 1: scanf(\u0026#34;%d\u0026#34;, \u0026amp;X); Insert(X, H); break; case 0: printf(\u0026#34;%d \u0026#34;, DeleteMin(H)); break; } } printf(\u0026#34;\\nInside H:\u0026#34;); for ( i=1; i\u0026lt;=H-\u0026gt;Size; i++ ) printf(\u0026#34; %d\u0026#34;, H-\u0026gt;Elements[i]); return 0; } /* Your function will be put here */ void swap(int pos1, int pos2, PriorityQueue H){ ElementType tmp = H-\u0026gt;Elements[pos1]; H-\u0026gt;Elements[pos1] = H-\u0026gt;Elements[pos2]; H-\u0026gt;Elements[pos2] = tmp; } int min_idx(int idx1, int idx2, PriorityQueue H){ if(H-\u0026gt;Elements[idx1] \u0026lt; H-\u0026gt;Elements[idx2]) return idx1; return idx2; } void PercolateUp( int p, PriorityQueue H ){ int pos = p; while(pos\u0026gt;1){ int parent_idx = 1; int val = H-\u0026gt;Elements[pos]; if(pos%2==0) parent_idx = pos/2; else parent_idx = (pos-1)/2; if(H-\u0026gt;Elements[parent_idx]\u0026gt;val) swap(pos, parent_idx, H); else break; pos = parent_idx; } } void PercolateDown( int p, PriorityQueue H ){ int pos = p; while(pos*2 \u0026lt;= H-\u0026gt;Size){ int val = H-\u0026gt;Elements[pos]; int child_idx = H-\u0026gt;Size; if(pos*2+1 \u0026lt;= H-\u0026gt;Size) child_idx = min_idx(pos*2, pos*2+1, H); else child_idx = pos*2; if(H-\u0026gt;Elements[child_idx] \u0026lt; val) swap(pos, child_idx, H); else break; pos = child_idx; } } ","permalink":"https://novel2430.github.io/notes/percolate-up-and-down/","summary":"\u003ch1 id=\"6-1-percolate-up-and-down\"\u003e6-1 Percolate Up and Down\u003c/h1\u003e\n\u003cp\u003eWrite the routines to do a \u0026ldquo;percolate up\u0026rdquo; and a \u0026ldquo;percolate down\u0026rdquo; in a binary min-heap.\u003c/p\u003e\n\u003ch2 id=\"format-of-functions\"\u003eFormat of functions:\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePercolateUp\u003c/span\u003e( \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e p, PriorityQueue H );\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePercolateDown\u003c/span\u003e( \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e p, PriorityQueue H );\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003ewhere \u003ccode\u003eint p\u003c/code\u003e is the position of the element, and \u003ccode\u003ePriorityQueue\u003c/code\u003e is defined as the following:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e HeapStruct \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ePriorityQueue;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e HeapStruct {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ElementType  \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eElements;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e Capacity;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e Size;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"sample-program-of-judge\"\u003eSample program of judge:\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;stdio.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;stdlib.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e ElementType;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define MinData -1\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e HeapStruct \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ePriorityQueue;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e HeapStruct {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ElementType  \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eElements;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e Capacity;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e Size;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePriorityQueue \u003cspan style=\"color:#a6e22e\"\u003eInitialize\u003c/span\u003e( \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e MaxElements ); \u003cspan style=\"color:#75715e\"\u003e/* details omitted */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePercolateUp\u003c/span\u003e( \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e p, PriorityQueue H );\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePercolateDown\u003c/span\u003e( \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e p, PriorityQueue H );\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eInsert\u003c/span\u003e( ElementType X, PriorityQueue H ) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e p \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003eH\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eSize;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[p] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e X;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ePercolateUp\u003c/span\u003e( p, H );\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eElementType \u003cspan style=\"color:#a6e22e\"\u003eDeleteMin\u003c/span\u003e( PriorityQueue H ) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{ \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ElementType MinElement; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    MinElement \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eSize\u003cspan style=\"color:#f92672\"\u003e--\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ePercolateDown\u003c/span\u003e( \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, H );\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e MinElement; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n, i, op, X;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    PriorityQueue H;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003escanf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003en);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    H \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eInitialize\u003c/span\u003e(n);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e ( i\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003en; i\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e ) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003escanf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eop);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eswitch\u003c/span\u003e( op ) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#a6e22e\"\u003escanf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eX);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#a6e22e\"\u003eInsert\u003c/span\u003e(X, H);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ebreak\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#a6e22e\"\u003eprintf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d \u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eDeleteMin\u003c/span\u003e(H));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ebreak\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eprintf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003eInside H:\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e ( i\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e; i\u003cspan style=\"color:#f92672\"\u003e\u0026lt;=\u003c/span\u003eH\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eSize; i\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e )\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003eprintf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34; %d\u0026#34;\u003c/span\u003e, H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[i]);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e/* Your function will be put here */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"sample-input\"\u003eSample Input:\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e9\n1 10\n1 5\n1 2\n0\n1 9\n1 1\n1 4\n0\n0\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"sample-output\"\u003eSample Output:\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e2 1 4 \nInside H: 5 10 9\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"code\"\u003eCode\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;stdio.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;stdlib.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e ElementType;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define MinData -1\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e HeapStruct \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ePriorityQueue;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e HeapStruct {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ElementType  \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eElements;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e Capacity;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e Size;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePriorityQueue \u003cspan style=\"color:#a6e22e\"\u003eInitialize\u003c/span\u003e( \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e MaxElements ); \u003cspan style=\"color:#75715e\"\u003e/* details omitted */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePercolateUp\u003c/span\u003e( \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e p, PriorityQueue H );\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePercolateDown\u003c/span\u003e( \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e p, PriorityQueue H );\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eInsert\u003c/span\u003e( ElementType X, PriorityQueue H ) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e p \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003eH\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eSize;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[p] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e X;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ePercolateUp\u003c/span\u003e( p, H );\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eElementType \u003cspan style=\"color:#a6e22e\"\u003eDeleteMin\u003c/span\u003e( PriorityQueue H ) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{ \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ElementType MinElement; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    MinElement \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eSize\u003cspan style=\"color:#f92672\"\u003e--\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ePercolateDown\u003c/span\u003e( \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, H );\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e MinElement; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n, i, op, X;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    PriorityQueue H;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003escanf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003en);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    H \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eInitialize\u003c/span\u003e(n);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e ( i\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003en; i\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e ) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003escanf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eop);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eswitch\u003c/span\u003e( op ) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#a6e22e\"\u003escanf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eX);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#a6e22e\"\u003eInsert\u003c/span\u003e(X, H);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ebreak\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#a6e22e\"\u003eprintf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d \u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eDeleteMin\u003c/span\u003e(H));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ebreak\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eprintf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003eInside H:\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e ( i\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e; i\u003cspan style=\"color:#f92672\"\u003e\u0026lt;=\u003c/span\u003eH\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eSize; i\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e )\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003eprintf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34; %d\u0026#34;\u003c/span\u003e, H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[i]);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e/* Your function will be put here */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eswap\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e pos1, \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e pos2, PriorityQueue H){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  ElementType tmp \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[pos1];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[pos1] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[pos2];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[pos2] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e tmp;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emin_idx\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e idx1, \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e idx2, PriorityQueue H){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e(H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[idx1] \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[idx2]) \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e idx1;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e idx2;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePercolateUp\u003c/span\u003e( \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e p, PriorityQueue H ){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e pos \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e p;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e(pos\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e parent_idx \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e val \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[pos];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e(pos\u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e) parent_idx \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e pos\u003cspan style=\"color:#f92672\"\u003e/\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e parent_idx \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e (pos\u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e)\u003cspan style=\"color:#f92672\"\u003e/\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e(H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[parent_idx]\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003eval) \u003cspan style=\"color:#a6e22e\"\u003eswap\u003c/span\u003e(pos, parent_idx, H);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ebreak\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    pos \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e parent_idx;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePercolateDown\u003c/span\u003e( \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e p, PriorityQueue H ){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e pos \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e p;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e(pos\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;=\u003c/span\u003e H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eSize){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e val \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[pos];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e child_idx \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eSize;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e(pos\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;=\u003c/span\u003e H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eSize)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      child_idx \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emin_idx\u003c/span\u003e(pos\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e, pos\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, H);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e child_idx \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e pos\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e(H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[child_idx] \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e val) \u003cspan style=\"color:#a6e22e\"\u003eswap\u003c/span\u003e(pos, child_idx, H);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ebreak\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    pos \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e child_idx;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"Percolate Up and Down"},{"content":"7-1 ZigZagging on a Tree Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences. And it is a simple standard routine to print the numbers in level-order. However, if you think the problem is too simple, then you are too naive. This time you are supposed to print the numbers in \u0026ldquo;zigzagging order\u0026rdquo; \u0026ndash; that is, starting from the root, print the numbers level-by-level, alternating between left to right and right to left. For example, for the following tree you must output: 1 11 5 8 17 12 20 15.\nInput Specification: Each input file contains one test case. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the inorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space.\nOutput Specification: For each test case, print the zigzagging sequence of the tree in a line. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.\nSample Input: 8 12 11 20 17 1 15 8 5 12 20 17 11 15 8 5 1 Sample Output: 1 11 5 8 17 12 20 15 Note 2 part\nBuild tree by inorder/preorder or inorder/postorder zig-zag print tree build tree TreeNode* build_tree(int* inorder, int* postorder, int length){ if(length==0) return NULL; int root_val = postorder[length-1]; TreeNode* res = tree_node_init(root_val); int idx = 0; // find root idx in inorder seq for(int i=0; i\u0026lt;length; i++){ if(inorder[i] == root_val){ idx = i; break; } } // split old seq to new seq (go left) int new_inorder[30]; int new_postorder[30]; for(int i=0; i\u0026lt;idx; i++) { new_inorder[i] = inorder[i]; new_postorder[i] = postorder[i]; } res-\u0026gt;left = build_tree(new_inorder, new_postorder, idx); // split old seq to new seq (go rigth) for(int i=0; i+idx+1\u0026lt;length; i++) { new_inorder[i] = inorder[i+idx+1]; } for(int i=0; i+idx\u0026lt;length-1; i++){ new_postorder[i] = postorder[i+idx]; } res-\u0026gt;right = build_tree(new_inorder, new_postorder, length-idx-1); return res; } zig-zag use 2 stack\nvoid tree_zig_zag_print(Tree* tree){ if(tree==NULL || tree-\u0026gt;top==NULL) return; my_stack* stack = stack_init(); my_stack* stack_2 = stack_init(); stack_push(stack, tree-\u0026gt;top); int flag = 0; // stop when 2 stack all empty while(!stack_is_empty(stack) || !stack_is_empty(stack_2)){ // stack1 pop, and push in stack2 while(!stack_is_empty(stack)){ TreeNode* cur = stack_pop(stack); if(flag++ \u0026gt; 0) printf(\u0026#34; \u0026#34;); printf(\u0026#34;%d\u0026#34;, cur-\u0026gt;value); if(cur-\u0026gt;right != NULL) stack_push(stack_2, cur-\u0026gt;right); if(cur-\u0026gt;left != NULL) stack_push(stack_2, cur-\u0026gt;left); } // stack2 pop, and push in stack1 while(!stack_is_empty(stack_2)){ TreeNode* cur = stack_pop(stack_2); printf(\u0026#34; %d\u0026#34;, cur-\u0026gt;value); if(cur-\u0026gt;left != NULL) stack_push(stack, cur-\u0026gt;left); if(cur-\u0026gt;right != NULL) stack_push(stack, cur-\u0026gt;right); } } stack_delete(stack); stack_delete(stack_2); } Code #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // Tree typedef struct TreeNode{ int value; struct TreeNode* left; struct TreeNode* right; } TreeNode ; typedef struct Tree { TreeNode* top; } Tree ; // Stack typedef struct stack_node{ TreeNode* values; struct stack_node* next; struct stack_node* before; }stack_node; typedef struct my_stack { stack_node* head; stack_node* top; }my_stack; // Stack \u0026amp; Stack Node op stack_node* node_init(TreeNode* val){ stack_node* node = (stack_node*)malloc(sizeof(stack_node)); node-\u0026gt;values = val; node-\u0026gt;next = NULL; node-\u0026gt;before = NULL; return node; } void node_delete(stack_node* node){ if(node==NULL) return; free(node); node = NULL; } my_stack* stack_init(){ my_stack* res = (my_stack*)malloc(sizeof(my_stack)); res-\u0026gt;head = node_init(NULL); res-\u0026gt;top = res-\u0026gt;head; return res; } void stack_delete(my_stack* stack){ if(stack==NULL) return; stack_node* cur = stack-\u0026gt;head; while(cur != NULL){ stack_node* next_node = cur-\u0026gt;next; node_delete(cur); cur = next_node; } free(stack); stack = NULL; } void stack_push(my_stack* stack, TreeNode* val){ stack_node* node = node_init(val); stack-\u0026gt;top-\u0026gt;next = node; node-\u0026gt;before = stack-\u0026gt;top; stack-\u0026gt;top = node; } TreeNode* stack_pop(my_stack* stack){ TreeNode* res = stack-\u0026gt;top-\u0026gt;values; stack_node* old_top = stack-\u0026gt;top; stack_node* new_top = stack-\u0026gt;top-\u0026gt;before; node_delete(old_top); stack-\u0026gt;top = new_top; stack-\u0026gt;top-\u0026gt;next = NULL; return res; } int stack_is_empty(my_stack* stack){ if(stack==NULL || stack-\u0026gt;head!=stack-\u0026gt;top){ return 0; } return 1; } // Tree \u0026amp; Tree Node op TreeNode* tree_node_init(int num){ TreeNode* res = (TreeNode*)malloc(sizeof(TreeNode)); res-\u0026gt;value = num; res-\u0026gt;left = NULL; res-\u0026gt;right = NULL; return res; } void tree_node_delete(TreeNode* node){ if(node == NULL) return; free(node); node = NULL; } Tree* tree_init(){ Tree* res = (Tree*)malloc(sizeof(Tree)); res-\u0026gt;top = NULL; return res; } void tree_delete_help(TreeNode* node){ if(node == NULL) return; tree_delete_help(node-\u0026gt;left); tree_delete_help(node-\u0026gt;right); free(node); node = NULL; } void tree_delete(Tree* tree){ if(tree==NULL) return; TreeNode* cur = tree-\u0026gt;top; tree_delete_help(cur); } void tree_zig_zag_print(Tree* tree){ if(tree==NULL || tree-\u0026gt;top==NULL) return; my_stack* stack = stack_init(); my_stack* stack_2 = stack_init(); stack_push(stack, tree-\u0026gt;top); int flag = 0; while(!stack_is_empty(stack) || !stack_is_empty(stack_2)){ while(!stack_is_empty(stack)){ TreeNode* cur = stack_pop(stack); if(flag++ \u0026gt; 0) printf(\u0026#34; \u0026#34;); printf(\u0026#34;%d\u0026#34;, cur-\u0026gt;value); if(cur-\u0026gt;right != NULL) stack_push(stack_2, cur-\u0026gt;right); if(cur-\u0026gt;left != NULL) stack_push(stack_2, cur-\u0026gt;left); } while(!stack_is_empty(stack_2)){ TreeNode* cur = stack_pop(stack_2); printf(\u0026#34; %d\u0026#34;, cur-\u0026gt;value); if(cur-\u0026gt;left != NULL) stack_push(stack, cur-\u0026gt;left); if(cur-\u0026gt;right != NULL) stack_push(stack, cur-\u0026gt;right); } } stack_delete(stack); stack_delete(stack_2); } TreeNode* build_tree(int* inorder, int* postorder, int length){ if(length==0) return NULL; int root_val = postorder[length-1]; TreeNode* res = tree_node_init(root_val); int idx = 0; for(int i=0; i\u0026lt;length; i++){ if(inorder[i] == root_val){ idx = i; break; } } int new_inorder[30]; int new_postorder[30]; for(int i=0; i\u0026lt;idx; i++) { new_inorder[i] = inorder[i]; new_postorder[i] = postorder[i]; } res-\u0026gt;left = build_tree(new_inorder, new_postorder, idx); for(int i=0; i+idx+1\u0026lt;length; i++) { new_inorder[i] = inorder[i+idx+1]; } for(int i=0; i+idx\u0026lt;length-1; i++){ new_postorder[i] = postorder[i+idx]; } res-\u0026gt;right = build_tree(new_inorder, new_postorder, length-idx-1); return res; } int main(){ Tree* tree = tree_init(); int node_num; scanf(\u0026#34;%d\u0026#34;, \u0026amp;node_num); int inorder[31]; int postorder[31]; for(int i=0; i\u0026lt;node_num; i++){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;inorder[i]); } for(int i=0; i\u0026lt;node_num; i++){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;postorder[i]); } tree-\u0026gt;top = build_tree(inorder, postorder, node_num); tree_zig_zag_print(tree); tree_delete(tree); } ","permalink":"https://novel2430.github.io/notes/zig-zagging-on-a-tree/","summary":"\u003ch1 id=\"7-1-zigzagging-on-a-tree\"\u003e7-1 ZigZagging on a Tree\u003c/h1\u003e\n\u003cp\u003eSuppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences. And it is a simple standard routine to print the numbers in level-order. However, if you think the problem is too simple, then you are too naive. This time you are supposed to print the numbers in \u0026ldquo;zigzagging order\u0026rdquo; \u0026ndash; that is, starting from the root, print the numbers level-by-level, alternating between left to right and right to left. For example, for the following tree you must output: 1 11 5 8 17 12 20 15.\u003c/p\u003e","title":"Zig Zagging on a Tree"},{"content":"6-1 Isomorphic Two trees, T1 and T2, are isomorphic if T1 can be transformed into T2 by swapping left and right children of (some of the) nodes in T1. For instance, the two trees in Figure 1 are isomorphic because they are the same if the children of A, B, and G, but not the other nodes, are swapped. Give a polynomial time algorithm to decide if two trees are isomorphic.\nFormat of functions: int Isomorphic( Tree T1, Tree T2 ); where Tree is defined as the following:\ntypedef struct TreeNode *Tree; struct TreeNode { ElementType Element; Tree Left; Tree Right; }; The function is supposed to return 1 if T1 and T2 are indeed isomorphic, or 0 if not.\nSample program of judge: #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef char ElementType; typedef struct TreeNode *Tree; struct TreeNode { ElementType Element; Tree Left; Tree Right; }; Tree BuildTree(); /* details omitted */ int Isomorphic( Tree T1, Tree T2 ); int main() { Tree T1, T2; T1 = BuildTree(); T2 = BuildTree(); printf(“%d\\n”, Isomorphic(T1, T2)); return 0; } /* Your function will be put here */ Sample Output 1 (for the trees shown in Figure 1): 1 Sample Output 2 (for the trees shown in Figure 2): 0 Note main part : check each node\u0026rsquo;s children situation\nCode #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef char ElementType; typedef struct TreeNode *Tree; struct TreeNode { ElementType Element; Tree Left; Tree Right; }; Tree BuildTree(); /* details omitted */ int Isomorphic( Tree T1, Tree T2 ); int checkValue(Tree n1, Tree n2){ if(n1!=NULL \u0026amp;\u0026amp; n2!=NULL \u0026amp;\u0026amp; n1-\u0026gt;Element==n2-\u0026gt;Element) return 1; if(n1==NULL \u0026amp;\u0026amp; n2==NULL) return 1; return 0; } int checkChild(Tree n1, Tree n2){ Tree n1_left = n1-\u0026gt;Left; Tree n1_right = n1-\u0026gt;Right; Tree n2_left = n2-\u0026gt;Left; Tree n2_right = n2-\u0026gt;Right; if(checkValue(n1_left, n2_left) \u0026amp;\u0026amp; checkValue(n1_right, n2_right)) return 1; // same if(checkValue(n1_left, n2_right) \u0026amp;\u0026amp; checkValue(n1_right, n2_left)) return 2; // same with swap return 0; // not same } int Isomorphic_help( Tree T1, Tree T2 ){ if(T1==NULL \u0026amp;\u0026amp; T2==NULL) return 1; int situation = checkChild(T1, T2); if(situation==1){ int r1 = Isomorphic_help(T1-\u0026gt;Left, T2-\u0026gt;Left); int r2 = Isomorphic_help(T1-\u0026gt;Right, T2-\u0026gt;Right); return r1*r2; } else if(situation==2){ int r1 = Isomorphic_help(T1-\u0026gt;Left, T2-\u0026gt;Right); int r2 = Isomorphic_help(T1-\u0026gt;Right, T2-\u0026gt;Left); return r1*r2; } else{ return 0; } } int Isomorphic( Tree T1, Tree T2 ){ int res = checkValue(T1, T2); if(res==0) return 0; return Isomorphic_help(T1, T2); } int main() { Tree T1, T2; /* T1 = BuildTree(); */ /* T2 = BuildTree(); */ printf(\u0026#34;%d\\n\u0026#34;, Isomorphic(T1, T2)); return 0; } /* Your function will be put here */ ","permalink":"https://novel2430.github.io/notes/isomorphic/","summary":"\u003ch1 id=\"6-1-isomorphic\"\u003e6-1 Isomorphic\u003c/h1\u003e\n\u003cp\u003eTwo trees, \u003ccode\u003eT1\u003c/code\u003e and \u003ccode\u003eT2\u003c/code\u003e, are isomorphic if \u003ccode\u003eT1\u003c/code\u003e can be transformed into \u003ccode\u003eT2\u003c/code\u003e by swapping left and right children of (some of the) nodes in \u003ccode\u003eT1\u003c/code\u003e. For instance, the two trees in Figure 1 are isomorphic because they are the same if the children of A, B, and G, but not the other nodes, are swapped. Give a polynomial time algorithm to decide if two trees are isomorphic.\u003c/p\u003e","title":"Isomorphic"},{"content":"7-1 Pop Sequence Given a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, \u0026hellip;, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.\nInput Specification: Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M (the maximum capacity of the stack), N (the length of push sequence), and K (the number of pop sequences to be checked). Then K lines follow, each contains a pop sequence of N numbers. All the numbers in a line are separated by a space.\nOutput Specification: For each pop sequence, print in one line YES if it is indeed a possible pop sequence of the stack, or NO if not.\nSample Input: 5 7 5 1 2 3 4 5 6 7 3 2 1 7 5 6 4 7 6 5 4 3 2 1 5 6 4 3 7 2 1 1 7 6 5 4 3 2 Sample Output: YES NO NO YES NO Code: #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // Basic Struct typedef struct stack_node{ int values; struct stack_node* next; struct stack_node* before; }stack_node; typedef struct my_stack { stack_node* head; stack_node* top; }my_stack ; // Node op stack_node* node_init(int num){ stack_node* node = (stack_node*)malloc(sizeof(stack_node)); node-\u0026gt;values = num; node-\u0026gt;next = NULL; node-\u0026gt;before = NULL; return node; } void node_delete(stack_node* node){ if(node==NULL) return; free(node); node = NULL; } // Stack op my_stack* stack_init(){ my_stack* res = (my_stack*)malloc(sizeof(my_stack)); res-\u0026gt;head = node_init(0); res-\u0026gt;top = res-\u0026gt;head; return res; } void stack_delete(my_stack* stack){ if(stack==NULL) return; stack_node* cur = stack-\u0026gt;head; while(cur != NULL){ stack_node* next_node = cur-\u0026gt;next; node_delete(cur); cur = next_node; } free(stack); stack = NULL; } void stack_push(my_stack* stack, int num){ stack-\u0026gt;head-\u0026gt;values++; stack_node* node = node_init(num); stack-\u0026gt;top-\u0026gt;next = node; node-\u0026gt;before = stack-\u0026gt;top; stack-\u0026gt;top = node; } int stack_pop(my_stack* stack){ stack-\u0026gt;head-\u0026gt;values--; int res = stack-\u0026gt;top-\u0026gt;values; stack_node* old_top = stack-\u0026gt;top; stack_node* new_top = stack-\u0026gt;top-\u0026gt;before; node_delete(old_top); stack-\u0026gt;top = new_top; stack-\u0026gt;top-\u0026gt;next = NULL; return res; } int stack_is_empty(my_stack* stack){ if(stack==NULL || stack-\u0026gt;head!=stack-\u0026gt;top){ return 0; } return 1; } int main(){ int max_length, max_num, seq_count; scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;max_length, \u0026amp;max_num, \u0026amp;seq_count); // build test int test[seq_count][max_num]; for(int i=0; i\u0026lt;seq_count; i++){ for(int j=0; j\u0026lt;max_num; j++){ int cur_num; scanf(\u0026#34;%d\u0026#34;, \u0026amp;cur_num); test[i][j] = cur_num; } } // do test for(int i=0; i\u0026lt;seq_count; i++){ my_stack* stack = stack_init(); int idx = 1; for(int j=0; j\u0026lt;max_num; j++){ int now_num = test[i][j]; for(;idx\u0026lt;=now_num \u0026amp;\u0026amp; stack-\u0026gt;head-\u0026gt;values\u0026lt;max_length; idx++){ stack_push(stack, idx); } if(stack-\u0026gt;top!=stack-\u0026gt;head \u0026amp;\u0026amp; stack-\u0026gt;top-\u0026gt;values==now_num){ stack_pop(stack); } else break; } if(i\u0026gt;0) printf(\u0026#34;\\n\u0026#34;); if(stack_is_empty(stack)) printf(\u0026#34;YES\u0026#34;); else printf(\u0026#34;NO\u0026#34;); stack_delete(stack); } } ","permalink":"https://novel2430.github.io/notes/pop-sequence/","summary":"\u003ch1 id=\"7-1-pop-sequence\"\u003e7-1 Pop Sequence\u003c/h1\u003e\n\u003cp\u003eGiven a stack which can keep \u003ccode\u003eM\u003c/code\u003e numbers at most. Push \u003ccode\u003eN\u003c/code\u003e numbers in the order of 1, 2, 3, \u0026hellip;, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if \u003ccode\u003eM\u003c/code\u003e is 5 and \u003ccode\u003eN\u003c/code\u003e is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.\u003c/p\u003e","title":"Pop Sequence"}]