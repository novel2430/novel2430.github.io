[{"content":"ZJU考研分享 Part1 - 来内地考研? 那首先，就是关于考研的选择。\n城市选择: 生活成本 第一个你可能会好奇的就是城市的选择，浙江大学在杭州，杭州不像上海是一个节奏快速，举世闻名的大城市，最直观的比如说物价可能就会低一点。那对于杭州，我会以在这个地方的生活成本，还有我所知道在杭州的实习机会来跟各位分享。\n先来分享一下在杭州的生活成本，比如说浙大的话，研究生收入主要来源有两个，第一便是学校会稳定支付你每个月1300人民币，入学的第一学期可能会欠你几个月，但很快就会补上。第二，就是你选择的实验室给你的劳务费。这个劳务费是会根据实验室的不同，有多有少，但保底就是500元一个月，如果你比较常帮忙老师，或接了一些项目，那就有机会更多。但我也听说过，有些实验室太小，老师让你作一堆事情，但直到毕业你都领500。\n再来就是支出，首先就是吃饭跟水电，这两个我觉得很看个人，但只讲三餐，一天100人民币我觉得不难解决问题，水电的话，如果你住在学校宿舍，那就真的是非常非常少的开销，但如果你选择住在校外，那就会根据你住的房形来决定。刚好讲到校外住宿，我自己目前就是住在学校外面，那在我亲身经历，还有身边其他租房的朋友所言，浙大的几个校区边上，房租的range其实蛮大的，800到3000多的都有，我自己是没太多要求，所以选择了1400的租房。\n城市选择: 实习机会 再来关于城市选择，你可以考虑到的就是读书期间实习的机会。因为我自己的专业，未来在互连网公司待的机会比较高，所以我这张简报上主要都是互连网企业。\n阿里系相关的产业可以说是杭州的代表，先不论他们企业文化如何，我相信大部分的人如果有机会能去阿里，铁定是比较开心的。再来就是华为，老实说我之前真的以为华为没放岗位在杭州，直到本科快毕业的时候接到一些华为hr的电话，才知道也是有再招人的，然后他们hr也真的是很辛苦。\n剩下还有一些比较知名的公司我也放在了图中，至少我在今天来之前打开boss直聘，他们都有在杭州招互连网岗位的实习。题外话，如果喜欢外商公司的话，我记得zoom好像也是在杭州。\n专业选择 那现在来聊聊专业选择吧！就像一开始说的，我就读的专业是叫做设计学，但其实我本科念的专业是纯计算机科学，虽然他们两个都是属于计算机科学学院底下，但还是不一样的。而我会有现在的转变，一部分是我自己在本科阶段算是意识到自己可能不太适合纯粹的CS，尤其是把CS拿来做科研的话，估计导师会想掐死我。\n另一部分，也是对你们比较重要的部分，就是浙大已经好几年不在计算机科学专业上招港澳台研究生了，但这个意思不是说你是港澳台，你就不准进去，只是说面向港澳台考研的这项特别通道，不能报考浙大的计算机专业。你真的想去，你一直都可以选择跟内地学生一起考研竞争，当然这个成本可能就要自己好好考量了。\n但不能选计算机，那为何要去设计学呢？我因为本科阶段在作毕业论文的时候，刚好有机会可以稍微认识了我校设计学专业目前常干的事情，他们基本上都是在做AIGC相关的领域，那至少这个趋势，是符合社会发展的。如果讲到兴趣，我是真心对人工智能相关的数学理论，算法，兴趣不是很大，把AI抓过来让他作点奇怪的事情我比较感兴趣。虽然这样说有点不准确，但相较于传统CS，设计学比较多的正是思考要如何结合AI技术，结合几个领域，看看可不可整出新点花样。\nPart2 - 择校经验 再来要说的就是学校的选择。\n报考人数 我也顺便分享一下报考状况。去年浙江大学港澳台硕士的总报考人数我这边没有资料，我只知道设计学专业的状况。那我们当初是参加复式的人数一共就三个，包括我两个是浙大本校生，另一个是澳门大学的朋友，经过大概半天的复式，最后总录取人数也是三个，老实说我有点怀疑会不会是人太少的关系。\n设计学? 那我们浙大的设计学都在干嘛呢？我这边列出了6个领域，但这只是一部分，我知道存在的范围而已。我自己目前做的是音乐生成相关的领域，但我们实验室体量比较大，所以比如说古籍修复，字体设计这些领域也有不少人在做。数据洞察这是我朋友他们实验室主要的方向，而舞蹈生成则是之前参会看到其他学校做的，他们的成果其实让我印象蛮深刻的。\n所以可以看到，设计学主要的领域范围是真的很大，像我自己虽然求学阶段一直都是理工科，但我对文艺领域的兴趣向来都是比理工科大的，所以可以说设计学给了我一次机会去将两者融合。\nCoding? 另外需要强调的是，虽然专业名称为设计学，但这个专业还是属于计算机学院底下，所以如果具备一定的 coding 能力，对于面试，还有未来做研究的时候都会有很大的帮助。其他学校我不知道，但浙大设计学，工业设计等专业目前大方向都得跟人工智能沾上边，所以比如说简单的python最好还是要会。\n另外比如说一些应用开发的能力，不管是网页端、安卓端、IOS端能稍微知道一点会蛮好的，有时候可能老师接了什么项目然后你刚好缺钱，那估计会用上。\nPart2 - 考试经验 初试 初试的话，主要就三个科目，中华文化，数学，英文，因为我报考的是设计学，所以那个数学他的正式称呼应该是逻辑推理，但我觉得叫脑筋急转弯的比较恰当。\n个人感想，我身边大部分觉得头痛的应该是中华文化，尤其理工科生更是如此。但我在考试前有拿着考纲跟内地的朋友讨论，他是说感觉范围就是他们的高中语文，然后加上历史课。我自己的感觉也差不多，真的要准备可以多看看抢救国文大作战，我不知道你们现在还有再用这玩意吗？\n再来就是英文，我觉得依照台生的英文水准应该是不用太担心，我自己觉得跟学测难度差不多，所以可能文法要回忆一下会比较好。阿如果担心词汇量，就去背大陆的考研单词吧！\n复试 那关于复试，浙大设计学是有两个阶段，第一个是设计学专业课的笔试，第二个就是面试。这两个都是同一天举行的。对于专业课笔试，我觉得像我一样夸专业考的人可以从中国大学幕课网上去学习，像浙大就有不少能参考的课程在上面。\n那对于复试，我记得老师们主要会想问你的问题，就是围绕着你为什么要来这个专业念硕士，还有你的毕业论文是在干嘛。所以针对面试，可以复习并简短一下自己的毕业答辩的内容就好。\n其他准备 那最后针对考研的其他准备，我觉得最重要的就是体现你对学术的热情。比如像我的话就是在最后一年找个实验室进去打工，看看能不能混个专利或挂名小文章，再不行也能混脸熟。\n那如果你没有这个时间的话，也可以先去了解一下自己感兴趣的导师，他有做什么方向，然后让gpt 帮你看看文章帮你总结。做这些的主要目的，就是让你在面试的展示阶段有话可说，并且也能尽量老师询问你你有准备的话题。\n","permalink":"https://novel2430.github.io/ideas/zju_postgraduate_entrance_exam/","summary":"\u003ch1 id=\"zju考研分享\"\u003eZJU考研分享\u003c/h1\u003e\n\u003ch2 id=\"part1---来内地考研\"\u003ePart1 - 来内地考研?\u003c/h2\u003e\n\u003cp\u003e那首先，就是关于考研的选择。\u003c/p\u003e\n\u003ch3 id=\"城市选择-生活成本\"\u003e城市选择: 生活成本\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"image\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/novel2430/MyImage/refs/heads/main/ZJU_postgraduate_exam_04.png\"\u003e\n第一个你可能会好奇的就是城市的选择，浙江大学在杭州，杭州不像上海是一个节奏快速，举世闻名的大城市，最直观的比如说物价可能就会低一点。那对于杭州，我会以在这个地方的生活成本，还有我所知道在杭州的实习机会来跟各位分享。\u003c/p\u003e","title":"ZJU postgraduate entrance examination sharing"},{"content":"Some simple Wayfire custom keybind ScreenShot You can use grim and slurp to have screenshot function\ngrim\nscreenshot slurp\nselect a region Install grim and slurp\nyay -S grim slurp For example shell script\n# ~/.config/wayfire/scripts/screenshot.sh path=\u0026#34;/home/novel2430/Pictures/screenshot/\u0026#34; # \u0026lt;--- Where you want to save your screenshots now_date=$(date \u0026#39;+%Y%m%d-%H%M%S\u0026#39;) file_name=\u0026#34;${path}${now_date}.png\u0026#34; msg=\u0026#34;save as ${file_name}\u0026#34; case $1 in full) grim ${file_name} \u0026amp;\u0026amp; dunstify -a \u0026#34;Screenshot\u0026#34; \u0026#34;Full\u0026#34; \u0026#34;${msg}\u0026#34; -r 2003 ;; select) grim -g \u0026#34;$(slurp)\u0026#34; ${file_name} \u0026amp;\u0026amp; dunstify -a \u0026#34;Screenshot\u0026#34; \u0026#34;Select\u0026#34; \u0026#34;${msg}\u0026#34; -r 2003 ;; esac Clipboard Manager We need two packages: cliphist and wl-clipboard\ncliphist\nFor clipboard managing wl-clipboard\nFor copy and paste Install both\nyay -S cliphist wl-clipboard # ~/.config/wayfire/scripts/clipboard.sh cliphist list | wofi show --dmenu | cliphist decode | wl-copy Volume Control We used Pipewire and Wireplumber to control our audio, so we can use wpctl to control the volume\nIncrease volume wpctl set-volume -l 1.5 @DEFAULT_AUDIO_SINK@ 5%+ Decrease volume wpctl set-volume @DEFAULT_AUDIO_SINK@ 5%- Mute wpctl set-mute @DEFAULT_AUDIO_SINK@ toggle Commands above can use with \u0026lsquo;dunst\u0026rsquo;, so we can write a simple script\n# ~/.config/wayfire/scripts/volume.sh # \u0026lt;this_file\u0026gt; up ----\u0026gt; Increase Volume # \u0026lt;this_file\u0026gt; down ----\u0026gt; Decrease Volume # \u0026lt;this_file\u0026gt; mute ----\u0026gt; Toggle Mute sending () { volume=$(wpctl get-volume @DEFAULT_AUDIO_SINK@ | awk \u0026#39;{print $2}\u0026#39;) volume_scale=$(awk \u0026#39;{print $1*$2}\u0026#39; \u0026lt;\u0026lt;\u0026lt;\u0026#34;${volume} 100\u0026#34;) dunstify -a \u0026#34;ChangeVolume\u0026#34; -r 9993 -h int:value:\u0026#34;$volume_scale\u0026#34; -i \u0026#34;Vol $1\u0026#34; \u0026#34;Level : ${volume_scale}%\u0026#34; -t 2000 } case $1 in up) wpctl set-volume -l 1.5 @DEFAULT_AUDIO_SINK@ 5%+ \u0026amp;\u0026amp; sending $1 ;; down) wpctl set-volume @DEFAULT_AUDIO_SINK@ 5%- \u0026amp;\u0026amp; sending $1 ;; mute) wpctl set-mute @DEFAULT_AUDIO_SINK@ toggle if [[ \u0026#34;$(wpctl get-volume @DEFAULT_AUDIO_SINK@ | awk \u0026#39;{print $3}\u0026#39;)\u0026#34; = \u0026#34;[MUTED]\u0026#34; ]]; then dunstify -a \u0026#34;ChangeVolume\u0026#34; -i \u0026#34;Muted\u0026#34; \u0026#34;MUTE\u0026#34; -t 2000 -r 9993 else sending up fi ;; esac Brightness Control I prefer \u0026lsquo;brillo\u0026rsquo;\nInstall brillo\nyay -S brillo # ~/.config/wayfire/bright.sh function send() { bright=$(printf \u0026#34;%.0f\\n\u0026#34; $(brillo -G)) dunstify -a \u0026#34;ChangeBrightness\u0026#34; -r 9993 -h int:value:\u0026#34;$bright\u0026#34; -i \u0026#34;Brightness $1\u0026#34; \u0026#34;Level : ${bright}%\u0026#34; -t 2000 } case $1 in up) sudo brillo -u 150000 -q -A 3 send $1 ;; down) sudo brillo -u 150000 -q -U 3 send $1 ;; esac Screen Lock I prefer \u0026lsquo;swaylock-effetcs\u0026rsquo;\nyay -S swaylock-effetcs # ~/.config/wayfire/scripts/swaylock.sh swaylock \\ --screenshots \\ --clock \\ --indicator \\ --indicator-radius 100 \\ --indicator-thickness 7 \\ --effect-blur 7x5 \\ --effect-vignette 0.5:0.5 \\ --ring-color bb00cc \\ --key-hl-color 880033 \\ --line-color 00000000 \\ --inside-color 00000088 \\ --separator-color 00000000 \\ --grace 2 \\ --fade-in 0.2 ","permalink":"https://novel2430.github.io/notes/simple-wayfire-keybind/","summary":"\u003ch1 id=\"some-simple-wayfire-custom-keybind\"\u003eSome simple Wayfire custom keybind\u003c/h1\u003e\n\u003ch2 id=\"screenshot\"\u003eScreenShot\u003c/h2\u003e\n\u003cp\u003eYou can use \u003ccode\u003egrim\u003c/code\u003e and \u003ccode\u003eslurp\u003c/code\u003e to have screenshot function\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003egrim\u003cbr\u003e\nscreenshot\u003c/li\u003e\n\u003cli\u003eslurp\u003cbr\u003e\nselect a region\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eInstall grim and slurp\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eyay -S grim slurp\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eFor example shell script\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# ~/.config/wayfire/scripts/screenshot.sh\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epath\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;/home/novel2430/Pictures/screenshot/\u0026#34;\u003c/span\u003e   \u003cspan style=\"color:#75715e\"\u003e# \u0026lt;--- Where you want to save your screenshots\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enow_date\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003edate \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;+%Y%m%d-%H%M%S\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efile_name\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e${\u003c/span\u003epath\u003cspan style=\"color:#e6db74\"\u003e}${\u003c/span\u003enow_date\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e.png\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emsg\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;save as \u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e${\u003c/span\u003efile_name\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e $1 in\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  full\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    grim \u003cspan style=\"color:#e6db74\"\u003e${\u003c/span\u003efile_name\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e dunstify -a \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Screenshot\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Full\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e${\u003c/span\u003emsg\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e -r \u003cspan style=\"color:#ae81ff\"\u003e2003\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ;;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eselect\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    grim -g \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003eslurp\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e${\u003c/span\u003efile_name\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e dunstify -a \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Screenshot\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Select\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e${\u003c/span\u003emsg\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e -r \u003cspan style=\"color:#ae81ff\"\u003e2003\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ;;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eesac\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"clipboard-manager\"\u003eClipboard Manager\u003c/h2\u003e\n\u003cp\u003eWe need two packages: \u003ccode\u003ecliphist\u003c/code\u003e and \u003ccode\u003ewl-clipboard\u003c/code\u003e\u003c/p\u003e","title":"Simple Wayfire Keybind"},{"content":"Alpine Linux with Sway Bash, Text Editor Packages apk add vim bash Create Non Root User Packages apk add sudo shadow Command Add User useradd -m -G wheel -s /bin/bash \u0026lt;user_name\u0026gt; passwd \u0026lt;user_name\u0026gt; sudo file EDITOR=vim visudo # Make wheel group can use sudo Setup eudev setup-devd udev GPU Intel apk add mesa-dri-gallium AMD\nRead here Nvidia\nRead here PAM apk add linux-pam shadow-login Elogind apk add elogind polkit-elogind dbus rc-update add elogind rc-update add polkit rc-update add dbus Sway apk add sway Reboot After rebooting your computer, you should use your non-root userer to log in\nRun Sway You can test loginctl output first, the output should not contains any No session\nAfter testing, you can run Sway\ndbus-run-session -- sway ","permalink":"https://novel2430.github.io/notes/alpine-to-sway/","summary":"\u003ch1 id=\"alpine-linux-with-sway\"\u003eAlpine Linux with Sway\u003c/h1\u003e\n\u003ch2 id=\"bash-text-editor\"\u003eBash, Text Editor\u003c/h2\u003e\n\u003ch3 id=\"packages\"\u003ePackages\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapk add vim bash\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"create-non-root-user\"\u003eCreate Non Root User\u003c/h2\u003e\n\u003ch3 id=\"packages-1\"\u003ePackages\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapk add sudo shadow\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"command\"\u003eCommand\u003c/h3\u003e\n\u003ch4 id=\"add-user\"\u003eAdd User\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003euseradd -m -G wheel -s /bin/bash \u0026lt;user_name\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epasswd \u0026lt;user_name\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"sudo-file\"\u003esudo file\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eEDITOR\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003evim visudo\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Make wheel group can use sudo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"setup-eudev\"\u003eSetup eudev\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esetup-devd udev\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"gpu\"\u003eGPU\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eIntel\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapk add mesa-dri-gallium\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eAMD\u003cbr\u003e\nRead \u003ca href=\"https://wiki.alpinelinux.org/wiki/Radeon_Video\"\u003ehere\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eNvidia\u003cbr\u003e\nRead \u003ca href=\"https://wiki.alpinelinux.org/wiki/NVIDIA\"\u003ehere\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"pam\"\u003ePAM\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapk add linux-pam shadow-login\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"elogind\"\u003eElogind\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapk add elogind polkit-elogind dbus\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003erc-update add elogind\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003erc-update add polkit\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003erc-update add dbus\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"sway\"\u003eSway\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapk add sway\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"reboot\"\u003eReboot\u003c/h2\u003e\n\u003cp\u003eAfter rebooting your computer, you should use your non-root userer to log in\u003c/p\u003e","title":"Alpine to Sway"},{"content":"Alpine Linux(UEFI) Semi-Automatic Installation Enter Installation Your login username is root, password is empty\nCheck UEFI test -d /sys/firmware/efi \u0026amp;\u0026amp; echo UEFI || echo BIOS Keyboard Layout Answer some questions\nsetup-keymap ## answer \u0026#39;us\u0026#39; twice Hostname setup-hostname \u0026lt;your_hostname\u0026gt; Networking Alpine Linux\u0026rsquo;s wiki recommend you using ethernet to connect internet\nBut you can also use setup-interfaces to use wireless connection Answer some questions\nsetup-interfaces After the configuration\nrc-service networking start rc-update add networking boot Apk Repositories You can find all repositories mirrors in here\nEdit /etc/apk/repositories\nvi /etc/apk/repositories For Chinese user, you can use example below\n# /etc/apk/repositories ... https://mirrors.aliyun.com/alpine/latest-stable/main https://mirrors.aliyun.com/alpine/latest-stable/community Finally, update your repositories\napk update Timezone We need to install tzdata\napk add tzdata Set your region info\ninstall -Dm 0644 /usr/share/zoneinfo/\u0026lt;Region\u0026gt;/\u0026lt;Country\u0026gt; /etc/zoneinfo/\u0026lt;Region\u0026gt;/\u0026lt;Country\u0026gt; export TZ=\u0026#39;\u0026lt;Region\u0026gt;/\u0026lt;Country\u0026gt;\u0026#39; echo \u0026#34;export TZ=\u0026#39;$TZ\u0026#39;\u0026#34; \u0026gt;\u0026gt; /etc/profile.d/timezone.sh For Chinese user\ninstall -Dm 0644 /usr/share/zoneinfo/Asia/Shanghai /etc/zoneinfo/Asia/Shanghai export TZ=\u0026#39;Asia/Shanghai\u0026#39; echo \u0026#34;export TZ=\u0026#39;$TZ\u0026#39;\u0026#34; \u0026gt;\u0026gt; /etc/profile.d/timezone.sh Root password passwd SSH Answer some questions\nsetup-sshd NTP Answer some questions\nsetup-ntp Disk Useful Tools Install some useful packages\napk add cfdisk dosfstools e2fsprogs e2fsprogs-extra Partition (Optional)\nIf you wish your Alpine Linux live with other Linux distributions, you can share your existing boot and swap partitions to Alpine Linux\nList All Disks and Partitions fdisk -l Change Partition Table You can use cfdisk to do this step.\ncfdisk /dev/\u0026lt;your_disk\u0026gt; Partition Table Example\nmount point partition type recommend size /mnt/boot /dev/efi_boot_partition EFI \u0026gt;=300M [SWAP] /dev/swap_partition Linux Swap \u0026gt;=512M /mnt /dev/root_partition Linux Filesystem space left Partition Table Example (With Home Partition)\nmount point partition type recommend size /mnt/boot /dev/efi_boot_partition EFI \u0026gt;=300M [SWAP] /dev/swap_partition Linux Swap \u0026gt;=512M /mnt /dev/root_partition Linux Filesystem space left /mnt/home /dev/home_partition Linux Filesystem space left Format For Boot Partition mkfs.fat -F 32 -n ALPINEBOOT /dev/efi_boot_partition For Swap Partition mkswap /dev/swap_partition For Root Partition mkfs.ext4 -L ALPINEROOT /dev/root_partition For Home Partition (If you have) mkfs.ext4 -L ALPINEHOME /dev/home_partition Mount Mount Root Partition mount /dev/root_partition /mnt Mount Boot Partition mkdir /mnt/boot mount /dev/boot_partition /mnt/boot Mount Swap Partition swapon /dev/swap_partition Mount Home Partition (If you have) mkdir /mnt/home mount /dev/home_partition /mnt/home Install Basic Package I only want Alpine Linux! setup-disk -m sys /mnt You can reboot your system now\nI already have other Linux distribution, and they share same grub partition Setting BOOTLOADER=none in order to make the script avoiding grub installation\nBOOTLOADER=none setup-disk -m sys /mnt Then, you can create a menuentry in /mnt/boot/grub/custom.cfg\nYou can use blkid to find your root partition UUID\n# /mnt/boot/grub/custom.cfg menuentry \u0026#34;Alpine Linux\u0026#34; { ## \u0026lt;-- You can change the name search --no-floppy --fs-uuid --set=root 88D1-11D6 # You must chage Boot Partition UUID above linux /vmlinuz-lts root=UUID=8de6973a-4a8c-40ed-b710-c4e2b42d6b7a modules=sd-mod,usb-storage,ext4 quiet # You must chage Root Partition UUID above initrd /initramfs-lts } ","permalink":"https://novel2430.github.io/notes/basic-alpinelinux-install/","summary":"\u003ch1 id=\"alpine-linuxuefi-semi-automatic-installation\"\u003eAlpine Linux(UEFI) Semi-Automatic Installation\u003c/h1\u003e\n\u003ch2 id=\"enter-installation\"\u003eEnter Installation\u003c/h2\u003e\n\u003cp\u003eYour login username is \u003ccode\u003eroot\u003c/code\u003e, password is empty\u003c/p\u003e\n\u003ch2 id=\"check-uefi\"\u003eCheck UEFI\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etest -d /sys/firmware/efi \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e echo UEFI \u003cspan style=\"color:#f92672\"\u003e||\u003c/span\u003e echo BIOS\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"keyboard-layout\"\u003eKeyboard Layout\u003c/h2\u003e\n\u003cp\u003eAnswer some questions\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esetup-keymap\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e## answer \u0026#39;us\u0026#39; twice\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"hostname\"\u003eHostname\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esetup-hostname \u0026lt;your_hostname\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"networking\"\u003eNetworking\u003c/h2\u003e\n\u003cp\u003eAlpine Linux\u0026rsquo;s wiki recommend you using ethernet to connect internet\u003cbr\u003e\nBut you can also use \u003ccode\u003esetup-interfaces\u003c/code\u003e to use wireless connection\nAnswer some questions\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esetup-interfaces\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eAfter the configuration\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003erc-service networking start\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003erc-update add networking boot\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"apk-repositories\"\u003eApk Repositories\u003c/h2\u003e\n\u003cp\u003eYou can find all repositories mirrors in \u003ca href=\"https://mirrors.alpinelinux.org/\"\u003ehere\u003c/a\u003e\u003cbr\u003e\nEdit \u003ccode\u003e/etc/apk/repositories\u003c/code\u003e\u003c/p\u003e","title":"Basic AlpineLinux (UEFI) Install"},{"content":"Applications on Wayfire Setup Wayfire Basic Environment [ App Menu ] (wofi) yay -S wofi # ~/.config/wayfire.ini ... # Start your launcher # https://hg.sr.ht/~scoopta/wofi # Note: Add mode=run or mode=drun to ~/.config/wofi/config. # You can also specify the mode with --show option. binding_launcher = \u0026lt;super\u0026gt; KEY_D # \u0026lt;-- Change key binding command_launcher = wofi --show drun # \u0026lt;-- Change exec command ... [ Web Browser ] (firefox) yay -S firefox Now you can use Wofi to open Firefox\n[ Notification ] (dunst) yay -S dunst libnotify Dunst\u0026rsquo;s config file =\u0026gt; ~/.config/dunst/dunstrc\nmkdir ~/.config/dunst cp /etc/dunst/dunstrc ~/.config/dunst/dunstrc Change notification app to dunst\n# ~/.config/wayfire.ini ... # Notifications # https://wayland.emersion.fr/mako/ notifications = mako # \u0026lt;-- change to dunst ... After restarting Wayfire, you can try sending notification\ndunstify \u0026#34;hello!\u0026#34; [ Autostart Script ] You can store your script anywhere, but I prefer store it in ~/.config/wayfire/autostart.sh\nmkdir ~/.config/wayfire touch ~/.config/wayfire/autostart.sh chmod +x ~/.config/wayfire/autostart.sh You need to specify script in ~/.config/wayfire.ini\n# ~/.config/wayfire.ini ... # Startup commands ───────────────────────────────────────────────────────────── [autostart] # Automatically start background and panel. # Set to false if you want to override the default clients. autostart_wf_shell = true # \u0026lt;-- You can set false my_autostart = ~/.config/wayfire/autostart.sh # \u0026lt;-- Add this line ... [ Wallpaper ] (swaybg) yay -S swaybg Our wallpaper should execute during Wayfire starting process, so we need to execute swaybg command in our autostart script.\n# ~/.config/wayfire/autostart.sh ### Wallpaper swaybg -i \u0026lt;your_wallpaper\u0026gt; \u0026amp; [ XDG-DESKTOP-PORTAL and Audio] yay -S xdg-desktop-portal xdg-desktop-portal-wlr xdg-desktop-portal-gtk The main reason setting up xdg-desktop-portal is to using desktop recorder such as Obs Studio\nSo, we need to start xdg-desktop-portal service and audio service in autostart script.\n# ~/.config/wayfire/autostart.sh ... ### XDG-DESKTOP-PORTAL dbus-update-activation-environment --systemd WAYLAND_DISPLAY XDG_CURRENT_DESKTOP=sway systemctl --user stop pipewire pipewire-pulse wireplumber xdg-desktop-portal xdg-desktop-portal-wlr xdg-desktop-portal-gtk systemctl --user start pipewire pipewire-pulse wireplumber xdg-desktop-portal xdg-desktop-portal-wlr xdg-desktop-portal-gtk For xdg-desktop-portal service, you can install obs-studio and try desktop recording\nFor audio service, you can run wpctl status and check the ouput.\n# Ouput of \u0026#39;wpctl status\u0026#39; ... Audio |- Devices: | ... |- Sinks: | * \u0026lt;something_here\u0026gt; ... [vol: 1.00] ... [ Bar ] (waybar) yay -S waybar You may need some special fonts to show icon.\n# Nerd Fonts - Ubuntu yay -S ttf-ubuntu-nerd You can copy two default config files in any place you want\ncp /etc/xdg/waybar/config.jsonc ~/.config/wayfire/waybar-config.jsonc cp /etc/xdg/waybar/style.css ~/.config/wayfire/waybar-style.css Put waybar command in autostart script\n# ~/.config/wayfire/autostart.sh ... ### Waybar waybar -c \u0026lt;your_waybar_config\u0026gt; -s \u0026lt;your_waybar_style\u0026gt; \u0026amp; [ Network Applet ] (network-manager-applet) network-manager-applet is a small tool to configure your network connection in GUI\nyay -S network-manager-applet Add command in your autostart script\n# ~/.config/wayfire/autostart.sh ... ### NetworkManager Applet nm-applet \u0026amp; [ Audio Control ] (pavucontrol) pavucontrol is a small tool to configure your audio optput device in GUI\nyay -S pavucontrol [ Bluetooth ] (bluez bluez-obex blueman) yay -S bluez bluez-obex blueman Enable bluez service\nsystemctl enable bluetooth.service systemctl start bluetooth.service Edit your autostart script\n# ~/.config/wayfire/autostart.sh ... ### Bluetooth systemctl --user restart dbus-org.bluez.obex.service systemctl --user restart blueman-applet.service Edit your Dunst\u0026rsquo;s config file (For bluetooth message actions)\n# ~/.config/dunst/dunstrc ... ### Misc/Advanced ### # dmenu path. dmenu = /usr/bin/wofi -dmenu # \u0026lt;-- Change here to wofi ... By default, mouse middle click event triggers notify action\n# ~/.config/dunst/dunstrc ... ### mouse # Defines list of actions for each mouse event # Possible values are: # * none: Don\u0026#39;t do anything. # * do_action: Invoke the action determined by the action_name rule. If there is no # such action, open the context menu. # * open_url: If the notification has exactly one url, open it. If there are multiple # ones, open the context menu. # * close_current: Close current notification. # * close_all: Close all notifications. # * context: Open context menu for the notification. # * context_all: Open context menu for all notifications. # These values can be strung together for each mouse event, and # will be executed in sequence. mouse_left_click = close_current mouse_middle_click = do_action, close_current # \u0026lt;-- Here mouse_right_click = close_all ... (For Chinese User) [ Fcitx5 ] You may want read wiki link\n# For Pinyin yay -S fcitx5 fcitx5-qt fcitx5-gtk fcitx5-chinese-addons fcitx5-configtool # For Chewing yay -S fcitx5 fcitx5-qt fcitx5-gtk fcitx5-chinese-addons fcitx5-configtool fcitx5-chewing You can edit your ~/.bashrc (For Bash User) or ~/.zshrc (For Zsh User) to add fcitx5 environment variables\n# ~/.bashrc ... export GTK_IM_MODULE=\u0026#34;fcitx\u0026#34; export QT_IM_MODULE=\u0026#34;fcitx\u0026#34; export XMODIFIERS=\u0026#34;@im=fcitx\u0026#34; export SDL_IM_MODULE=\u0026#34;fcitx\u0026#34; export INPUT_METHOD=\u0026#34;fcitx\u0026#34; Do not forget source ~/.bashrc or source ~/.zshrc\nEdit your wayfire config to enable input method plugin\n# ~/.config/wayfire.ini ... # List of plugins to be enabled. # See the Configuration document for a complete list. plugins = \\ alpha \\ animate \\ autostart \\ command \\ cube \\ decoration \\ expo \\ fast-switcher \\ fisheye \\ foreign-toplevel \\ grid \\ gtk-shell \\ idle \\ invert \\ move \\ oswitch \\ place \\ resize \\ switcher \\ vswitch \\ wayfire-shell \\ window-rules \\ wm-actions \\ wobbly \\ wrot \\ zoom \\ input-method-v1 # \u0026lt;-- add this line Finally, add Fcitx5 in your autostart script\n# ~/.config/wayfire/autostart.sh ... ### Fcitx5 fcitx5 --replace -d \u0026amp; ","permalink":"https://novel2430.github.io/notes/basic-wayfire-applications/","summary":"\u003ch1 id=\"applications-on-wayfire\"\u003eApplications on Wayfire\u003c/h1\u003e\n\u003ch2 id=\"setup-wayfire-basic-environment\"\u003eSetup Wayfire Basic Environment\u003c/h2\u003e\n\u003ch3 id=\"-app-menu--wofi\"\u003e[ App Menu ] (wofi)\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eyay -S wofi\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# ~/.config/wayfire.ini\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ...\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Start your launcher\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# https://hg.sr.ht/~scoopta/wofi\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Note: Add mode=run or mode=drun to ~/.config/wofi/config.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# You can also specify the mode with --show option.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ebinding_launcher \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u0026lt;super\u0026gt; KEY_D \u003cspan style=\"color:#75715e\"\u003e# \u0026lt;-- Change key binding\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecommand_launcher \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e wofi --show drun \u003cspan style=\"color:#75715e\"\u003e# \u0026lt;-- Change exec command\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ...\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"-web-browser--firefox\"\u003e[ Web Browser ] (firefox)\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eyay -S firefox\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow you can use \u003ccode\u003eWofi\u003c/code\u003e to open \u003ccode\u003eFirefox\u003c/code\u003e\u003c/p\u003e","title":"Basic Wayfire Applications"},{"content":"Basic ArchLinux(UEFI) + WayFire Install Basic Arch Install [ Check UEFI or BIOS ] ls /sys/firmware/efi/efivars If the directory not exist, you are not in UEFI mode.\n[ Internet ] Check system activate internet interface ip link For Ethernet (DHCP) Good to go!\nFor WiFi (iwd) enter interactive prompt\niwctl list all wifi device\n[iwd] device list select the device you want to use, i.e: wlan0\nand start scanning\n[iwd] station \u0026lt;device\u0026gt; scan after scanning, you can list all available networks\n[iwd] station \u0026lt;device\u0026gt; get-networks connect one network\n[iwd] station \u0026lt;device\u0026gt; connect \u0026lt;network-name\u0026gt; leave iwclt\n[iwd] exit Ping test ping archlinux.org [ Update System Time ] timedatectl set-ntp true [ Partition ] List All Disks and Partitions fdisk -l Change Partition Table You can use cfdisk to do this step.\ncfdisk /dev/\u0026lt;your_disk\u0026gt; Partition Table Example\nmount point partition type recommend size /mnt/boot /dev/efi_boot_partition EFI \u0026gt;=300M [SWAP] /dev/swap_partition Linux Swap \u0026gt;=512M /mnt /dev/root_partition Linux Filesystem space left Partition Table Example (With Home Partition)\nmount point partition type recommend size /mnt/boot /dev/efi_boot_partition EFI \u0026gt;=300M [SWAP] /dev/swap_partition Linux Swap \u0026gt;=512M /mnt /dev/root_partition Linux Filesystem space left /mnt/home /dev/home_partition Linux Filesystem space left Format Partitions For Boot Partition mkfs.fat -F 32 -n ARCHBOOT /dev/efi_boot_partition For Swap Partition mkswap /dev/swap_partition For Root Partition mkfs.ext4 -L ARCHROOT /dev/root_partition For Home Partition (If you have) mkfs.ext4 -L ARCHHOME /dev/home_partition Mount Partitions Mount Root Partition mount /dev/disk/by-label/ARCHROOT /mnt Mount Boot Partition mkdir /mnt/boot mount /dev/disk/by-label/ARCHBOOT /mnt/boot Mount Swap Partition swapon /dev/swap_partition Mount Home Partition (If you have) mkdir /mnt/home mount /dev/disk/by-label/ARCHHOME /mnt/home [ Install Basic Package ] (Optional) Setup Mirrorlist edit /etc/pacman.d/mirrorlist file\nExample For Chinese User:\n# /etc/pacman.d/mirrorlist Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch Install Packages pacstrap /mnt base linux linux-firmware networkmanager vim man-db man-pages texinfo base, linux, linux-firmware\nmust install\nnetworkmanager\nfor internet\nvim\ntext editor, or you can choose nano\nman-db, man-pages, texinfo\nFor man page\n[ Generate Fstab ] genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab [ Chroot to System ] arch-chroot /mnt [ Timezone ] ln -sf /usr/share/zoneinfo/\u0026lt;Your_Region\u0026gt;/\u0026lt;Your_City\u0026gt; /etc/localtime Example For Chinese User:\nln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime run hwclock to generate /etc/adjtime\nhwclock --systohc [ Locale ] edit the file /etc/locale.gen, uncomment en_US.UTF-8 UTF-8 run locale-gen to generate locale info locale-gen build /etc/locale.conf file, set the variable LANG # /etc/locale.conf LANG=en_US.UTF-8 [ Host Name ] build /etc/hostname file\n# /etc/hostname \u0026lt;your_host_name\u0026gt; [ Set Root User Password ] passwd [ Enable NetworkManager Service ] systemctl enable NetworkManager.service We are now in chroot, so we do not need to start NetworkManager service. After bootloader installed and reboot to system, the NetworkManager will start automatically.\n[ Install Microcode ] For AMD User pacman -S amd-ucode For Intel User pacman -S intel-ucode [ Install Grub ] pacman -S grub efibootmgr (Optional) os-prober \u0026ndash; For Dual Boot pacman -S os-prober If you want dual boot with Windows OS, you may need ntfs-3g\npacman -S ntfs-3g [ Messing with GRUB :( ] I only need LINUX! (No Dual Boot) install grub on your boot partition # command below is for x86_64 user # you can find more info in https://wiki.archlinux.org/title/GRUB grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB generate /boot/grub/grub.cfg grub-mkconfig -o /boot/grub/grub.cfg I cannot leave windows\u0026hellip; (Dual Boot) NOTE: Setup Dual Booting always has many problems, the following guidance is only for reference.\ninstall grub on your boot partition # command below is for x86_64 user # you can find more info in https://wiki.archlinux.org/title/GRUB grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB edit /etc/default/grub # /etc/default/grub ... # Probing for other operating systems is disabled for security reasons. Read # documentation on GRUB_DISABLE_OS_PROBER, if still want to enable this # functionality install os-prober and uncomment to detect and include other # operating systems. GRUB_DISABLE_OS_PROBER=false # \u0026lt;-- Uncomment this Line generate /boot/grub/grub.cfg grub-mkconfig -o /boot/grub/grub.cfg # You must make sure os-prober find your windowsOS boot partition [ Reboot ] leave chroot exit umount /mnt umount -R /mnt swapoff swapoff /dev/swap_partition shutdown shutdown now reboot your computer\n(Make sure you unplugged your Arch Linux Installer USB drive)\nIf everything go well, you will see GRUB menu after booting. Setup Basic Destop Environment [ Root Login ] We only have user root right now, use root account to log in\n[ Check Internet ] Normally, NetworkManager.service will start automatically, you can use ping to check your internet connection\n# ping example ping archlinux.org You can use nmtui to configure your connection\n[ Neofetch ] \u0026lt;\u0026ndash; VERY IMPORTANT!!! pacman -S neofetch neofetch If you don\u0026rsquo;t hava neofetch, you are not using Arch :)\n[ GPU Card ] If you are not using NVIDIA card, GOOOOOOD!!\nI\u0026rsquo;m not familiar with AMD gpu\u0026hellip;Please read wiki!\nonly Nvidia pacman -S mesa-utils nvidia nvidia-utils (Optional) You may need nvtop to be coooool(?)\npacman -S nvtop After the installation, you need to reboot you computer\nonly AMD Please read the wiki (AMD GPU) first :)\nlink\npacman -S mesa mesa-utils For Vulkan support\npacman -S vulkan-radeon Intel+NVIDIA Please read the wiki (INTEL GPU) first :)\nlink\nFor our Intel card (with Vulkan)\npacman -S mesa mesa-utils vulkan-intel For our Nvidia card :(\npacman -S mesa-utils nvidia nvidia-utils nvidia-prime (Optional) You may need nvtop to be coooool(?)\npacman -S nvtop You can use prime-run \u0026lt;command\u0026gt; to run stuff on Nvidia card\nAfter the installation, you need to reboot you computer\n[ Audio ] Install Some Basic Packages pacman -S alsa-utils alsa-firmware sof-firmware alsa-ucm-conf Pipewire and Wireplumber pacman -S pipewire wireplumber pipewire-pulse [ Sudo ] Install Sudo pacman -S sudo Create one normal user useradd -m -G wheel -s /bin/bash \u0026lt;new_user_name\u0026gt; set this user\u0026rsquo;s password\npasswd \u0026lt;new_user_name\u0026gt; Edit sudo file edit file\nEDITOR=vim visudo uncomment one line in sudo file\n# In visudo ... ### ### User privilege specification ### root ALL=(ALL:ALL) ALL ## Uncomment to allow members of group wheel to execute any command %wheel ALL=(ALL:ALL) ALL # \u0026lt;-- uncomment this line ... Log out user root After installed Sudo, now we can use new user account to do stuff\nexit (For Chinese User) [ Clash ] We need a good way to Love GFW \u0026hellip;\nsudo pacman -S curl clash You can use curl to get your config.yaml\ncd \u0026lt;your_clash_directory\u0026gt; curl https://gitee.com/mirrors/Pingtunnel/raw/master/GeoLite2-Country.mmdb \u0026gt; ./Country.mmdb curl \u0026lt;your_sub_url\u0026gt; \u0026gt; ./config.yaml Edit clash systemd unit\nsudo vim /etc/systemd/user/clash.service # /etc/systemd/user/clash.service [Unit] Description=Clash, Good Way to Love GFW After=network.target [Service] Type=simple Restart=on-abort ExecStart=/usr/bin/clash -d \u0026lt;your_clash_directory\u0026gt; [Install] WantedBy=multi-user.target Reload Daemon\nsystemctl --user daemon-reload Start Clash Service\nsystemctl --user start clash.service Check Clash Service\nsystemctl --user status clash.service Set Clash as your current system porxy\nexport http_proxy=http://127.0.0.1:7890 export https_proxy=http://127.0.0.1:7890 [ YAY (AUR Helper) ] link\nsudo pacman -S --needed git base-devel git clone https://aur.archlinux.org/yay.git cd yay makepkg -si After installed yay, we can use yay -S 'package' instead of sudo pacman -S 'package'\n(For Chinese User) [ Chinese Fonts ] yay -S wqy-zenhei [ Wayfire ] install wayland packages yay -S wayland wayland-protocals xorg-xwayland install wayfire yay -S wayfire install basic font (For terminal emulator) yay -S ttf-dejavu install terminal emulator There are many terminal emulators on arch, such as Alacritty, Kitty, Foot \u0026hellip;\n# I prefer foot yay -S foot download default config file curl https://raw.githubusercontent.com/WayfireWM/wayfire/master/wayfire.ini \u0026gt; ~/.config/wayfire.ini set default terminal emulator edit ~/.config/wayfire.ini\n# ~/.config/wayfire.ini ... # Applications ───────────────────────────────────────────────────────────────── [command] # Start a terminal # https://github.com/alacritty/alacritty binding_terminal = \u0026lt;super\u0026gt; KEY_ENTER command_terminal = alacritty # \u0026lt;-- Change Here ... Run Wayfire wayfire If you use QEMU to run wayfire\nWLR_RENDERER_ALLOW_SOFTWARE=1 wayfire ","permalink":"https://novel2430.github.io/notes/basic-archlinux-wayfire-install/","summary":"\u003ch1 id=\"basic-archlinuxuefi--wayfire-install\"\u003eBasic ArchLinux(UEFI) + WayFire Install\u003c/h1\u003e\n\u003ch2 id=\"basic-arch-install\"\u003eBasic Arch Install\u003c/h2\u003e\n\u003ch3 id=\"-check-uefi-or-bios-\"\u003e[ Check UEFI or BIOS ]\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003els /sys/firmware/efi/efivars\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIf the directory not exist, you are not in UEFI mode.\u003c/p\u003e\n\u003ch3 id=\"-internet-\"\u003e[ Internet ]\u003c/h3\u003e\n\u003ch4 id=\"check-system-activate-internet-interface\"\u003eCheck system activate internet interface\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eip link\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"for-ethernet-dhcp\"\u003eFor Ethernet (DHCP)\u003c/h4\u003e\n\u003cp\u003eGood to go!\u003c/p\u003e\n\u003ch4 id=\"for-wifi-iwd\"\u003eFor WiFi (iwd)\u003c/h4\u003e\n\u003cp\u003eenter interactive prompt\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eiwctl\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003elist all wifi device\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eiwd\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e device list\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eselect the device you want to use, i.e: wlan0\u003cbr\u003e\nand start scanning\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eiwd\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e station \u0026lt;device\u0026gt; scan\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eafter scanning, you can list all available networks\u003c/p\u003e","title":"Basic Archlinux Wayfire Install"},{"content":"Song - Cozy A little song for my ex.\nI hope you can be happy even when I\u0026rsquo;m not with you 🫠 ","permalink":"https://novel2430.github.io/ideas/cozy/","summary":"\u003ch1 id=\"song---cozy\"\u003eSong - Cozy\u003c/h1\u003e\n\u003cp\u003eA little song for my ex.\u003cbr\u003e\nI hope you can be happy even when I\u0026rsquo;m not with you 🫠\n\u003cimg alt=\"img\" loading=\"lazy\" src=\"https://cloud.yejsgk.top/f/eZT0/20231225232420_small.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003caudio controls src=\"https://cloud.yejsgk.top/f/4jha/Cozy.mp3\"\u003e\u003c/audio\u003e\u003c/p\u003e","title":"Cozy"},{"content":"7-1 Replacement Selection When the input is much too large to fit into memory, we have to do external sorting instead of internal sorting. One of the key steps in external sorting is to generate sets of sorted records (also called runs) with limited internal memory. The simplest method is to read as many records as possible into the memory, and sort them internally, then write the resulting run back to some tape. The size of each run is the same as the capacity of the internal memory.\nReplacement Selection sorting algorithm was described in 1965 by Donald Knuth. Notice that as soon as the first record is written to an output tape, the memory it used becomes available for another record. Assume that we are sorting in ascending order, if the next record is not smaller than the record we have just output, then it can be included in the run.\nFor example, suppose that we have a set of input { 81, 94, 11, 96, 12, 99, 35 }, and our memory can sort 3 records only. By the simplest method we will obtain three runs: { 11, 81, 94 }, { 12, 96, 99 } and { 35 }. According to the replacement selection algorithm, we would read and sort the first 3 records { 81, 94, 11 } and output 11 as the smallest one. Then one space is available so 96 is read in and will join the first run since it is larger than 11. Now we have { 81, 94, 96 }. After 81 is out, 12 comes in but it must belong to the next run since it is smaller than 81. Hence we have { 94, 96, 12 } where 12 will stay since it belongs to the next run. When 94 is out and 99 is in, since 99 is larger than 94, it must belong to the first run. Eventually we will obtain two runs: the first one contains { 11, 81, 94, 96, 99 } and the second one contains { 12, 35 }.\nYour job is to implement this replacement selection algorithm.\nInput Specification: Each input file contains several test cases. The first line gives two positive integers N (≤105) and M (\u0026lt;N/2), which are the total number of records to be sorted, and the capacity of the internal memory. Then N numbers are given in the next line, all in the range of int. All the numbers in a line are separated by a space.\nOutput Specification: For each test case, print in each line a run (in ascending order) generated by the replacement selection algorithm. All the numbers in a line must be separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line.\nSample Input: 13 3 81 94 11 96 12 99 17 35 28 58 41 75 15 Sample Output: 11 81 94 96 99 12 17 28 35 41 58 75 15 Code #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MAXN 500000 typedef enum Boolean{FALSE, TRUE} Boolean ; typedef int DataValue ; typedef struct Heap{ DataValue nodes[MAXN]; int size; }Heap; Heap* heap_init(){ Heap* res = (Heap*)malloc(sizeof(Heap)); res-\u0026gt;size = 0; return res; }; void heap_delete(Heap* heap){ if(heap==NULL) return; free(heap); heap = NULL; } void swap(Heap* heap, int idx1, int idx2){ if(heap==NULL) return; DataValue tmp = heap-\u0026gt;nodes[idx1]; heap-\u0026gt;nodes[idx1] = heap-\u0026gt;nodes[idx2]; heap-\u0026gt;nodes[idx2] = tmp; } int min_idx(Heap* heap, int idx1, int idx2){ if(heap-\u0026gt;nodes[idx1] \u0026lt; heap-\u0026gt;nodes[idx2]) return idx1; return idx2; } void heap_insert(Heap* heap, DataValue data){ if(heap==NULL) return; heap-\u0026gt;size++; heap-\u0026gt;nodes[heap-\u0026gt;size] = data; for(int idx=heap-\u0026gt;size; idx\u0026gt;1; idx=idx/2){ DataValue cur = heap-\u0026gt;nodes[idx]; DataValue parent = heap-\u0026gt;nodes[idx/2]; if(parent\u0026gt;cur) swap(heap, idx, idx/2); else break; } } DataValue heap_pop(Heap* heap){ DataValue res = heap-\u0026gt;nodes[1]; swap(heap, 1, heap-\u0026gt;size); for(int idx=1; idx*2\u0026lt;heap-\u0026gt;size; ){ int next_idx = idx; if(idx*2+1\u0026lt;heap-\u0026gt;size){ next_idx = min_idx(heap, idx*2, idx*2+1); } else if(heap-\u0026gt;nodes[idx]\u0026gt;heap-\u0026gt;nodes[idx*2]){ next_idx = idx*2; } if(heap-\u0026gt;nodes[idx] \u0026gt; heap-\u0026gt;nodes[next_idx]) swap(heap, idx, next_idx); else break; idx = next_idx; } heap-\u0026gt;size--; return res; } Boolean heap_is_empty(Heap* heap){ if(heap-\u0026gt;size==0) return TRUE; return FALSE; } void replacement_selection(int* arr, int size, int capacity){ Heap* heap1 = heap_init(); Heap* heap2 = heap_init(); for(int i=0; i\u0026lt;size\u0026amp;\u0026amp;i\u0026lt;capacity; i++) heap_insert(heap1, arr[i]); int cur_idx = capacity; while(!heap_is_empty(heap1) || !heap_is_empty(heap2)){ int print_num_count = 0; int flag = 0; while(!heap_is_empty(heap1)){ int cur_min = heap_pop(heap1); flag = 1; if(cur_idx \u0026lt; size){ int cur_num = arr[cur_idx++]; if(cur_min \u0026lt; cur_num) heap_insert(heap1, cur_num); else heap_insert(heap2, cur_num); } if(print_num_count++ \u0026gt; 0) printf(\u0026#34; \u0026#34;); printf(\u0026#34;%d\u0026#34;, cur_min); } if(flag) printf(\u0026#34;\\n\u0026#34;); print_num_count = 0; flag = 0; while(!heap_is_empty(heap2)){ flag = 1; int cur_min = heap_pop(heap2); if(cur_idx \u0026lt; size){ int cur_num = arr[cur_idx++]; if(cur_min \u0026lt; cur_num) heap_insert(heap2, cur_num); else heap_insert(heap1, cur_num); } if(print_num_count++ \u0026gt; 0) printf(\u0026#34; \u0026#34;); printf(\u0026#34;%d\u0026#34;, cur_min); } if(flag) printf(\u0026#34;\\n\u0026#34;); } heap_delete(heap1); heap_delete(heap2); } int main(int argc, char *argv[]){ int size, capacity; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;size, \u0026amp;capacity); int arr[MAXN]; for(int i=0; i\u0026lt;size; i++){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;arr[i]); } replacement_selection(arr, size, capacity); return 0; } ","permalink":"https://novel2430.github.io/notes/replacement-selection/","summary":"\u003ch1 id=\"7-1-replacement-selection\"\u003e7-1 Replacement Selection\u003c/h1\u003e\n\u003cp\u003eWhen the input is much too large to fit into memory, we have to do \u003cstrong\u003eexternal sorting\u003c/strong\u003e instead of internal sorting. One of the key steps in external sorting is to generate sets of sorted records (also called runs) with limited internal memory. The simplest method is to read as many records as possible into the memory, and sort them internally, then write the resulting run back to some tape. The size of each run is the same as the capacity of the internal memory.\u003cbr\u003e\n\u003cstrong\u003eReplacement Selection\u003c/strong\u003e sorting algorithm was described in 1965 by Donald Knuth. Notice that as soon as the first record is written to an output tape, the memory it used becomes available for another record. Assume that we are sorting in ascending order, if the next record is not smaller than the record we have just output, then it can be included in the run.\u003cbr\u003e\nFor example, suppose that we have a set of input { 81, 94, 11, 96, 12, 99, 35 }, and our memory can sort 3 records only. By the simplest method we will obtain three runs: { 11, 81, 94 }, { 12, 96, 99 } and { 35 }. According to the replacement selection algorithm, we would read and sort the first 3 records { 81, 94, 11 } and output 11 as the smallest one. Then one space is available so 96 is read in and will join the first run since it is larger than 11. Now we have { 81, 94, 96 }. After 81 is out, 12 comes in but it must belong to the next run since it is smaller than 81. Hence we have { 94, 96, 12 } where 12 will stay since it belongs to the next run. When 94 is out and 99 is in, since 99 is larger than 94, it must belong to the \u003cstrong\u003efirst run\u003c/strong\u003e. Eventually we will obtain two runs: the first one contains { 11, 81, 94, 96, 99 } and the second one contains { 12, 35 }.\u003cbr\u003e\nYour job is to implement this replacement selection algorithm.\u003c/p\u003e","title":"Replacement Selection"},{"content":"7-1 Queue Using Two Stacks A queue (FIFO structure) can be implemented by two stacks (LIFO structure) in the following way:\nStart from two empty stacks s1 and s2\nWhen element e is enqueued, it is actually pushed onto s1\nWhen we are supposed to dequeue, s2 is checked first. If s2 is empty, everything in s1 will be transferred to s2 by popping from s1 and immediately pushing onto s2. Then we just pop from s2 \u0026ndash; the top element of s2 must be the first one to enter s1 thus is the first element that was enqueued.\nAssume that each operation of push or pop takes 1 unit of time. You job is to tell the time taken for each dequeue.\nInput Specification: Each input file contains one test case. For each case, the first line gives a positive integer N (≤103), which are the number of operations. Then N lines follow, each gives an operation in the format\nOperation Element where Operation being I represents enqueue and O represents dequeue. For each I, Element is a positive integer that is no more than 106. No Element is given for O operations.\nIt is guaranteed that there is at least one O operation.\nOutput Specification: For each dequeue operation, print in a line the dequeued element and the unites of time taken to do this dequeue. The numbers in a line must be separated by 1 space, and there must be no extra space at the beginning or the end of the line.\nIn case that the queue is empty when dequeue is called, output in a line ERROR instead.\nSample Input: 10 I 20 I 32 O I 11 O O O I 100 I 66 O Sample Output: 20 5 32 1 11 3 ERROR 100 5 Code #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // Basic Struct typedef struct stack_node{ int values; struct stack_node* next; struct stack_node* before; }stack_node; typedef struct my_stack { stack_node* head; stack_node* top; }my_stack; typedef struct my_queue { my_stack* stack1; my_stack* stack2; int op_count; }my_queue; // Node op stack_node* node_init(int num){ stack_node* node = (stack_node*)malloc(sizeof(stack_node)); node-\u0026gt;values = num; node-\u0026gt;next = NULL; node-\u0026gt;before = NULL; return node; } void node_delete(stack_node* node){ if(node==NULL) return; free(node); node = NULL; } // Stack op my_stack* stack_init(){ my_stack* res = (my_stack*)malloc(sizeof(my_stack)); res-\u0026gt;head = node_init(0); res-\u0026gt;top = res-\u0026gt;head; return res; } void stack_delete(my_stack* stack){ if(stack==NULL) return; stack_node* cur = stack-\u0026gt;head; while(cur != NULL){ stack_node* next_node = cur-\u0026gt;next; node_delete(cur); cur = next_node; } free(stack); stack = NULL; } void stack_push(my_stack* stack, int num){ stack-\u0026gt;head-\u0026gt;values++; stack_node* node = node_init(num); stack-\u0026gt;top-\u0026gt;next = node; node-\u0026gt;before = stack-\u0026gt;top; stack-\u0026gt;top = node; } int stack_pop(my_stack* stack){ stack-\u0026gt;head-\u0026gt;values--; int res = stack-\u0026gt;top-\u0026gt;values; stack_node* old_top = stack-\u0026gt;top; stack_node* new_top = stack-\u0026gt;top-\u0026gt;before; node_delete(old_top); stack-\u0026gt;top = new_top; stack-\u0026gt;top-\u0026gt;next = NULL; return res; } int stack_is_empty(my_stack* stack){ if(stack==NULL || stack-\u0026gt;head!=stack-\u0026gt;top){ return 0; } return 1; } // Queue op my_queue* queue_init(){ my_queue* res = (my_queue*)malloc(sizeof(my_queue)); res-\u0026gt;stack1 = stack_init(); res-\u0026gt;stack2 = stack_init(); res-\u0026gt;op_count = 0; return res; } void queue_delete(my_queue* queue){ if(queue == NULL) return; stack_delete(queue-\u0026gt;stack1); stack_delete(queue-\u0026gt;stack2); free(queue); queue = NULL; } void queue_push(my_queue* queue, int num){ stack_push(queue-\u0026gt;stack1, num); } int queue_pop(my_queue* queue){ queue-\u0026gt;op_count = 0; if(stack_is_empty(queue-\u0026gt;stack1) \u0026amp;\u0026amp; stack_is_empty(queue-\u0026gt;stack2)) return -1; if(stack_is_empty(queue-\u0026gt;stack2)){ queue-\u0026gt;op_count = queue-\u0026gt;stack1-\u0026gt;head-\u0026gt;values*2; while(!stack_is_empty(queue-\u0026gt;stack1)){ stack_push(queue-\u0026gt;stack2, stack_pop(queue-\u0026gt;stack1)); } } queue-\u0026gt;op_count++; return stack_pop(queue-\u0026gt;stack2); } int main(){ int op_counts = 0; my_queue* queue = queue_init(); scanf(\u0026#34;%d\u0026#34;, \u0026amp;op_counts); int print_count = 0; for(int i=0; i\u0026lt;op_counts; i++){ /* printf(\u0026#34;Time : %d\\n\u0026#34;,i); */ getchar(); char op; scanf(\u0026#34;%c\u0026#34;, \u0026amp;op); if(op==\u0026#39;I\u0026#39;){ int num; scanf(\u0026#34;%d\u0026#34;, \u0026amp;num); queue_push(queue, num); } else if(op==\u0026#39;O\u0026#39;){ int num = queue_pop(queue); if(num==-1){ if(print_count\u0026gt;0) printf(\u0026#34;\\nERROR\u0026#34;); else printf(\u0026#34;ERROR\u0026#34;); } else { if(print_count\u0026gt;0) printf(\u0026#34;\\n%d %d\u0026#34;,num, queue-\u0026gt;op_count); else printf(\u0026#34;%d %d\u0026#34;,num, queue-\u0026gt;op_count); } print_count++; } } queue_delete(queue); return 0; } ","permalink":"https://novel2430.github.io/notes/queue-using-two-stacks/","summary":"\u003ch1 id=\"7-1-queue-using-two-stacks\"\u003e7-1 Queue Using Two Stacks\u003c/h1\u003e\n\u003cp\u003eA queue (FIFO structure) can be implemented by two stacks (LIFO structure) in the following way:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eStart from two empty stacks s\u003csub\u003e1\u003c/sub\u003e and s\u003csub\u003e2\u003c/sub\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWhen element \u003ccode\u003ee\u003c/code\u003e is enqueued, it is actually pushed onto s\u003csub\u003e1\u003c/sub\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWhen we are supposed to dequeue, s\u003csub\u003e2\u003c/sub\u003e is checked first. If s\u003csub\u003e2\u003c/sub\u003e is empty, everything in s\u003csub\u003e1\u003c/sub\u003e will be transferred to s\u003csub\u003e2\u003c/sub\u003e by popping from s\u003csub\u003e1\u003c/sub\u003e and immediately pushing onto s\u003csub\u003e2\u003c/sub\u003e. Then we just pop from s\u003csub\u003e2\u003c/sub\u003e \u0026ndash; the top element of s\u003csub\u003e2\u003c/sub\u003e must be the first one to enter s\u003csub\u003e1\u003c/sub\u003e thus is the first element that was enqueued.\u003c/p\u003e","title":"Queue Using Two Stacks"},{"content":"7-1 Hashing - Hard Version Given a hash table of size N, we can define a hash function H(x)=x%N. Suppose that the linear probing is used to solve collisions, we can easily obtain the status of the hash table with a given sequence of input numbers.\nHowever, now you are asked to solve the reversed problem: reconstruct the input sequence from the given status of the hash table. Whenever there are multiple choices, the smallest number is always taken.\nInput Specification: Each input file contains one test case. For each test case, the first line contains a positive integer N (≤1000), which is the size of the hash table. The next line contains N integers, separated by a space. A negative integer represents an empty cell in the hash table. It is guaranteed that all the non-negative integers are distinct in the table.\nOutput Specification: For each test case, print a line that contains the input sequence, with the numbers separated by a space. Notice that there must be no extra space at the end of each line.\nSample Input: 11 33 1 13 12 34 38 27 22 32 -1 21 Sample Output: 1 13 12 21 33 34 38 27 22 32 Code #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MAXN 1000 typedef enum Boolean {FALSE, TRUE} Boolean ; typedef struct Node{ int value; int before_count; int after_count; struct Node* after[MAXN]; }Node ; typedef struct Heap{ int size; Node* nodes[MAXN]; }Heap ; Node* node_init(int value){ Node* res = (Node*)malloc(sizeof(Node)); res-\u0026gt;value = value; res-\u0026gt;after_count = 0; res-\u0026gt;before_count = 0; return res; } void node_delete(Node* node){ if(node==NULL) return; free(node); node = NULL; } void node_add_after(Node* cur, Node* after){ if(cur==NULL || after==NULL) return; cur-\u0026gt;after[cur-\u0026gt;after_count] = after; cur-\u0026gt;after_count++; after-\u0026gt;before_count++; } Heap* heap_init(){ Heap* res = (Heap*)malloc(sizeof(Heap)); res-\u0026gt;size = 0; return res; } void heap_delete(Heap* heap){ if(heap==NULL) return; for(int i=0; i\u0026lt;heap-\u0026gt;size; i++) node_delete(heap-\u0026gt;nodes[i]); free(heap); heap = NULL; } Boolean heap_is_empty(Heap* heap){ if(heap-\u0026gt;size==0) return TRUE; return FALSE; } int min_idx(Heap* heap, int idx1, int idx2){ if(heap-\u0026gt;nodes[idx1]-\u0026gt;value \u0026lt; heap-\u0026gt;nodes[idx2]-\u0026gt;value) return idx1; return idx2; } void swap(Heap* heap, int idx1, int idx2){ Node* tmp = heap-\u0026gt;nodes[idx1]; heap-\u0026gt;nodes[idx1] = heap-\u0026gt;nodes[idx2]; heap-\u0026gt;nodes[idx2] = tmp; } void heap_insert(Heap* heap, Node* node){ if(heap==NULL || node==NULL) return; heap-\u0026gt;nodes[heap-\u0026gt;size] = node; for(int i=heap-\u0026gt;size; i\u0026gt;0; i=(i-1)/2){ Node* cur = heap-\u0026gt;nodes[i]; Node* father = heap-\u0026gt;nodes[(i-1)/2]; if(cur-\u0026gt;value \u0026gt;= father-\u0026gt;value) break; swap(heap, i, (i-1)/2); } heap-\u0026gt;size++; } Node* heap_pop(Heap* heap){ if(heap==NULL || heap-\u0026gt;size==0) return NULL; heap-\u0026gt;size--; Node* res = heap-\u0026gt;nodes[0]; swap(heap, 0, heap-\u0026gt;size); int next = 0; for(int i=0; i*2+1\u0026lt;heap-\u0026gt;size; i=next){ if(i*2+2 \u0026lt; heap-\u0026gt;size) next = min_idx(heap, i*2+1, i*2+2); else next = i*2+1; if(heap-\u0026gt;nodes[i]-\u0026gt;value \u0026lt;= heap-\u0026gt;nodes[next]-\u0026gt;value) break; swap(heap, i, next); } return res; } void build_node_reletions(Node* nodes[MAXN], int size){ for(int i=0; i\u0026lt;size; i++){ Node* cur = nodes[i]; if(cur==NULL) continue; int dist = i - cur-\u0026gt;value%size; if(dist \u0026lt; 0) dist = size + dist; for(int ii=cur-\u0026gt;value%size; ii\u0026lt;(cur-\u0026gt;value%size)+dist; ii++){ int idx = ii%size; node_add_after(nodes[idx], cur); } } } void build_input_seq(Node* nodes[MAXN], int size){ Heap* heap = heap_init(); for(int i=0; i\u0026lt;size; i++){ if(nodes[i]==NULL) continue; if(nodes[i]-\u0026gt;before_count==0) heap_insert(heap, nodes[i]); } int count = 0; while(!heap_is_empty(heap)){ Node* cur = heap_pop(heap); for(int i=0; i\u0026lt;cur-\u0026gt;after_count; i++){ cur-\u0026gt;after[i]-\u0026gt;before_count--; if(cur-\u0026gt;after[i]-\u0026gt;before_count==0) heap_insert(heap, cur-\u0026gt;after[i]); } if(count \u0026gt; 0) printf(\u0026#34; \u0026#34;); printf(\u0026#34;%d\u0026#34;, cur-\u0026gt;value); count++; } heap_delete(heap); } int main(int argc, char *argv[]){ int size; Node* nodes[MAXN]; scanf(\u0026#34;%d\u0026#34;, \u0026amp;size); for(int i=0; i\u0026lt;size; i++){ int tmp; scanf(\u0026#34;%d\u0026#34;, \u0026amp;tmp); if(tmp\u0026lt;0) nodes[i] = NULL; else nodes[i] = node_init(tmp); } build_node_reletions(nodes, size); build_input_seq(nodes, size); return 0; } ","permalink":"https://novel2430.github.io/notes/hashing-hard-version/","summary":"\u003ch1 id=\"7-1-hashing---hard-version\"\u003e7-1 Hashing - Hard Version\u003c/h1\u003e\n\u003cp\u003eGiven a hash table of size N, we can define a hash function \u003ccode\u003eH(x)=x%N\u003c/code\u003e. Suppose that the linear probing is used to solve collisions, we can easily obtain the status of the hash table with a given sequence of input numbers.\u003cbr\u003e\nHowever, now you are asked to solve the reversed problem: reconstruct the input sequence from the given status of the hash table. Whenever there are multiple choices, the smallest number is always taken.\u003c/p\u003e","title":"Hashing Hard Version"},{"content":"7-1 Insertion or Heap Sort According to Wikipedia:\nInsertion sort iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.\nHeap sort divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. it involves the use of a heap data structure rather than a linear-time search to find the maximum.\nNow given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using?\nInput Specification: Each input file contains one test case. For each case, the first line gives a positive integer N (≤100). Then in the next line, N integers are given as the initial sequence. The last line contains the partially sorted sequence of the N numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space.\nOutput Specification: For each test case, print in the first line either \u0026ldquo;Insertion Sort\u0026rdquo; or \u0026ldquo;Heap Sort\u0026rdquo; to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resulting sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.\nSample Input 1: 10 3 1 2 8 7 5 9 4 6 0 1 2 3 7 8 5 9 4 6 0 Sample Output 1: Insertion Sort 1 2 3 5 7 8 9 4 6 0 Sample Input 2: 10 3 1 2 8 7 5 9 4 6 0 6 4 5 1 0 3 2 7 8 9 Sample Output 2: Heap Sort 5 4 3 1 0 2 6 7 8 9 Code #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MAXN 1000 typedef enum SortType{ INSERTION, HEAP }SortType ; SortType get_sort_type(int* arr, int* orig, int size){ if(arr[0]\u0026lt;arr[1]) return INSERTION; return HEAP; } void swap(int* arr, int idx1, int idx2){ int tmp = arr[idx1]; arr[idx1] = arr[idx2]; arr[idx2] = tmp; } int max_idx(int* arr, int idx1, int idx2){ if(arr[idx1]\u0026gt;arr[idx2]) return idx1; return idx2; } void do_sort(SortType type, int* arr, int size){ if(type==INSERTION){ int idx = 0; for(int i=0; i\u0026lt;size-1; i++){ if(arr[i]\u0026gt;arr[i+1]){ idx = i+1; break; } } for(int i=idx; i\u0026gt;0; i--){ if(arr[i]\u0026lt;arr[i-1]){ swap(arr, i, i-1); } } } else{ int max = arr[0]; int heap_size = 0; for(int i=0; i\u0026lt;size; i++){ if(arr[i]\u0026gt;max){ heap_size = i; break; } } heap_size--; swap(arr, 0, heap_size); for(int start=0, next=start; start*2+1\u0026lt;heap_size; start=next){ if(2*(start+1) \u0026lt; heap_size){ next = max_idx(arr, start*2+1, 2*(start+1)); } else{ next = start*2 + 1; } if(arr[start]\u0026gt;arr[next]) break; swap(arr, start, next); } } for(int i=0; i\u0026lt;size; i++){ if(i\u0026gt;0) printf(\u0026#34; \u0026#34;); printf(\u0026#34;%d\u0026#34;, arr[i]); if(i==size-1) printf(\u0026#34;\\n\u0026#34;); } } int main(int argc, char *argv[]){ int size; int arr[MAXN]; int orig[MAXN]; scanf(\u0026#34;%d\u0026#34;, \u0026amp;size); for(int i=0; i\u0026lt;size; i++){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;orig[i]); } for(int i=0; i\u0026lt;size; i++){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;arr[i]); } switch(get_sort_type(arr, orig, size)){ case INSERTION: printf(\u0026#34;Insertion Sort\\n\u0026#34;); do_sort(INSERTION, arr, size); break; case HEAP: printf(\u0026#34;Heap Sort\\n\u0026#34;); do_sort(HEAP, arr, size); break; default: break; } return 0; } ","permalink":"https://novel2430.github.io/notes/insertion-or-heap-sort/","summary":"\u003ch1 id=\"7-1-insertion-or-heap-sort\"\u003e7-1 Insertion or Heap Sort\u003c/h1\u003e\n\u003cp\u003eAccording to Wikipedia:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eInsertion sort\u003c/strong\u003e iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHeap sort\u003c/strong\u003e divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. it involves the use of a heap data structure rather than a linear-time search to find the maximum.\u003c/p\u003e","title":"Insertion or Heap Sort"},{"content":"6-1 Iterative Mergesort How would you implement mergesort without using recursion?\nThe idea of iterative mergesort is to start from N sorted sublists of length 1, and each time to merge a pair of adjacent sublists until one sorted list is obtained. You are supposed to implement the key function of merging.\nFormat of functions: void merge_pass( ElementType list[], ElementType sorted[], int N, int length ); The function merge_pass performs one pass of the merge sort that merges adjacent pairs of sublists from list into sorted. N is the number of elements in the list and length is the length of the sublists.\nSample program of judge: #include \u0026lt;stdio.h\u0026gt; #define ElementType int #define MAXN 100 void merge_pass( ElementType list[], ElementType sorted[], int N, int length ); void output( ElementType list[], int N ) { int i; for (i=0; i\u0026lt;N; i++) printf(\u0026#34;%d \u0026#34;, list[i]); printf(\u0026#34;\\n\u0026#34;); } void merge_sort( ElementType list[], int N ) { ElementType extra[MAXN]; /* the extra space required */ int length = 1; /* current length of sublist being merged */ while( length \u0026lt; N ) { merge_pass( list, extra, N, length ); /* merge list into extra */ output( extra, N ); length *= 2; merge_pass( extra, list, N, length ); /* merge extra back to list */ output( list, N ); length *= 2; } } int main() { int N, i; ElementType A[MAXN]; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); for (i=0; i\u0026lt;N; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;A[i]); merge_sort(A, N); output(A, N); return 0; } /* Your function will be put here */ Sample Input: 10 8 7 9 2 3 5 1 6 4 0 Sample Output: 7 8 2 9 3 5 1 6 0 4 2 7 8 9 1 3 5 6 0 4 1 2 3 5 6 7 8 9 0 4 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 Code #include \u0026lt;stdio.h\u0026gt; #define ElementType int #define MAXN 100 void merge_pass( ElementType list[], ElementType sorted[], int N, int length ); void output( ElementType list[], int N ) { int i; for (i=0; i\u0026lt;N; i++) printf(\u0026#34;%d \u0026#34;, list[i]); printf(\u0026#34;\\n\u0026#34;); } void merge_sort( ElementType list[], int N ) { ElementType extra[MAXN]; /* the extra space required */ int length = 1; /* current length of sublist being merged */ while( length \u0026lt; N ) { merge_pass( list, extra, N, length ); /* merge list into extra */ output( extra, N ); length *= 2; merge_pass( extra, list, N, length ); /* merge extra back to list */ output( list, N ); length *= 2; } } int main() { int N, i; ElementType A[MAXN]; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); for (i=0; i\u0026lt;N; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;A[i]); merge_sort(A, N); output(A, N); return 0; } /* Your function will be put here */ int min(int x, int y) { return x \u0026lt; y ? x : y; } void merge_pass( ElementType list[], ElementType sorted[], int N, int length ){ for(int start=0; start\u0026lt;N; start+=length*2){ int cur_idx = start; int start1 = start; int end1 = min(start+length, N); int start2 = end1; int end2 = min(start+length*2, N); while(start1\u0026lt;end1 \u0026amp;\u0026amp; start2\u0026lt;end2){ if(list[start1]\u0026gt;list[start2]){ sorted[cur_idx++] = list[start2++]; } else{ sorted[cur_idx++] = list[start1++]; } } while(start1\u0026lt;end1){ sorted[cur_idx++] = list[start1++]; } while(start2\u0026lt;end2){ sorted[cur_idx++] = list[start2++]; } } } ","permalink":"https://novel2430.github.io/notes/iterative-mergesort/","summary":"\u003ch1 id=\"6-1-iterative-mergesort\"\u003e6-1 Iterative Mergesort\u003c/h1\u003e\n\u003cp\u003eHow would you implement mergesort without using recursion?\u003c/p\u003e\n\u003cp\u003eThe idea of iterative mergesort is to start from N sorted sublists of length 1, and each time to merge a pair of adjacent sublists until one sorted list is obtained. You are supposed to implement the key function of merging.\u003c/p\u003e\n\u003ch2 id=\"format-of-functions\"\u003eFormat of functions:\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emerge_pass\u003c/span\u003e( ElementType list[], ElementType sorted[], \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e N, \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e length );\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe function \u003ccode\u003emerge_pass\u003c/code\u003e performs one pass of the merge sort that merges adjacent pairs of sublists from \u003ccode\u003elist\u003c/code\u003e into \u003ccode\u003esorted\u003c/code\u003e. \u003ccode\u003eN\u003c/code\u003e is the number of elements in the \u003ccode\u003elist\u003c/code\u003e and length is the \u003ccode\u003elength\u003c/code\u003e of the sublists.\u003c/p\u003e","title":"Iterative Mergesort"},{"content":"6-1 Strongly Connected Components Write a program to find the strongly connected components in a digraph.\nFormat of functions: void StronglyConnectedComponents( Graph G, void (*visit)(Vertex V) ); where Graph is defined as the following:\ntypedef struct VNode *PtrToVNode; struct VNode { Vertex Vert; PtrToVNode Next; }; typedef struct GNode *Graph; struct GNode { int NumOfVertices; int NumOfEdges; PtrToVNode *Array; }; Here void (*visit)(Vertex V) is a function parameter that is passed into StronglyConnectedComponents to handle (print with a certain format) each vertex that is visited. The function StronglyConnectedComponents is supposed to print a return after each component is found.\nSample program of judge: #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MaxVertices 10 /* maximum number of vertices */ typedef int Vertex; /* vertices are numbered from 0 to MaxVertices-1 */ typedef struct VNode *PtrToVNode; struct VNode { Vertex Vert; PtrToVNode Next; }; typedef struct GNode *Graph; struct GNode { int NumOfVertices; int NumOfEdges; PtrToVNode *Array; }; Graph ReadG(); /* details omitted */ void PrintV( Vertex V ) { printf(\u0026#34;%d \u0026#34;, V); } void StronglyConnectedComponents( Graph G, void (*visit)(Vertex V) ); int main() { Graph G = ReadG(); StronglyConnectedComponents( G, PrintV ); return 0; } /* Your function will be put here */ Sample Input (for the graph shown in the figure): 4 5 0 1 1 2 2 0 3 1 3 2 Sample Output: 3 1 2 0 Note: The output order does not matter. That is, a solution like\n0 1 2 3 is also considered correct.\nCode Tarjan #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MaxVertices 10 /* maximum number of vertices */ typedef int Vertex; /* vertices are numbered from 0 to MaxVertices-1 */ typedef struct VNode *PtrToVNode; struct VNode { Vertex Vert; PtrToVNode Next; }; typedef struct GNode *Graph; struct GNode { int NumOfVertices; int NumOfEdges; PtrToVNode *Array; }; Graph ReadG(); /* details omitted */ void PrintV( Vertex V ) { printf(\u0026#34;%d \u0026#34;, V); } void StronglyConnectedComponents( Graph G, void (*visit)(Vertex V) ); int main() { Graph G = ReadG(); StronglyConnectedComponents( G, PrintV ); return 0; } PtrToVNode ptr_node_init(Vertex v){ PtrToVNode res = (PtrToVNode)malloc(sizeof(struct VNode)); res-\u0026gt;Vert = v; res-\u0026gt;Next = NULL; return res; } Graph ReadG(){ Graph res = (Graph)malloc(sizeof(struct GNode)); int vertice_num, edge_num; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;vertice_num, \u0026amp;edge_num); res-\u0026gt;NumOfVertices = vertice_num; res-\u0026gt;NumOfEdges = edge_num; res-\u0026gt;Array = (PtrToVNode*)malloc(sizeof(PtrToVNode)*res-\u0026gt;NumOfVertices); for(int i=0; i\u0026lt;vertice_num; i++) res-\u0026gt;Array[i] = NULL; for(int i=0; i\u0026lt;edge_num; i++){ int v1, v2; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;v1, \u0026amp;v2); PtrToVNode node = ptr_node_init(v2); if(res-\u0026gt;Array[v1]==NULL) res-\u0026gt;Array[v1] = node; else{ node-\u0026gt;Next = res-\u0026gt;Array[v1]; res-\u0026gt;Array[v1] = node; } } return res; } /* Your function will be put here */ typedef enum Boolean {FALSE, TRUE} Boolean ; typedef int StackVal; ; typedef struct Stack{ int max_size; int cur_top; StackVal* array; } Stack; Stack* stack_init(int max){ Stack* res = (Stack*)malloc(sizeof(Stack)); res-\u0026gt;max_size = max; res-\u0026gt;cur_top = -1; res-\u0026gt;array = (StackVal*)malloc(sizeof(StackVal)*res-\u0026gt;max_size); return res; } Boolean stack_is_empty(Stack* stack){ if(stack-\u0026gt;cur_top==-1) return TRUE; return FALSE; } void stack_insert(Stack* stack, StackVal val){ stack-\u0026gt;cur_top++; stack-\u0026gt;array[stack-\u0026gt;cur_top] = val; } StackVal stack_pop(Stack* stack){ int res = stack-\u0026gt;array[stack-\u0026gt;cur_top]; stack-\u0026gt;cur_top--; return res; } StackVal stack_peak(Stack* stack){ int res = stack-\u0026gt;array[stack-\u0026gt;cur_top]; return res; } void stack_empty(Stack* stack){ while(!stack_is_empty(stack)){ stack_pop(stack); } } int min(int a, int b){ if(a \u0026lt; b) return a; return b; } void tarjan(Graph G, Stack* stack, int* dfn, int* low, Boolean* in_stack, int cur_idx, int* visit_count, void (*visit)(Vertex V)){ dfn[cur_idx] = *visit_count; low[cur_idx] = *visit_count; (*visit_count)++; stack_insert(stack, cur_idx); in_stack[cur_idx] = TRUE; for(PtrToVNode cur=G-\u0026gt;Array[cur_idx]; cur!=NULL; cur=cur-\u0026gt;Next){ if(dfn[cur-\u0026gt;Vert]\u0026lt;0){ tarjan(G, stack, dfn, low, in_stack, cur-\u0026gt;Vert, visit_count, visit); low[cur_idx] = min(low[cur_idx], low[cur-\u0026gt;Vert]); } else if(in_stack[cur-\u0026gt;Vert]){ low[cur_idx] = min(low[cur_idx], dfn[cur-\u0026gt;Vert]); } } if(low[cur_idx]==dfn[cur_idx]){ while(!stack_is_empty(stack)){ int stack_top = stack_pop(stack); in_stack[stack_top] = FALSE; visit(stack_top); if(cur_idx==stack_top) break; } printf(\u0026#34;\\n\u0026#34;); } } void StronglyConnectedComponents( Graph G, void (*visit)(Vertex V) ){ Stack* stack = stack_init(G-\u0026gt;NumOfVertices); int dfn[G-\u0026gt;NumOfVertices]; int low[G-\u0026gt;NumOfVertices]; Boolean in_stack[G-\u0026gt;NumOfVertices]; for(int i=0; i\u0026lt;G-\u0026gt;NumOfVertices; i++){ dfn[i] = -1; low[i] = -1; in_stack[i] = FALSE; } for(int i=0; i\u0026lt;G-\u0026gt;NumOfVertices; i++){ int visit_count = 0; if(dfn[i]==-1) tarjan(G, stack, dfn, low, in_stack, i, \u0026amp;visit_count, visit); stack_empty(stack); } } Code Kosaraju #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MaxVertices 10 /* maximum number of vertices */ typedef int Vertex; /* vertices are numbered from 0 to MaxVertices-1 */ typedef struct VNode *PtrToVNode; struct VNode { Vertex Vert; PtrToVNode Next; }; typedef struct GNode *Graph; struct GNode { int NumOfVertices; int NumOfEdges; PtrToVNode *Array; }; Graph ReadG(); /* details omitted */ void PrintV( Vertex V ) { printf(\u0026#34;%d \u0026#34;, V); } void StronglyConnectedComponents( Graph G, void (*visit)(Vertex V) ); int main() { Graph G = ReadG(); StronglyConnectedComponents( G, PrintV ); return 0; } PtrToVNode ptr_node_init(Vertex v){ PtrToVNode res = (PtrToVNode)malloc(sizeof(struct VNode)); res-\u0026gt;Vert = v; res-\u0026gt;Next = NULL; return res; } Graph ReadG(){ Graph res = (Graph)malloc(sizeof(struct GNode)); int vertice_num, edge_num; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;vertice_num, \u0026amp;edge_num); res-\u0026gt;NumOfVertices = vertice_num; res-\u0026gt;NumOfEdges = edge_num; res-\u0026gt;Array = (PtrToVNode*)malloc(sizeof(PtrToVNode)*res-\u0026gt;NumOfVertices); for(int i=0; i\u0026lt;vertice_num; i++) res-\u0026gt;Array[i] = NULL; for(int i=0; i\u0026lt;edge_num; i++){ int v1, v2; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;v1, \u0026amp;v2); PtrToVNode node = ptr_node_init(v2); if(res-\u0026gt;Array[v1]==NULL) res-\u0026gt;Array[v1] = node; else{ node-\u0026gt;Next = res-\u0026gt;Array[v1]; res-\u0026gt;Array[v1] = node; } } return res; } /* Your function will be put here */ typedef enum Boolean {FALSE, TRUE} Boolean ; typedef int StackVal; ; typedef struct Stack{ int max_size; int cur_top; StackVal* array; } Stack; Stack* stack_init(int max){ Stack* res = (Stack*)malloc(sizeof(Stack)); res-\u0026gt;max_size = max; res-\u0026gt;cur_top = -1; res-\u0026gt;array = (StackVal*)malloc(sizeof(StackVal)*res-\u0026gt;max_size); return res; } Boolean stack_is_empty(Stack* stack){ if(stack-\u0026gt;cur_top==-1) return TRUE; return FALSE; } void stack_insert(Stack* stack, StackVal val){ stack-\u0026gt;cur_top++; stack-\u0026gt;array[stack-\u0026gt;cur_top] = val; } StackVal stack_pop(Stack* stack){ int res = stack-\u0026gt;array[stack-\u0026gt;cur_top]; stack-\u0026gt;cur_top--; return res; } StackVal stack_peak(Stack* stack){ int res = stack-\u0026gt;array[stack-\u0026gt;cur_top]; return res; } void stack_empty(Stack* stack){ while(!stack_is_empty(stack)){ stack_pop(stack); } } int min(int a, int b){ if(a \u0026lt; b) return a; return b; } Graph build_graph_inverse(Graph graph){ Graph res = (Graph)malloc(sizeof(struct GNode)); res-\u0026gt;NumOfEdges = graph-\u0026gt;NumOfEdges; res-\u0026gt;NumOfVertices = graph-\u0026gt;NumOfVertices; res-\u0026gt;Array = (PtrToVNode*)malloc(sizeof(PtrToVNode)*res-\u0026gt;NumOfVertices); for(int i=0; i\u0026lt;res-\u0026gt;NumOfVertices; i++) res-\u0026gt;Array[i] = NULL; for(int i=0; i\u0026lt;res-\u0026gt;NumOfVertices; i++){ for(PtrToVNode cur = graph-\u0026gt;Array[i]; cur!=NULL; cur=cur-\u0026gt;Next){ int v1 = cur-\u0026gt;Vert; int v2 = i; PtrToVNode node = (PtrToVNode)malloc(sizeof(struct VNode)); node-\u0026gt;Vert = v2; node-\u0026gt;Next = NULL; if(res-\u0026gt;Array[v1]==NULL) res-\u0026gt;Array[v1] = node; else{ node-\u0026gt;Next = res-\u0026gt;Array[v1]; res-\u0026gt;Array[v1] = node; } } } return res; } void kosaraju_first_dfs(Graph graph, Stack* stack, Boolean* visit, Boolean* in_stack, int cur_idx){ if(visit[cur_idx]) return; visit[cur_idx] = TRUE; for(PtrToVNode cur=graph-\u0026gt;Array[cur_idx]; cur!=NULL; cur=cur-\u0026gt;Next){ kosaraju_first_dfs(graph, stack, visit, in_stack, cur-\u0026gt;Vert); } stack_insert(stack, cur_idx); in_stack[cur_idx] = TRUE; } void kosaraju_second_dfs(Graph graph, Boolean* visit, Boolean* in_stack, int cur_idx, void (*print_visit)(Vertex V)){ if(visit[cur_idx] || !in_stack[cur_idx]) return; visit[cur_idx] = TRUE; print_visit(cur_idx); for(PtrToVNode cur=graph-\u0026gt;Array[cur_idx]; cur!=NULL; cur=cur-\u0026gt;Next){ kosaraju_second_dfs(graph, visit, in_stack, cur-\u0026gt;Vert, print_visit); } } void kosaraju(Graph graph, Boolean* is_visit, int start, void (*visit)(Vertex V)){ Graph inverse_graph = build_graph_inverse(graph); Stack* stack = stack_init(graph-\u0026gt;NumOfVertices); Boolean is_visit_2[graph-\u0026gt;NumOfVertices]; Boolean in_stack[graph-\u0026gt;NumOfVertices]; for(int i=0; i\u0026lt;graph-\u0026gt;NumOfVertices; i++) is_visit_2[i] = FALSE; for(int i=0; i\u0026lt;graph-\u0026gt;NumOfVertices; i++) in_stack[i] = FALSE; kosaraju_first_dfs(graph, stack, is_visit, in_stack, start); while(!stack_is_empty(stack)){ int stack_top = stack_pop(stack); if(is_visit_2[stack_top]) continue; kosaraju_second_dfs(inverse_graph, is_visit_2, in_stack, stack_top, visit); printf(\u0026#34;\\n\u0026#34;); } } void StronglyConnectedComponents( Graph G, void (*visit)(Vertex V) ){ Boolean is_visit[G-\u0026gt;NumOfVertices]; for(int i=0; i\u0026lt;G-\u0026gt;NumOfVertices; i++) is_visit[i] = FALSE; for(int i=0; i\u0026lt;G-\u0026gt;NumOfVertices; i++){ if(is_visit[i]) continue; kosaraju(G, is_visit, i, visit); } } ","permalink":"https://novel2430.github.io/notes/strongly-connected-components/","summary":"\u003ch1 id=\"6-1-strongly-connected-components\"\u003e6-1 Strongly Connected Components\u003c/h1\u003e\n\u003cp\u003eWrite a program to find the strongly connected components in a digraph.\u003c/p\u003e\n\u003ch2 id=\"format-of-functions\"\u003eFormat of functions:\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eStronglyConnectedComponents\u003c/span\u003e( Graph G, \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e (\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003evisit)(Vertex V) );\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003ewhere \u003ccode\u003eGraph\u003c/code\u003e is defined as the following:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e VNode \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ePtrToVNode;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e VNode {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Vertex Vert;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    PtrToVNode Next;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e GNode \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eGraph;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e GNode {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e NumOfVertices;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e NumOfEdges;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    PtrToVNode \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eArray;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eHere \u003ccode\u003evoid (*visit)(Vertex V)\u003c/code\u003e is a function parameter that is passed into \u003ccode\u003eStronglyConnectedComponents\u003c/code\u003e to handle (print with a certain format) each vertex that is visited. The function \u003ccode\u003eStronglyConnectedComponents\u003c/code\u003e is supposed to print a return after each component is found.\u003c/p\u003e","title":"Strongly Connected Components"},{"content":"Uniqueness of MST Given any weighted undirected graph, there exists at least one minimum spanning tree (MST) if the graph is connected. Sometimes the MST may not be unique though. Here you are supposed to calculate the minimum total weight of the MST, and also tell if it is unique or not.\nInput Specification: Each input file contains one test case. Each case starts with a line containing 2 numbers N (≤ 500), and M, which are the total number of vertices, and the number of edges, respectively. Then M lines follow, each describes an edge by 3 integers:\nV1 V2 Weight where V1 and V2 are the two ends of the edge (the vertices are numbered from 1 to N), and Weight is the positive weight on that edge. It is guaranteed that the total weight of the graph will not exceed 230.\nOutput Specification: For each test case, first print in a line the total weight of the minimum spanning tree if there exists one, or else print No MST instead. Then if the MST exists, print in the next line Yes if the tree is unique, or No otherwise. There there is no MST, print the number of connected components instead.\nSample Input 1: 5 7 1 2 6 5 1 1 2 3 4 3 4 3 4 1 7 2 4 2 4 5 5 Sample Output 1: 11 Yes Sample Input 2: 4 5 1 2 1 2 3 1 3 4 2 4 1 2 3 1 3 Sample Output 2: 4 No Sample Input 3: 5 5 1 2 1 2 3 1 3 4 2 4 1 2 3 1 3 Sample Output 3: No MST 2 Code Prim #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define MAXN 2000 #define MAXE 150000 typedef enum { FALSE, TRUE } boolean; typedef enum { UNIQUE, PLURAL, NONE } ResType; typedef struct Edge{ int v1; int v2; int weight; }Edge ; typedef struct Graph{ int node_num; int edge_num; Edge* weights[MAXN][MAXN]; Edge* MST_edges[MAXE]; }Graph ; typedef struct HeapNode{ Edge* edge; int to; }HeapNode ; typedef struct Heap{ int size; HeapNode* value[MAXE]; }Heap ; void swap(int pos1, int pos2, Heap* H){ HeapNode* tmp = H-\u0026gt;value[pos1]; H-\u0026gt;value[pos1] = H-\u0026gt;value[pos2]; H-\u0026gt;value[pos2] = tmp; } int min_idx(int idx1, int idx2, Heap* H){ if(H-\u0026gt;value[idx1]-\u0026gt;edge-\u0026gt;weight \u0026lt; H-\u0026gt;value[idx2]-\u0026gt;edge-\u0026gt;weight) return idx1; return idx2; } Heap* heap_init(){ Heap* res = (Heap*)malloc(sizeof(Heap)); res-\u0026gt;size = 0; return res; } void heap_node_delete(HeapNode* node){ if(node==NULL) return; free(node); node = NULL; } boolean heap_is_empty(Heap* heap){ if(heap-\u0026gt;size==0) return TRUE; else return FALSE; } void heap_delete(Heap* heap){ if(heap==NULL) return; for(int i=1; i\u0026lt;=heap-\u0026gt;size; i++){ heap_node_delete(heap-\u0026gt;value[i]); } free(heap); heap = NULL; } HeapNode heap_pop_min(Heap* heap){ HeapNode* res = heap-\u0026gt;value[1]; heap-\u0026gt;value[1] = heap-\u0026gt;value[heap-\u0026gt;size]; heap-\u0026gt;size--; for(int pos=1, child_idx; pos*2\u0026lt;=heap-\u0026gt;size; pos=child_idx){ int val = heap-\u0026gt;value[pos]-\u0026gt;edge-\u0026gt;weight; if(pos*2+1 \u0026lt;= heap-\u0026gt;size) child_idx = min_idx(pos*2, pos*2+1, heap); else child_idx = pos*2; if(heap-\u0026gt;value[child_idx]-\u0026gt;edge-\u0026gt;weight \u0026lt; val) swap(pos, child_idx, heap); else break; } HeapNode node; node.edge = res-\u0026gt;edge; node.to = res-\u0026gt;to; heap_node_delete(res); return node; } void heap_insert(Heap* heap, Edge* edge, int to){ if(heap==NULL) return; HeapNode* new_node = (HeapNode*)malloc(sizeof(HeapNode)); new_node-\u0026gt;edge = edge; new_node-\u0026gt;to = to; heap-\u0026gt;value[heap-\u0026gt;size+1] = new_node; heap-\u0026gt;size++; for(int pos=heap-\u0026gt;size,parent_idx; pos\u0026gt;1; pos=parent_idx){ int val = heap-\u0026gt;value[pos]-\u0026gt;edge-\u0026gt;weight; if(pos%2==0) parent_idx = pos/2; else parent_idx = (pos-1)/2; if(heap-\u0026gt;value[parent_idx]-\u0026gt;edge-\u0026gt;weight\u0026gt;val) swap(pos, parent_idx, heap); else break; } } Graph* graph_init(int node_num, int edge_num){ Graph* res = (Graph*)malloc(sizeof(Graph)); res-\u0026gt;node_num = node_num; res-\u0026gt;edge_num = edge_num; for(int i=0; i\u0026lt;node_num; i++){ for(int j=0; j\u0026lt;node_num; j++) res-\u0026gt;weights[i][j] = NULL; } return res; } void graph_insert_edge(Graph* graph, int v1, int v2, int weight){ Edge* edge = (Edge*)malloc(sizeof(Edge)); edge-\u0026gt;v1 = v1; edge-\u0026gt;v2 = v2; edge-\u0026gt;weight = weight; graph-\u0026gt;weights[v1-1][v2-1] = edge; graph-\u0026gt;weights[v2-1][v1-1] = edge; } ResType find_mst(Graph* graph, Heap* heap, boolean* visit, int start_idx, int* mst_val, int* mst_edge_count){ visit[start_idx] = TRUE; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ if(graph-\u0026gt;weights[start_idx][i]!=NULL){ heap_insert(heap, graph-\u0026gt;weights[start_idx][i], i); } } while(!heap_is_empty(heap)){ HeapNode min = heap_pop_min(heap); Edge* edge = min.edge; if(visit[min.to]) continue; visit[min.to] = TRUE; (*mst_val) += min.edge-\u0026gt;weight; graph-\u0026gt;MST_edges[(*mst_edge_count)++] = edge; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ if(!visit[i] \u0026amp;\u0026amp; graph-\u0026gt;weights[min.to][i]!=NULL){ heap_insert(heap, graph-\u0026gt;weights[min.to][i], i); } } } if((*mst_edge_count)!=graph-\u0026gt;node_num-1) return NONE; return UNIQUE; } int find_tree_count(Graph* graph, Heap* heap, boolean* visit){ int res = 1; int mst_val = 0; int mst_edge_count = 0; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ if(!visit[i]){ find_mst(graph, heap, visit, i, \u0026amp;mst_val, \u0026amp;mst_edge_count); res++; } } return res; } ResType tree_unique(Graph* graph, Heap* heap, int min_mst_val, int mst_edge_count){ boolean visit[MAXN]; for(int ii=0; ii\u0026lt;mst_edge_count; ii++){ Edge* cannot_use_edge = graph-\u0026gt;MST_edges[ii]; memset(visit, FALSE, sizeof(visit)); visit[0] = TRUE; int mst_val = 0; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ if(graph-\u0026gt;weights[0][i]!=NULL){ heap_insert(heap, graph-\u0026gt;weights[0][i], i); } } while(!heap_is_empty(heap)){ HeapNode min = heap_pop_min(heap); Edge* edge = min.edge; if(visit[min.to] || edge==cannot_use_edge) continue; visit[min.to] = TRUE; mst_val += edge-\u0026gt;weight; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ if(!visit[i] \u0026amp;\u0026amp; graph-\u0026gt;weights[min.to][i]!=NULL){ heap_insert(heap, graph-\u0026gt;weights[min.to][i], i); } } } if(mst_val==min_mst_val) return PLURAL; } return UNIQUE; } ResType prim(Graph* graph, int* mst_val, int* tree_count){ int mst_edge_count = 0; Heap* heap = heap_init(); boolean visit[MAXN]; memset(visit, FALSE, sizeof(visit)); ResType res = find_mst(graph, heap, visit, 0, mst_val, \u0026amp;mst_edge_count); if(res==NONE){ (*tree_count) = find_tree_count(graph, heap, visit); } else{ res = tree_unique(graph, heap, *mst_val, mst_edge_count); } heap_delete(heap); return res; } int main(int argc, char *argv[]){ int node_num, edge_num; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;node_num, \u0026amp;edge_num); Graph* graph = graph_init(node_num, edge_num); for(int i=0; i\u0026lt;edge_num; i++){ int v1, v2, weight; scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;v1, \u0026amp;v2, \u0026amp;weight); graph_insert_edge(graph, v1, v2, weight); } int mst_val = 0; int tree_count = 0; ResType res = prim(graph, \u0026amp;mst_val, \u0026amp;tree_count); switch (res) { case UNIQUE: printf(\u0026#34;%d\\nYes\\n\u0026#34;, mst_val); break; case PLURAL: printf(\u0026#34;%d\\nNo\\n\u0026#34;, mst_val); break; case NONE: printf(\u0026#34;No MST\\n%d\\n\u0026#34;, tree_count); break; default: break; } return 0; } Code Kruskal Normal #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define MAXN 150000 typedef enum { FALSE, TRUE } boolean; typedef enum { UNIQUE, PLURAL, NONE } ResType; typedef struct Node{ int val; struct Node* parent; }Node ; typedef struct Edge{ Node* v1; Node* v2; int weight; }Edge ; typedef struct Graph{ int node_num; int edge_num; Edge* edges[MAXN]; Node* nodes[MAXN]; }Graph ; Node* node_init(int val){ Node* res = (Node*)malloc(sizeof(Node)); res-\u0026gt;val = val; res-\u0026gt;parent = res; return res; } Node* node_find_parent(Node* node){ if(node == node-\u0026gt;parent) return node; node-\u0026gt;parent = node_find_parent(node-\u0026gt;parent); return node-\u0026gt;parent; } boolean node_is_same_set(Node* node1, Node* node2){ Node* n1_parent = node_find_parent(node1); Node* n2_parent = node_find_parent(node2); if(n1_parent==n2_parent) return TRUE; return FALSE; } void node_union(Node* node1, Node* node2){ node_find_parent(node1)-\u0026gt;parent = node_find_parent(node2); } Graph* graph_init(int node_num, int edge_num){ Graph* res = (Graph*)malloc(sizeof(Graph)); res-\u0026gt;node_num = node_num; res-\u0026gt;edge_num = edge_num; for(int i=0; i\u0026lt;res-\u0026gt;node_num; i++){ res-\u0026gt;nodes[i] = node_init(i+1); } return res; } void graph_insert_edge(Graph* graph, int idx, int v1, int v2, int weight){ graph-\u0026gt;edges[idx] = (Edge*)malloc(sizeof(Edge)); graph-\u0026gt;edges[idx]-\u0026gt;v1 = graph-\u0026gt;nodes[v1-1]; graph-\u0026gt;edges[idx]-\u0026gt;v2 = graph-\u0026gt;nodes[v2-1];; graph-\u0026gt;edges[idx]-\u0026gt;weight = weight; } void merge_sort_conquer(Edge** arr, Edge** tmp, int low, int mid, int high){ int start_1 = low; int end_1 = mid; int start_2 = mid+1; int end_2 = high; int idx = 0; while(start_1\u0026lt;=end_1 \u0026amp;\u0026amp; start_2\u0026lt;=end_2){ if(arr[start_1]-\u0026gt;weight \u0026lt; arr[start_2]-\u0026gt;weight){ tmp[idx++] = arr[start_1++]; } else{ tmp[idx++] = arr[start_2++]; } } while(start_1 \u0026lt;= end_1){ tmp[idx++] = arr[start_1++]; } while(start_2 \u0026lt;= end_2){ tmp[idx++] = arr[start_2++]; } idx = 0; while(low \u0026lt;= high){ arr[low++] = tmp[idx++]; } } void merge_sort_divide(Edge** arr, Edge** tmp, int low, int high){ if(low\u0026lt;high){ int mid = (low+high)/2; merge_sort_divide(arr, tmp, low, mid); merge_sort_divide(arr, tmp, mid+1, high); merge_sort_conquer(arr, tmp, low, mid, high); } } void merge_sort_edge(Graph* graph){ Edge* tmp[MAXN]; merge_sort_divide(graph-\u0026gt;edges, tmp, 0, graph-\u0026gt;edge_num-1); } ResType kruskal(Graph* graph, int* mst_val){ int mst_edge_count = 0; // find MST Edge* MST_edge[MAXN]; for(int i=0; i\u0026lt;graph-\u0026gt;edge_num\u0026amp;\u0026amp;mst_edge_count\u0026lt;graph-\u0026gt;node_num-1; i++){ Edge* cur_edge = graph-\u0026gt;edges[i]; if(!node_is_same_set(cur_edge-\u0026gt;v1, cur_edge-\u0026gt;v2)){ (*mst_val) += cur_edge-\u0026gt;weight; MST_edge[mst_edge_count++] = cur_edge; node_union(cur_edge-\u0026gt;v1, cur_edge-\u0026gt;v2); } } if(mst_edge_count!=graph-\u0026gt;node_num-1) return NONE; // find SMST for(int i=0; i\u0026lt;mst_edge_count; i++){ int sum_SMST = 0; for(int ii=0; ii\u0026lt;graph-\u0026gt;node_num; ii++) graph-\u0026gt;nodes[ii]-\u0026gt;parent = graph-\u0026gt;nodes[ii]; for(int j=0; j\u0026lt;graph-\u0026gt;edge_num; j++){ Edge* cur_edge = graph-\u0026gt;edges[j]; if(cur_edge==MST_edge[i]) continue; if(!node_is_same_set(cur_edge-\u0026gt;v1, cur_edge-\u0026gt;v2)){ sum_SMST += cur_edge-\u0026gt;weight; node_union(cur_edge-\u0026gt;v1, cur_edge-\u0026gt;v2); } } if(sum_SMST==(*mst_val)) return PLURAL; } return UNIQUE; } int graph_count_set(Graph* graph){ int res = 0; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ if(graph-\u0026gt;nodes[i]-\u0026gt;parent==graph-\u0026gt;nodes[i]) res++; } return res; } int main(int argc, char *argv[]){ int node_num, edge_num; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;node_num, \u0026amp;edge_num); Graph* graph = graph_init(node_num, edge_num); for(int i=0; i\u0026lt;edge_num; i++){ int v1, v2, weight; scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;v1, \u0026amp;v2, \u0026amp;weight); graph_insert_edge(graph, i, v1, v2, weight); } merge_sort_edge(graph); int mst_val = 0; ResType res = kruskal(graph, \u0026amp;mst_val); switch (res) { case UNIQUE: printf(\u0026#34;%d\\nYes\\n\u0026#34;, mst_val); break; case PLURAL: printf(\u0026#34;%d\\nNo\\n\u0026#34;, mst_val); break; case NONE: printf(\u0026#34;No MST\\n%d\\n\u0026#34;, graph_count_set(graph)); break; default: break; } return 0; } Code Kruskal Better #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define MAXN 150000 typedef enum { FALSE, TRUE } boolean; typedef enum { UNIQUE, PLURAL, NONE } ResType; typedef struct Node{ int val; struct Node* parent; }Node ; typedef struct Edge{ Node* v1; Node* v2; int weight; }Edge ; typedef struct Graph{ int node_num; int edge_num; Edge* edges[MAXN]; Node* nodes[MAXN]; }Graph ; Node* node_init(int val){ Node* res = (Node*)malloc(sizeof(Node)); res-\u0026gt;val = val; res-\u0026gt;parent = res; return res; } Node* node_find_parent(Node* node){ if(node == node-\u0026gt;parent) return node; node-\u0026gt;parent = node_find_parent(node-\u0026gt;parent); return node-\u0026gt;parent; } boolean node_is_same_set(Node* node1, Node* node2){ Node* n1_parent = node_find_parent(node1); Node* n2_parent = node_find_parent(node2); if(n1_parent==n2_parent) return TRUE; return FALSE; } void node_union(Node* node1, Node* node2){ node_find_parent(node1)-\u0026gt;parent = node_find_parent(node2); } Graph* graph_init(int node_num, int edge_num){ Graph* res = (Graph*)malloc(sizeof(Graph)); res-\u0026gt;node_num = node_num; res-\u0026gt;edge_num = edge_num; for(int i=0; i\u0026lt;res-\u0026gt;node_num; i++){ res-\u0026gt;nodes[i] = node_init(i+1); } return res; } void graph_insert_edge(Graph* graph, int idx, int v1, int v2, int weight){ graph-\u0026gt;edges[idx] = (Edge*)malloc(sizeof(Edge)); graph-\u0026gt;edges[idx]-\u0026gt;v1 = graph-\u0026gt;nodes[v1-1]; graph-\u0026gt;edges[idx]-\u0026gt;v2 = graph-\u0026gt;nodes[v2-1];; graph-\u0026gt;edges[idx]-\u0026gt;weight = weight; } void merge_sort_conquer(Edge** arr, Edge** tmp, int low, int mid, int high){ int start_1 = low; int end_1 = mid; int start_2 = mid+1; int end_2 = high; int idx = 0; while(start_1\u0026lt;=end_1 \u0026amp;\u0026amp; start_2\u0026lt;=end_2){ if(arr[start_1]-\u0026gt;weight \u0026lt; arr[start_2]-\u0026gt;weight){ tmp[idx++] = arr[start_1++]; } else{ tmp[idx++] = arr[start_2++]; } } while(start_1 \u0026lt;= end_1){ tmp[idx++] = arr[start_1++]; } while(start_2 \u0026lt;= end_2){ tmp[idx++] = arr[start_2++]; } idx = 0; while(low \u0026lt;= high){ arr[low++] = tmp[idx++]; } } void merge_sort_divide(Edge** arr, Edge** tmp, int low, int high){ if(low\u0026lt;high){ int mid = (low+high)/2; merge_sort_divide(arr, tmp, low, mid); merge_sort_divide(arr, tmp, mid+1, high); merge_sort_conquer(arr, tmp, low, mid, high); } } void merge_sort_edge(Graph* graph){ Edge* tmp[MAXN]; merge_sort_divide(graph-\u0026gt;edges, tmp, 0, graph-\u0026gt;edge_num-1); } ResType kruskal(Graph* graph, int* mst_val){ int mst_edge_count = 0; // find MST int flag = 0; for(int i=0; i\u0026lt;graph-\u0026gt;edge_num\u0026amp;\u0026amp;mst_edge_count\u0026lt;graph-\u0026gt;node_num-1; i++){ Edge* cur_edge = graph-\u0026gt;edges[i]; if(!node_is_same_set(cur_edge-\u0026gt;v1, cur_edge-\u0026gt;v2)){ for(int j=i+1; flag==0\u0026amp;\u0026amp;j\u0026lt;graph-\u0026gt;edge_num\u0026amp;\u0026amp;graph-\u0026gt;edges[j]-\u0026gt;weight==cur_edge-\u0026gt;weight; j++){ Edge* edge = graph-\u0026gt;edges[j]; if(node_is_same_set(cur_edge-\u0026gt;v1, edge-\u0026gt;v1) \u0026amp;\u0026amp; node_is_same_set(cur_edge-\u0026gt;v2, edge-\u0026gt;v2)){ flag = 1; break; } if(node_is_same_set(cur_edge-\u0026gt;v1, edge-\u0026gt;v2) \u0026amp;\u0026amp; node_is_same_set(cur_edge-\u0026gt;v2, edge-\u0026gt;v1)){ flag = 1; break; } } (*mst_val) += cur_edge-\u0026gt;weight; mst_edge_count++; node_union(cur_edge-\u0026gt;v1, cur_edge-\u0026gt;v2); } } if(mst_edge_count!=graph-\u0026gt;node_num-1) return NONE; if(flag) return PLURAL; return UNIQUE; } int graph_count_set(Graph* graph){ int res = 0; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ if(graph-\u0026gt;nodes[i]-\u0026gt;parent==graph-\u0026gt;nodes[i]) res++; } return res; } int main(int argc, char *argv[]){ int node_num, edge_num; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;node_num, \u0026amp;edge_num); Graph* graph = graph_init(node_num, edge_num); for(int i=0; i\u0026lt;edge_num; i++){ int v1, v2, weight; scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;v1, \u0026amp;v2, \u0026amp;weight); graph_insert_edge(graph, i, v1, v2, weight); } merge_sort_edge(graph); int mst_val = 0; ResType res = kruskal(graph, \u0026amp;mst_val); switch (res) { case UNIQUE: printf(\u0026#34;%d\\nYes\\n\u0026#34;, mst_val); break; case PLURAL: printf(\u0026#34;%d\\nNo\\n\u0026#34;, mst_val); break; case NONE: printf(\u0026#34;No MST\\n%d\\n\u0026#34;, graph_count_set(graph)); break; default: break; } return 0; } ","permalink":"https://novel2430.github.io/notes/uniqueness-of-mst/","summary":"\u003ch1 id=\"uniqueness-of-mst\"\u003eUniqueness of MST\u003c/h1\u003e\n\u003cp\u003eGiven any weighted undirected graph, there exists at least one minimum spanning tree (MST) if the graph is connected. Sometimes the MST may not be unique though. Here you are supposed to calculate the minimum total weight of the MST, and also tell if it is unique or not.\u003c/p\u003e\n\u003ch2 id=\"input-specification\"\u003eInput Specification:\u003c/h2\u003e\n\u003cp\u003eEach input file contains one test case. Each case starts with a line containing 2 numbers N (≤ 500), and M, which are the total number of vertices, and the number of edges, respectively. Then M lines follow, each describes an edge by 3 integers:\u003c/p\u003e","title":"Uniqueness of MST"},{"content":"Universal Travel Sites After finishing her tour around the Earth, CYLL is now planning a universal travel sites development project. After a careful investigation, she has a list of capacities of all the satellite transportation stations in hand. To estimate a budget, she must know the minimum capacity that a planet station must have to guarantee that every space vessel can dock and download its passengers on arrival.\nInput Specification: Each input file contains one test case. For each case, the first line contains the names of the source and the destination planets, and a positive integer N (≤500). Then N lines follow, each in the format: source[i] destination[i] capacity[i] where source[i] and destination[i] are the names of the satellites and the two involved planets, and capacity[i] \u0026gt; 0 is the maximum number of passengers that can be transported at one pass from source[i] to destination[i]. Each name is a string of 3 uppercase characters chosen from {A-Z}, e.g., ZJU. Note that the satellite transportation stations have no accommodation facilities for the passengers. Therefore none of the passengers can stay. Such a station will not allow arrivals of space vessels that contain more than its own capacity. It is guaranteed that the list contains neither the routes to the source planet nor that from the destination planet.\nOutput Specification: For each test case, just print in one line the minimum capacity that a planet station must have to guarantee that every space vessel can dock and download its passengers on arrival.\nSample Input: EAR MAR 11 EAR AAA 300 EAR BBB 400 AAA BBB 100 AAA CCC 400 AAA MAR 300 BBB DDD 400 AAA DDD 400 DDD AAA 100 CCC MAR 400 DDD CCC 200 DDD MAR 300 Sample Output: 700 Code Dinic // USING DINIC #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define MAXN 2000 #define INF 0x3f3f3f3f typedef enum { FALSE, TRUE } boolean; typedef struct Graph{ int edge_num; int node_num; int flow[MAXN][MAXN]; char dict[MAXN][4]; }Graph ; typedef struct QueueNode{ int val; struct QueueNode* next; }QueueNode ; typedef struct Queue{ QueueNode* head; QueueNode* tail; }Queue ; QueueNode* queue_node_init(int val){ QueueNode* res = (QueueNode*)malloc(sizeof(QueueNode)); res-\u0026gt;val = val; res-\u0026gt;next = NULL; return res; } Queue* queue_init(){ Queue* res = (Queue*)malloc(sizeof(Queue)); res-\u0026gt;head = queue_node_init(0); res-\u0026gt;tail = res-\u0026gt;head; return res; } void queue_insert(Queue* queue, int val){ QueueNode* node = queue_node_init(val); queue-\u0026gt;tail-\u0026gt;next = node; queue-\u0026gt;tail = node; queue-\u0026gt;head-\u0026gt;val++; } int queue_pop(Queue* queue){ int res = -1; QueueNode* cur = queue-\u0026gt;head-\u0026gt;next; if(cur!=NULL){ res = cur-\u0026gt;val; queue-\u0026gt;head-\u0026gt;next = cur-\u0026gt;next; if(cur==queue-\u0026gt;tail){ queue-\u0026gt;tail = queue-\u0026gt;head; } free(cur); cur = NULL; queue-\u0026gt;head-\u0026gt;val--; } return res; } void queue_delete(Queue* queue){ QueueNode* cur = queue-\u0026gt;head; while(cur!=NULL){ QueueNode* tmp = cur; cur = cur-\u0026gt;next; free(tmp); tmp = NULL; } free(queue); queue = NULL; } boolean queue_is_empty(Queue* queue){ if(queue-\u0026gt;head==queue-\u0026gt;tail) return TRUE; return FALSE; } Graph* graph_init(char* start, char* end, int edge_num){ Graph* res = (Graph*)malloc(sizeof(Graph)); res-\u0026gt;edge_num = 2; res-\u0026gt;node_num = edge_num; memset(res-\u0026gt;flow, 0, sizeof(res-\u0026gt;flow)); strcpy(res-\u0026gt;dict[0], start); strcpy(res-\u0026gt;dict[1], end); return res; } void graph_insert_edge(Graph* graph, char* planet1, char* planet2, int weight){ int p1_idx = -1; int p2_idx = -1; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ if(strcmp(graph-\u0026gt;dict[i], planet1)==0){ p1_idx = i; } if(strcmp(graph-\u0026gt;dict[i], planet2)==0){ p2_idx = i; } } if(p1_idx==-1){ strcpy(graph-\u0026gt;dict[graph-\u0026gt;node_num], planet1); p1_idx = graph-\u0026gt;node_num; graph-\u0026gt;node_num++; } if(p2_idx==-1){ strcpy(graph-\u0026gt;dict[graph-\u0026gt;node_num], planet2); p2_idx = graph-\u0026gt;node_num; graph-\u0026gt;node_num++; } graph-\u0026gt;flow[p1_idx][p2_idx] = weight; } int min(int a, int b){ if(a\u0026gt;b) return b; return a; } int count_node_flow_sum(Graph* graph, int idx){ int res = 0; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ res += graph-\u0026gt;flow[idx][i]; } return res; } void build_level_graph_bfs(int* level, Graph* graph){ Queue* queue = queue_init(); queue_insert(queue, 0); level[0] = 1; while(!queue_is_empty(queue)){ int cur_idx = queue_pop(queue); for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ if(level[i]==0 \u0026amp;\u0026amp; graph-\u0026gt;flow[cur_idx][i]\u0026gt;0){ queue_insert(queue, i); level[i] = level[cur_idx]+1; } } } queue_delete(queue); } int find_blocking_flow_dfs(Graph* graph, int* level, int cur_idx, int last_flow){ if(cur_idx==1){ // meet end return last_flow; } int res = 0; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ if(level[i]==level[cur_idx]+1 \u0026amp;\u0026amp; graph-\u0026gt;flow[cur_idx][i]\u0026gt;0){ int flow = find_blocking_flow_dfs(graph, level, i, min(last_flow-res, graph-\u0026gt;flow[cur_idx][i])); graph-\u0026gt;flow[cur_idx][i] -= flow; graph-\u0026gt;flow[i][cur_idx] += flow; res += flow; } } return res; } void dinic(Graph* graph){ int level[MAXN]; while(1){ // build level graph memset(level, 0, sizeof(level)); build_level_graph_bfs(level, graph); // find blocking flow in level graph // \u0026amp; // update residual graph if(!find_blocking_flow_dfs(graph, level, 0, INF)){ // No blocking flow then break break; } } } int main(int argc, char *argv[]){ char start[4]; char end[4]; int edge_num; scanf(\u0026#34;%s %s %d\u0026#34;, start, end, \u0026amp;edge_num); Graph* graph = graph_init(start, end, edge_num); for(int i=0; i\u0026lt;edge_num; i++){ char planet1[4]; char planet2[4]; int capacity; scanf(\u0026#34;%s %s %d\u0026#34;, planet1, planet2, \u0026amp;capacity); graph_insert_edge(graph, planet1, planet2, capacity); } int before = count_node_flow_sum(graph, 0); dinic(graph); int after = count_node_flow_sum(graph, 0); printf(\u0026#34;%d\\n\u0026#34;, before-after); return 0; } Code Ford Fulkerson #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define MAXN 2000 #define INF 0x3f3f3f3f typedef enum { FALSE, TRUE } boolean; typedef struct Graph{ int edge_num; int node_num; int flow[MAXN][MAXN]; char dict[MAXN][4]; }Graph ; typedef struct QueueNode{ int val; struct QueueNode* next; }QueueNode ; typedef struct Queue{ QueueNode* head; QueueNode* tail; }Queue ; QueueNode* queue_node_init(int val){ QueueNode* res = (QueueNode*)malloc(sizeof(QueueNode)); res-\u0026gt;val = val; res-\u0026gt;next = NULL; return res; } Queue* queue_init(){ Queue* res = (Queue*)malloc(sizeof(Queue)); res-\u0026gt;head = queue_node_init(0); res-\u0026gt;tail = res-\u0026gt;head; return res; } void queue_insert(Queue* queue, int val){ QueueNode* node = queue_node_init(val); queue-\u0026gt;tail-\u0026gt;next = node; queue-\u0026gt;tail = node; queue-\u0026gt;head-\u0026gt;val++; } int queue_pop(Queue* queue){ int res = -1; QueueNode* cur = queue-\u0026gt;head-\u0026gt;next; if(cur!=NULL){ res = cur-\u0026gt;val; queue-\u0026gt;head-\u0026gt;next = cur-\u0026gt;next; if(cur==queue-\u0026gt;tail){ queue-\u0026gt;tail = queue-\u0026gt;head; } free(cur); cur = NULL; queue-\u0026gt;head-\u0026gt;val--; } return res; } void queue_delete(Queue* queue){ QueueNode* cur = queue-\u0026gt;head; while(cur!=NULL){ QueueNode* tmp = cur; cur = cur-\u0026gt;next; free(tmp); tmp = NULL; } free(queue); queue = NULL; } void queue_empty(Queue* queue){ QueueNode* cur = queue-\u0026gt;head-\u0026gt;next; while(cur!=NULL){ QueueNode* tmp = cur; cur = cur-\u0026gt;next; free(tmp); tmp = NULL; } queue-\u0026gt;tail = queue-\u0026gt;head; } boolean queue_is_empty(Queue* queue){ if(queue-\u0026gt;head==queue-\u0026gt;tail) return TRUE; return FALSE; } Graph* graph_init(char* start, char* end, int edge_num){ Graph* res = (Graph*)malloc(sizeof(Graph)); res-\u0026gt;edge_num = 2; res-\u0026gt;node_num = edge_num; memset(res-\u0026gt;flow, 0, sizeof(res-\u0026gt;flow)); strcpy(res-\u0026gt;dict[0], start); strcpy(res-\u0026gt;dict[1], end); return res; } void graph_insert_edge(Graph* graph, char* planet1, char* planet2, int weight){ int p1_idx = -1; int p2_idx = -1; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ if(strcmp(graph-\u0026gt;dict[i], planet1)==0){ p1_idx = i; } if(strcmp(graph-\u0026gt;dict[i], planet2)==0){ p2_idx = i; } } if(p1_idx==-1){ strcpy(graph-\u0026gt;dict[graph-\u0026gt;node_num], planet1); p1_idx = graph-\u0026gt;node_num; graph-\u0026gt;node_num++; } if(p2_idx==-1){ strcpy(graph-\u0026gt;dict[graph-\u0026gt;node_num], planet2); p2_idx = graph-\u0026gt;node_num; graph-\u0026gt;node_num++; } graph-\u0026gt;flow[p1_idx][p2_idx] = weight; } int min(int a, int b){ if(a\u0026gt;b) return b; return a; } boolean has_one_path_bfs(Graph* graph, Queue* queue, boolean* visit, int* path, int start, int end){ queue_insert(queue, start); while (!queue_is_empty(queue)) { int cur_idx = queue_pop(queue); visit[cur_idx] = TRUE; if(cur_idx==end) return TRUE; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ if(!visit[i] \u0026amp;\u0026amp; graph-\u0026gt;flow[cur_idx][i]\u0026gt;0){ queue_insert(queue, i); path[i] = cur_idx; } } } return FALSE; } int update_one_path_residual_dfs(Graph* graph, int* path, int cur_idx, int end, int last_num){ if(cur_idx==end){ return last_num; } int next = path[cur_idx]; int min_flow = update_one_path_residual_dfs(graph, path, next, end, min(last_num, graph-\u0026gt;flow[next][cur_idx])); graph-\u0026gt;flow[next][cur_idx] -= min_flow; graph-\u0026gt;flow[cur_idx][next] += min_flow; return min_flow; } void ford_fulkerson(Graph* graph){ Queue* queue = queue_init(); int path[MAXN]; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++) path[i] = i; boolean visit[MAXN]; memset(visit, FALSE, sizeof(visit)); int count = 0; while(has_one_path_bfs(graph, queue, visit, path, 0, 1)){ update_one_path_residual_dfs(graph, path, 1, 0, INF); for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++) path[i] = i; queue_empty(queue); memset(visit, FALSE, sizeof(visit)); } queue_delete(queue); } int count_node_flow_sum(Graph* graph, int idx){ int res = 0; for(int i=0; i\u0026lt;graph-\u0026gt;node_num; i++){ res += graph-\u0026gt;flow[idx][i]; } return res; } int main(int argc, char *argv[]){ char start[4]; char end[4]; int edge_num; scanf(\u0026#34;%s %s %d\u0026#34;, start, end, \u0026amp;edge_num); Graph* graph = graph_init(start, end, edge_num); for(int i=0; i\u0026lt;edge_num; i++){ char planet1[4]; char planet2[4]; int capacity; scanf(\u0026#34;%s %s %d\u0026#34;, planet1, planet2, \u0026amp;capacity); graph_insert_edge(graph, planet1, planet2, capacity); } int before = count_node_flow_sum(graph, 0); ford_fulkerson(graph); int after = count_node_flow_sum(graph, 0); printf(\u0026#34;%d\\n\u0026#34;, before-after); return 0; } ","permalink":"https://novel2430.github.io/notes/universal-travel-sites/","summary":"\u003ch1 id=\"universal-travel-sites\"\u003eUniversal Travel Sites\u003c/h1\u003e\n\u003cp\u003eAfter finishing her tour around the Earth, CYLL is now planning a universal travel sites development project. After a careful investigation, she has a list of capacities of all the satellite transportation stations in hand. To estimate a budget, she must know the minimum capacity that a planet station must have to guarantee that every space vessel can dock and download its passengers on arrival.\u003c/p\u003e\n\u003ch2 id=\"input-specification\"\u003eInput Specification:\u003c/h2\u003e\n\u003cp\u003eEach input file contains one test case. For each case, the first line contains the names of the source and the destination planets, and a positive integer N (≤500). Then N lines follow, each in the format: \u003ccode\u003esource[i]\u003c/code\u003e \u003ccode\u003edestination[i]\u003c/code\u003e \u003ccode\u003ecapacity[i]\u003c/code\u003e where \u003ccode\u003esource[i]\u003c/code\u003e and \u003ccode\u003edestination[i]\u003c/code\u003e are the names of the satellites and the two involved planets, and \u003ccode\u003ecapacity[i]\u003c/code\u003e \u0026gt; 0 is the maximum number of passengers that can be transported at one pass from \u003ccode\u003esource[i]\u003c/code\u003e to \u003ccode\u003edestination[i]\u003c/code\u003e. Each name is a string of 3 uppercase characters chosen from {A-Z}, e.g., ZJU.\nNote that the satellite transportation stations have no accommodation facilities for the passengers. Therefore none of the passengers can stay. Such a station will not allow arrivals of space vessels that contain more than its own capacity. It is guaranteed that the list contains neither the routes to the source planet nor that from the destination planet.\u003c/p\u003e","title":"Universal Travel Sites"},{"content":"7-1 Hamiltonian Cycle The \u0026ldquo;Hamilton cycle problem\u0026rdquo; is to find a simple cycle that contains every vertex in a graph. Such a cycle is called a \u0026ldquo;Hamiltonian cycle\u0026rdquo;.\nIn this problem, you are supposed to tell if a given cycle is a Hamiltonian cycle.\nInput Specification: Each input file contains one test case. For each case, the first line contains 2 positive integers N (2\u0026lt;N≤200), the number of vertices, and M, the number of edges in an undirected graph. Then M lines follow, each describes an edge in the format Vertex1 Vertex2, where the vertices are numbered from 1 to N. The next line gives a positive integer K which is the number of queries, followed by K lines of queries, each in the format:\nn V1 V2 \u0026hellip; Vn\nwhere n is the number of vertices in the list, and Vi\u0026rsquo;s are the vertices on a path.\nOutput Specification: For each query, print in a line YES if the path does form a Hamiltonian cycle, or NO if not.\nSample Input: 6 10 6 2 3 4 1 5 2 5 3 1 4 1 1 6 6 3 1 2 4 5 6 7 5 1 4 3 6 2 5 6 5 1 4 3 6 2 9 6 2 1 6 3 4 5 2 6 4 1 2 5 1 7 6 1 3 4 5 2 6 7 6 1 2 5 4 3 1 Sample Output: YES NO NO NO YES NO Code #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int graph[300][300]; void graph_init(){ for(int i=0; i\u0026lt;300; i++){ for(int j=0; j\u0026lt;300; j++) graph[i][j] = 0; } } int is_seq_ok(int* seq, int size, int total_size){ if(size-1!=total_size || seq[0]!=seq[size-1] ) return 0; int node[total_size+1]; for(int i=0; i\u0026lt;total_size+1; i++) node[i] = 0; node[seq[0]] = 1; for(int i=1; i\u0026lt;size; i++){ if(i\u0026lt;size-1){ if(node[seq[i]]) return 0; node[seq[i]] = 1; } if(graph[seq[i-1]][seq[i]] == 0) { return 0; } } return 1; } int main(int argc, char *argv[]){ graph_init(); int total_size, edge_size; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;total_size, \u0026amp;edge_size); for(int i=0; i\u0026lt;edge_size; i++){ int n1, n2; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n1, \u0026amp;n2); graph[n1][n2] = 1; graph[n2][n1] = 1; } int case_count; scanf(\u0026#34;%d\u0026#34;, \u0026amp;case_count); for(int i=0; i\u0026lt;case_count; i++){ int seq_size; scanf(\u0026#34;%d\u0026#34;, \u0026amp;seq_size); int seq[seq_size]; for(int j=0; j\u0026lt;seq_size; j++){ int num; scanf(\u0026#34;%d\u0026#34;, \u0026amp;num); seq[j] = num; } if(is_seq_ok(seq, seq_size, total_size)) printf(\u0026#34;YES\\n\u0026#34;); else printf(\u0026#34;NO\\n\u0026#34;); } } ","permalink":"https://novel2430.github.io/notes/hamiltonian-cycle/","summary":"\u003ch1 id=\"7-1-hamiltonian-cycle\"\u003e7-1 Hamiltonian Cycle\u003c/h1\u003e\n\u003cp\u003eThe \u0026ldquo;Hamilton cycle problem\u0026rdquo; is to find a simple cycle that contains every vertex in a graph. Such a cycle is called a \u0026ldquo;Hamiltonian cycle\u0026rdquo;.\u003c/p\u003e\n\u003cp\u003eIn this problem, you are supposed to tell if a given cycle is a Hamiltonian cycle.\u003c/p\u003e\n\u003ch2 id=\"input-specification\"\u003eInput Specification:\u003c/h2\u003e\n\u003cp\u003eEach input file contains one test case. For each case, the first line contains 2 positive integers N (2\u0026lt;N≤200), the number of vertices, and M, the number of edges in an undirected graph. Then M lines follow, each describes an edge in the format \u003ccode\u003eVertex1 Vertex2\u003c/code\u003e, where the vertices are numbered from 1 to N. The next line gives a positive integer K which is the number of queries, followed by K lines of queries, each in the format:\u003cbr\u003e\nn V\u003csub\u003e1\u003c/sub\u003e V\u003csub\u003e2\u003c/sub\u003e \u0026hellip; V\u003csub\u003en\u003c/sub\u003e\u003cbr\u003e\nwhere n is the number of vertices in the list, and V\u003csub\u003ei\u003c/sub\u003e\u0026rsquo;s are the vertices on a path.\u003c/p\u003e","title":"Hamiltonian Cycle"},{"content":"6-1 Is Topological Order Write a program to test if a give sequence Seq is a topological order of a given graph Graph.\nFormat of functions: bool IsTopSeq( LGraph Graph, Vertex Seq[] ); where LGraph is defined as the following:\ntypedef struct AdjVNode *PtrToAdjVNode; struct AdjVNode{ Vertex AdjV; PtrToAdjVNode Next; }; typedef struct Vnode{ PtrToAdjVNode FirstEdge; } AdjList[MaxVertexNum]; typedef struct GNode *PtrToGNode; struct GNode{ int Nv; int Ne; AdjList G; }; typedef PtrToGNode LGraph; The function IsTopSeq must return true if Seq does correspond to a topological order; otherwise return false.\nNote: Although the vertices are numbered from 1 to MaxVertexNum, they are indexed from 0 in the LGraph structure.\nSample program of judge: #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef enum {false, true} bool; #define MaxVertexNum 10 /* maximum number of vertices */ typedef int Vertex; /* vertices are numbered from 1 to MaxVertexNum */ typedef struct AdjVNode *PtrToAdjVNode; struct AdjVNode{ Vertex AdjV; PtrToAdjVNode Next; }; typedef struct Vnode{ PtrToAdjVNode FirstEdge; } AdjList[MaxVertexNum]; typedef struct GNode *PtrToGNode; struct GNode{ int Nv; int Ne; AdjList G; }; typedef PtrToGNode LGraph; LGraph ReadG(); /* details omitted */ bool IsTopSeq( LGraph Graph, Vertex Seq[] ); int main() { int i, j, N; Vertex Seq[MaxVertexNum]; LGraph G = ReadG(); scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); for (i=0; i\u0026lt;N; i++) { for (j=0; j\u0026lt;G-\u0026gt;Nv; j++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;Seq[j]); if ( IsTopSeq(G, Seq)==true ) printf(\u0026#34;yes\\n\u0026#34;); else printf(\u0026#34;no\\n\u0026#34;); } return 0; } /* Your function will be put here */ Sample Input (for the graph shown in the figure): 6 8 1 2 1 3 5 2 5 4 2 3 2 6 3 4 6 4 5 1 5 2 3 6 4 5 1 2 6 3 4 5 1 2 3 6 4 5 2 1 6 3 4 1 2 3 4 5 6 Sample Output: yes yes yes no no Code #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef enum {false, true} bool; #define MaxVertexNum 10 /* maximum number of vertices */ typedef int Vertex; /* vertices are numbered from 1 to MaxVertexNum */ typedef struct AdjVNode *PtrToAdjVNode; struct AdjVNode{ Vertex AdjV; PtrToAdjVNode Next; }; typedef struct Vnode{ PtrToAdjVNode FirstEdge; } AdjList[MaxVertexNum]; typedef struct GNode *PtrToGNode; struct GNode{ int Nv; int Ne; AdjList G; }; typedef PtrToGNode LGraph; LGraph ReadG(); /* details omitted */ bool IsTopSeq( LGraph Graph, Vertex Seq[] ); int main() { int i, j, N; Vertex Seq[MaxVertexNum]; LGraph G = ReadG(); scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); for (i=0; i\u0026lt;N; i++) { for (j=0; j\u0026lt;G-\u0026gt;Nv; j++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;Seq[j]); if ( IsTopSeq(G, Seq)==true ) printf(\u0026#34;yes\\n\u0026#34;); else printf(\u0026#34;no\\n\u0026#34;); } return 0; } /* Your function will be put here */ bool IsTopSeq( LGraph Graph, Vertex Seq[] ){ int in_degree[1000]; PtrToAdjVNode t_node; for(int i=0;i\u0026lt;=Graph-\u0026gt;Nv;i++) in_degree[i]=0; for(int i=0;i\u0026lt;Graph-\u0026gt;Nv;i++){ t_node=Graph-\u0026gt;G[i].FirstEdge; while (t_node){ in_degree[t_node-\u0026gt;AdjV] = in_degree[t_node-\u0026gt;AdjV] + 1; t_node=t_node-\u0026gt;Next; } } for(int i=0;i\u0026lt;Graph-\u0026gt;Nv;i++){ if(in_degree[Seq[i]-1]!=0) return false; else{ t_node=Graph-\u0026gt;G[Seq[i]-1].FirstEdge; while(t_node){ in_degree[t_node-\u0026gt;AdjV] = in_degree[t_node-\u0026gt;AdjV] - 1; t_node=t_node-\u0026gt;Next; } } } return true; } ","permalink":"https://novel2430.github.io/notes/is-topological-order/","summary":"\u003ch1 id=\"6-1-is-topological-order\"\u003e6-1 Is Topological Order\u003c/h1\u003e\n\u003cp\u003eWrite a program to test if a give sequence \u003ccode\u003eSeq\u003c/code\u003e is a topological order of a given graph \u003ccode\u003eGraph\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"format-of-functions\"\u003eFormat of functions:\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eIsTopSeq\u003c/span\u003e( LGraph Graph, Vertex Seq[] );\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003ewhere \u003ccode\u003eLGraph\u003c/code\u003e is defined as the following:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e AdjVNode \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ePtrToAdjVNode; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e AdjVNode{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Vertex AdjV;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    PtrToAdjVNode Next;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e Vnode{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    PtrToAdjVNode FirstEdge;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e} AdjList[MaxVertexNum];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e GNode \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ePtrToGNode;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e GNode{  \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e Nv;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e Ne;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    AdjList G;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e PtrToGNode LGraph;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe function \u003ccode\u003eIsTopSeq\u003c/code\u003e must return \u003ccode\u003etrue\u003c/code\u003e if \u003ccode\u003eSeq\u003c/code\u003e does correspond to a topological order; otherwise return \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e","title":"Is Topological Order"},{"content":"7-1 File Transfer We have a network of computers and a list of bi-directional connections. Each of these connections allows a file transfer from one computer to another. Is it possible to send a file from any computer on the network to any other?\nInput Specification: Each input file contains one test case. For each test case, the first line contains N (2≤N≤104), the total number of computers in a network. Each computer in the network is then represented by a positive integer between 1 and N. Then in the following lines, the input is given in the format:\nI c1 c2 where I stands for inputting a connection between c1 and c2; or\nC c1 c2 where C stands for checking if it is possible to transfer files between c1 and c2; or\nS where S stands for stopping this case.\nOutput Specification: For each C case, print in one line the word \u0026ldquo;yes\u0026rdquo; or \u0026ldquo;no\u0026rdquo; if it is possible or impossible to transfer files between c1 and c2, respectively. At the end of each case, print in one line \u0026ldquo;The network is connected.\u0026rdquo; if there is a path between any pair of computers; or \u0026ldquo;There are k components.\u0026rdquo; where k is the number of connected components in this network.\nSample Input 1: 5 C 3 2 I 3 2 C 1 5 I 4 5 I 2 4 C 3 5 S Sample Output 1: no no yes There are 2 components. Sample Input 2: 5 C 3 2 I 3 2 C 1 5 I 4 5 I 2 4 C 3 5 I 1 3 C 1 5 S Sample Output 2: no no yes yes The network is connected. Code #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define true 1 #define false 0 typedef struct Node{ struct Node* parent; }Node ; // Node op Node* node_init(){ Node* res = (Node*)malloc(sizeof(Node)); res-\u0026gt;parent = res; return res; } Node* node_check_father(Node* node){ if(node-\u0026gt;parent == node) return node; node-\u0026gt;parent = node_check_father(node-\u0026gt;parent); return node-\u0026gt;parent; } Node* node_check_father_non_recursice(Node* node){ // find root Node* root = node; while(root-\u0026gt;parent!=root) root = root-\u0026gt;parent; // set root Node* cur = node; while(cur!=root){ Node* tmp = cur-\u0026gt;parent; cur-\u0026gt;parent = root; cur = tmp; } return root; } void node_build_connect(Node* n1, Node* n2){ if(n1==NULL || n2==NULL) return; node_check_father(n1)-\u0026gt;parent = node_check_father(n2); } int node_is_connect(Node* n1, Node* n2){ Node* n1_father = node_check_father(n1); Node* n2_father = node_check_father(n2); if(n1_father==n2_father) return true; return false; } int count_components(Node** nodes, int size){ int count = 0; for(int i=0; i\u0026lt;size; i++){ if(nodes[i]-\u0026gt;parent==nodes[i]) count++; } return count; } int main(int argc, char *argv[]){ int size; scanf(\u0026#34;%d\u0026#34;, \u0026amp;size); Node* nodes[size]; for(int i=0; i\u0026lt;size; i++) nodes[i] = node_init(); while(1){ getchar(); char op; scanf(\u0026#34;%c\u0026#34;, \u0026amp;op); if(op==\u0026#39;S\u0026#39;) break; int n1, n2; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n1, \u0026amp;n2); if(op==\u0026#39;C\u0026#39;){ if(node_is_connect(nodes[n1-1], nodes[n2-1])){ printf(\u0026#34;yes\\n\u0026#34;); } else printf(\u0026#34;no\\n\u0026#34;); } else if(op==\u0026#39;I\u0026#39;){ node_build_connect(nodes[n1-1], nodes[n2-1]); } } int count = count_components(nodes, size); if(count==1) printf(\u0026#34;The network is connected.\\n\u0026#34;); else printf(\u0026#34;There are %d components.\\n\u0026#34;, count); } ","permalink":"https://novel2430.github.io/notes/file-transfer/","summary":"\u003ch1 id=\"7-1-file-transfer\"\u003e7-1 File Transfer\u003c/h1\u003e\n\u003cp\u003eWe have a network of computers and a list of bi-directional connections. Each of these connections allows a file transfer from one computer to another. Is it possible to send a file from any computer on the network to any other?\u003c/p\u003e\n\u003ch2 id=\"input-specification\"\u003eInput Specification:\u003c/h2\u003e\n\u003cp\u003eEach input file contains one test case. For each test case, the first line contains N (2≤N≤10\u003csup\u003e4\u003c/sup\u003e), the total number of computers in a network. Each computer in the network is then represented by a positive integer between 1 and N. Then in the following lines, the input is given in the format:\u003c/p\u003e","title":"File Transfer"},{"content":"7-1 Complete Binary Search Tree A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:\nThe left subtree of a node contains only nodes with keys less than the node\u0026rsquo;s key. The right subtree of a node contains only nodes with keys greater than or equal to the node\u0026rsquo;s key. Both the left and right subtrees must also be binary search trees. A Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right. Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST.\nInput Specification: Each input file contains one test case. For each case, the first line contains a positive integer N (≤1000). Then N distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000.\nOutput Specification: For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.\nSample Input: 10 1 2 3 4 5 6 7 8 9 0 Sample Output: 6 3 8 1 5 7 9 0 2 4 Code #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // Merge Sort void merge_sort_help(int* arr, int* tmp, int low_idx, int high_idx){ if(low_idx\u0026gt;=high_idx) return; int mid = (low_idx + high_idx)/2; merge_sort_help(arr, tmp, low_idx, mid); merge_sort_help(arr, tmp, mid+1, high_idx); int start1 = low_idx; int end1 = mid; int start2 = mid+1; int end2 = high_idx; int cur_idx = start1; while(cur_idx\u0026lt;=high_idx){ if(arr[start1] \u0026lt; arr[start2] \u0026amp;\u0026amp; start1\u0026lt;=end1){ tmp[cur_idx] = arr[start1++]; } else if(arr[start1] \u0026gt;= arr[start2] \u0026amp;\u0026amp; start2\u0026lt;=end2){ tmp[cur_idx] = arr[start2++]; } else if (start1\u0026gt;end1) { tmp[cur_idx] = arr[start2++]; } else if (start2\u0026gt;end2) { tmp[cur_idx] = arr[start1++]; } cur_idx++; } for(int i=low_idx; i\u0026lt;=high_idx; i++){ arr[i] = tmp[i]; } } void merge_sort(int* arr, int size){ int* tmp = (int*)malloc(sizeof(int)*size); merge_sort_help(arr, tmp, 0, size-1); } // Build Tree Layer print void get_tree_layer_help(int* inorder, int n, int size, int* cur_idx, int* layer){ if(n\u0026gt;=size) return; get_tree_layer_help(inorder, 2*n+1, size, cur_idx, layer); layer[n] = inorder[(*cur_idx)++]; get_tree_layer_help(inorder, 2*(n+1), size, cur_idx, layer); } int* get_tree_layer(int* inorder, int size){ int* tmp = (int*)malloc(sizeof(int)*size); int base_idx = 0; get_tree_layer_help(inorder, 0, size, \u0026amp;base_idx, tmp); return tmp; } int main(int argc, char *argv[]){ int count; scanf(\u0026#34;%d\u0026#34;, \u0026amp;count); int nums[count]; for(int i=0; i\u0026lt;count; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;nums[i]); merge_sort(nums, count); int* res = get_tree_layer(nums, count); for(int i=0; i\u0026lt;count; i++){ if(i\u0026gt;0) printf(\u0026#34; \u0026#34;); printf(\u0026#34;%d\u0026#34;, res[i]); } return 0; } ","permalink":"https://novel2430.github.io/notes/complete-binart-search-tree/","summary":"\u003ch1 id=\"7-1-complete-binary-search-tree\"\u003e7-1 Complete Binary Search Tree\u003c/h1\u003e\n\u003cp\u003eA Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe left subtree of a node contains only nodes with keys less than the node\u0026rsquo;s key.\u003c/li\u003e\n\u003cli\u003eThe right subtree of a node contains only nodes with keys greater than or equal to the node\u0026rsquo;s key.\u003c/li\u003e\n\u003cli\u003eBoth the left and right subtrees must also be binary search trees.\nA Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNow given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST.\u003c/p\u003e","title":"Complete Binart Search Tree"},{"content":"6-1 Percolate Up and Down Write the routines to do a \u0026ldquo;percolate up\u0026rdquo; and a \u0026ldquo;percolate down\u0026rdquo; in a binary min-heap.\nFormat of functions: void PercolateUp( int p, PriorityQueue H ); void PercolateDown( int p, PriorityQueue H ); where int p is the position of the element, and PriorityQueue is defined as the following:\ntypedef struct HeapStruct *PriorityQueue; struct HeapStruct { ElementType *Elements; int Capacity; int Size; }; Sample program of judge: #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef int ElementType; #define MinData -1 typedef struct HeapStruct *PriorityQueue; struct HeapStruct { ElementType *Elements; int Capacity; int Size; }; PriorityQueue Initialize( int MaxElements ); /* details omitted */ void PercolateUp( int p, PriorityQueue H ); void PercolateDown( int p, PriorityQueue H ); void Insert( ElementType X, PriorityQueue H ) { int p = ++H-\u0026gt;Size; H-\u0026gt;Elements[p] = X; PercolateUp( p, H ); } ElementType DeleteMin( PriorityQueue H ) { ElementType MinElement; MinElement = H-\u0026gt;Elements[1]; H-\u0026gt;Elements[1] = H-\u0026gt;Elements[H-\u0026gt;Size--]; PercolateDown( 1, H ); return MinElement; } int main() { int n, i, op, X; PriorityQueue H; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); H = Initialize(n); for ( i=0; i\u0026lt;n; i++ ) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;op); switch( op ) { case 1: scanf(\u0026#34;%d\u0026#34;, \u0026amp;X); Insert(X, H); break; case 0: printf(\u0026#34;%d \u0026#34;, DeleteMin(H)); break; } } printf(\u0026#34;\\nInside H:\u0026#34;); for ( i=1; i\u0026lt;=H-\u0026gt;Size; i++ ) printf(\u0026#34; %d\u0026#34;, H-\u0026gt;Elements[i]); return 0; } /* Your function will be put here */ Sample Input: 9 1 10 1 5 1 2 0 1 9 1 1 1 4 0 0 Sample Output: 2 1 4 Inside H: 5 10 9 Code #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef int ElementType; #define MinData -1 typedef struct HeapStruct *PriorityQueue; struct HeapStruct { ElementType *Elements; int Capacity; int Size; }; PriorityQueue Initialize( int MaxElements ); /* details omitted */ void PercolateUp( int p, PriorityQueue H ); void PercolateDown( int p, PriorityQueue H ); void Insert( ElementType X, PriorityQueue H ) { int p = ++H-\u0026gt;Size; H-\u0026gt;Elements[p] = X; PercolateUp( p, H ); } ElementType DeleteMin( PriorityQueue H ) { ElementType MinElement; MinElement = H-\u0026gt;Elements[1]; H-\u0026gt;Elements[1] = H-\u0026gt;Elements[H-\u0026gt;Size--]; PercolateDown( 1, H ); return MinElement; } int main() { int n, i, op, X; PriorityQueue H; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); H = Initialize(n); for ( i=0; i\u0026lt;n; i++ ) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;op); switch( op ) { case 1: scanf(\u0026#34;%d\u0026#34;, \u0026amp;X); Insert(X, H); break; case 0: printf(\u0026#34;%d \u0026#34;, DeleteMin(H)); break; } } printf(\u0026#34;\\nInside H:\u0026#34;); for ( i=1; i\u0026lt;=H-\u0026gt;Size; i++ ) printf(\u0026#34; %d\u0026#34;, H-\u0026gt;Elements[i]); return 0; } /* Your function will be put here */ void swap(int pos1, int pos2, PriorityQueue H){ ElementType tmp = H-\u0026gt;Elements[pos1]; H-\u0026gt;Elements[pos1] = H-\u0026gt;Elements[pos2]; H-\u0026gt;Elements[pos2] = tmp; } int min_idx(int idx1, int idx2, PriorityQueue H){ if(H-\u0026gt;Elements[idx1] \u0026lt; H-\u0026gt;Elements[idx2]) return idx1; return idx2; } void PercolateUp( int p, PriorityQueue H ){ int pos = p; while(pos\u0026gt;1){ int parent_idx = 1; int val = H-\u0026gt;Elements[pos]; if(pos%2==0) parent_idx = pos/2; else parent_idx = (pos-1)/2; if(H-\u0026gt;Elements[parent_idx]\u0026gt;val) swap(pos, parent_idx, H); else break; pos = parent_idx; } } void PercolateDown( int p, PriorityQueue H ){ int pos = p; while(pos*2 \u0026lt;= H-\u0026gt;Size){ int val = H-\u0026gt;Elements[pos]; int child_idx = H-\u0026gt;Size; if(pos*2+1 \u0026lt;= H-\u0026gt;Size) child_idx = min_idx(pos*2, pos*2+1, H); else child_idx = pos*2; if(H-\u0026gt;Elements[child_idx] \u0026lt; val) swap(pos, child_idx, H); else break; pos = child_idx; } } ","permalink":"https://novel2430.github.io/notes/percolate-up-and-down/","summary":"\u003ch1 id=\"6-1-percolate-up-and-down\"\u003e6-1 Percolate Up and Down\u003c/h1\u003e\n\u003cp\u003eWrite the routines to do a \u0026ldquo;percolate up\u0026rdquo; and a \u0026ldquo;percolate down\u0026rdquo; in a binary min-heap.\u003c/p\u003e\n\u003ch2 id=\"format-of-functions\"\u003eFormat of functions:\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePercolateUp\u003c/span\u003e( \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e p, PriorityQueue H );\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePercolateDown\u003c/span\u003e( \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e p, PriorityQueue H );\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003ewhere \u003ccode\u003eint p\u003c/code\u003e is the position of the element, and \u003ccode\u003ePriorityQueue\u003c/code\u003e is defined as the following:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e HeapStruct \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ePriorityQueue;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e HeapStruct {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ElementType  \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eElements;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e Capacity;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e Size;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"sample-program-of-judge\"\u003eSample program of judge:\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;stdio.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;stdlib.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e ElementType;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define MinData -1\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e HeapStruct \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ePriorityQueue;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e HeapStruct {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ElementType  \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eElements;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e Capacity;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e Size;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePriorityQueue \u003cspan style=\"color:#a6e22e\"\u003eInitialize\u003c/span\u003e( \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e MaxElements ); \u003cspan style=\"color:#75715e\"\u003e/* details omitted */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePercolateUp\u003c/span\u003e( \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e p, PriorityQueue H );\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePercolateDown\u003c/span\u003e( \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e p, PriorityQueue H );\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eInsert\u003c/span\u003e( ElementType X, PriorityQueue H ) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e p \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003eH\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eSize;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[p] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e X;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ePercolateUp\u003c/span\u003e( p, H );\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eElementType \u003cspan style=\"color:#a6e22e\"\u003eDeleteMin\u003c/span\u003e( PriorityQueue H ) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{ \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ElementType MinElement; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    MinElement \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eSize\u003cspan style=\"color:#f92672\"\u003e--\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ePercolateDown\u003c/span\u003e( \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, H );\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e MinElement; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n, i, op, X;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    PriorityQueue H;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003escanf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003en);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    H \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eInitialize\u003c/span\u003e(n);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e ( i\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003en; i\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e ) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003escanf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eop);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eswitch\u003c/span\u003e( op ) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#a6e22e\"\u003escanf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eX);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#a6e22e\"\u003eInsert\u003c/span\u003e(X, H);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ebreak\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#a6e22e\"\u003eprintf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d \u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eDeleteMin\u003c/span\u003e(H));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ebreak\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eprintf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003eInside H:\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e ( i\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e; i\u003cspan style=\"color:#f92672\"\u003e\u0026lt;=\u003c/span\u003eH\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eSize; i\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e )\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003eprintf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34; %d\u0026#34;\u003c/span\u003e, H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[i]);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e/* Your function will be put here */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"sample-input\"\u003eSample Input:\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e9\n1 10\n1 5\n1 2\n0\n1 9\n1 1\n1 4\n0\n0\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"sample-output\"\u003eSample Output:\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e2 1 4 \nInside H: 5 10 9\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"code\"\u003eCode\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;stdio.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;stdlib.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e ElementType;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define MinData -1\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e HeapStruct \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ePriorityQueue;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e HeapStruct {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ElementType  \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eElements;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e Capacity;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e Size;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePriorityQueue \u003cspan style=\"color:#a6e22e\"\u003eInitialize\u003c/span\u003e( \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e MaxElements ); \u003cspan style=\"color:#75715e\"\u003e/* details omitted */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePercolateUp\u003c/span\u003e( \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e p, PriorityQueue H );\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePercolateDown\u003c/span\u003e( \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e p, PriorityQueue H );\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eInsert\u003c/span\u003e( ElementType X, PriorityQueue H ) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e p \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003eH\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eSize;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[p] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e X;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ePercolateUp\u003c/span\u003e( p, H );\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eElementType \u003cspan style=\"color:#a6e22e\"\u003eDeleteMin\u003c/span\u003e( PriorityQueue H ) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{ \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ElementType MinElement; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    MinElement \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eSize\u003cspan style=\"color:#f92672\"\u003e--\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ePercolateDown\u003c/span\u003e( \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, H );\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e MinElement; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n, i, op, X;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    PriorityQueue H;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003escanf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003en);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    H \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eInitialize\u003c/span\u003e(n);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e ( i\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003en; i\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e ) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003escanf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eop);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eswitch\u003c/span\u003e( op ) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#a6e22e\"\u003escanf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eX);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#a6e22e\"\u003eInsert\u003c/span\u003e(X, H);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ebreak\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#a6e22e\"\u003eprintf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d \u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eDeleteMin\u003c/span\u003e(H));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ebreak\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eprintf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003eInside H:\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e ( i\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e; i\u003cspan style=\"color:#f92672\"\u003e\u0026lt;=\u003c/span\u003eH\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eSize; i\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e )\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003eprintf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34; %d\u0026#34;\u003c/span\u003e, H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[i]);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e/* Your function will be put here */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eswap\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e pos1, \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e pos2, PriorityQueue H){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  ElementType tmp \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[pos1];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[pos1] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[pos2];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[pos2] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e tmp;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emin_idx\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e idx1, \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e idx2, PriorityQueue H){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e(H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[idx1] \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[idx2]) \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e idx1;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e idx2;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePercolateUp\u003c/span\u003e( \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e p, PriorityQueue H ){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e pos \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e p;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e(pos\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e parent_idx \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e val \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[pos];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e(pos\u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e) parent_idx \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e pos\u003cspan style=\"color:#f92672\"\u003e/\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e parent_idx \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e (pos\u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e)\u003cspan style=\"color:#f92672\"\u003e/\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e(H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[parent_idx]\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003eval) \u003cspan style=\"color:#a6e22e\"\u003eswap\u003c/span\u003e(pos, parent_idx, H);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ebreak\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    pos \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e parent_idx;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePercolateDown\u003c/span\u003e( \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e p, PriorityQueue H ){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e pos \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e p;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e(pos\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;=\u003c/span\u003e H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eSize){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e val \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[pos];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e child_idx \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eSize;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e(pos\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;=\u003c/span\u003e H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eSize)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      child_idx \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emin_idx\u003c/span\u003e(pos\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e, pos\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, H);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e child_idx \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e pos\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e(H\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eElements[child_idx] \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e val) \u003cspan style=\"color:#a6e22e\"\u003eswap\u003c/span\u003e(pos, child_idx, H);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ebreak\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    pos \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e child_idx;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"Percolate Up and Down"},{"content":"7-1 ZigZagging on a Tree Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences. And it is a simple standard routine to print the numbers in level-order. However, if you think the problem is too simple, then you are too naive. This time you are supposed to print the numbers in \u0026ldquo;zigzagging order\u0026rdquo; \u0026ndash; that is, starting from the root, print the numbers level-by-level, alternating between left to right and right to left. For example, for the following tree you must output: 1 11 5 8 17 12 20 15.\nInput Specification: Each input file contains one test case. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the inorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space.\nOutput Specification: For each test case, print the zigzagging sequence of the tree in a line. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.\nSample Input: 8 12 11 20 17 1 15 8 5 12 20 17 11 15 8 5 1 Sample Output: 1 11 5 8 17 12 20 15 Note 2 part\nBuild tree by inorder/preorder or inorder/postorder zig-zag print tree build tree TreeNode* build_tree(int* inorder, int* postorder, int length){ if(length==0) return NULL; int root_val = postorder[length-1]; TreeNode* res = tree_node_init(root_val); int idx = 0; // find root idx in inorder seq for(int i=0; i\u0026lt;length; i++){ if(inorder[i] == root_val){ idx = i; break; } } // split old seq to new seq (go left) int new_inorder[30]; int new_postorder[30]; for(int i=0; i\u0026lt;idx; i++) { new_inorder[i] = inorder[i]; new_postorder[i] = postorder[i]; } res-\u0026gt;left = build_tree(new_inorder, new_postorder, idx); // split old seq to new seq (go rigth) for(int i=0; i+idx+1\u0026lt;length; i++) { new_inorder[i] = inorder[i+idx+1]; } for(int i=0; i+idx\u0026lt;length-1; i++){ new_postorder[i] = postorder[i+idx]; } res-\u0026gt;right = build_tree(new_inorder, new_postorder, length-idx-1); return res; } zig-zag use 2 stack\nvoid tree_zig_zag_print(Tree* tree){ if(tree==NULL || tree-\u0026gt;top==NULL) return; my_stack* stack = stack_init(); my_stack* stack_2 = stack_init(); stack_push(stack, tree-\u0026gt;top); int flag = 0; // stop when 2 stack all empty while(!stack_is_empty(stack) || !stack_is_empty(stack_2)){ // stack1 pop, and push in stack2 while(!stack_is_empty(stack)){ TreeNode* cur = stack_pop(stack); if(flag++ \u0026gt; 0) printf(\u0026#34; \u0026#34;); printf(\u0026#34;%d\u0026#34;, cur-\u0026gt;value); if(cur-\u0026gt;right != NULL) stack_push(stack_2, cur-\u0026gt;right); if(cur-\u0026gt;left != NULL) stack_push(stack_2, cur-\u0026gt;left); } // stack2 pop, and push in stack1 while(!stack_is_empty(stack_2)){ TreeNode* cur = stack_pop(stack_2); printf(\u0026#34; %d\u0026#34;, cur-\u0026gt;value); if(cur-\u0026gt;left != NULL) stack_push(stack, cur-\u0026gt;left); if(cur-\u0026gt;right != NULL) stack_push(stack, cur-\u0026gt;right); } } stack_delete(stack); stack_delete(stack_2); } Code #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // Tree typedef struct TreeNode{ int value; struct TreeNode* left; struct TreeNode* right; } TreeNode ; typedef struct Tree { TreeNode* top; } Tree ; // Stack typedef struct stack_node{ TreeNode* values; struct stack_node* next; struct stack_node* before; }stack_node; typedef struct my_stack { stack_node* head; stack_node* top; }my_stack; // Stack \u0026amp; Stack Node op stack_node* node_init(TreeNode* val){ stack_node* node = (stack_node*)malloc(sizeof(stack_node)); node-\u0026gt;values = val; node-\u0026gt;next = NULL; node-\u0026gt;before = NULL; return node; } void node_delete(stack_node* node){ if(node==NULL) return; free(node); node = NULL; } my_stack* stack_init(){ my_stack* res = (my_stack*)malloc(sizeof(my_stack)); res-\u0026gt;head = node_init(NULL); res-\u0026gt;top = res-\u0026gt;head; return res; } void stack_delete(my_stack* stack){ if(stack==NULL) return; stack_node* cur = stack-\u0026gt;head; while(cur != NULL){ stack_node* next_node = cur-\u0026gt;next; node_delete(cur); cur = next_node; } free(stack); stack = NULL; } void stack_push(my_stack* stack, TreeNode* val){ stack_node* node = node_init(val); stack-\u0026gt;top-\u0026gt;next = node; node-\u0026gt;before = stack-\u0026gt;top; stack-\u0026gt;top = node; } TreeNode* stack_pop(my_stack* stack){ TreeNode* res = stack-\u0026gt;top-\u0026gt;values; stack_node* old_top = stack-\u0026gt;top; stack_node* new_top = stack-\u0026gt;top-\u0026gt;before; node_delete(old_top); stack-\u0026gt;top = new_top; stack-\u0026gt;top-\u0026gt;next = NULL; return res; } int stack_is_empty(my_stack* stack){ if(stack==NULL || stack-\u0026gt;head!=stack-\u0026gt;top){ return 0; } return 1; } // Tree \u0026amp; Tree Node op TreeNode* tree_node_init(int num){ TreeNode* res = (TreeNode*)malloc(sizeof(TreeNode)); res-\u0026gt;value = num; res-\u0026gt;left = NULL; res-\u0026gt;right = NULL; return res; } void tree_node_delete(TreeNode* node){ if(node == NULL) return; free(node); node = NULL; } Tree* tree_init(){ Tree* res = (Tree*)malloc(sizeof(Tree)); res-\u0026gt;top = NULL; return res; } void tree_delete_help(TreeNode* node){ if(node == NULL) return; tree_delete_help(node-\u0026gt;left); tree_delete_help(node-\u0026gt;right); free(node); node = NULL; } void tree_delete(Tree* tree){ if(tree==NULL) return; TreeNode* cur = tree-\u0026gt;top; tree_delete_help(cur); } void tree_zig_zag_print(Tree* tree){ if(tree==NULL || tree-\u0026gt;top==NULL) return; my_stack* stack = stack_init(); my_stack* stack_2 = stack_init(); stack_push(stack, tree-\u0026gt;top); int flag = 0; while(!stack_is_empty(stack) || !stack_is_empty(stack_2)){ while(!stack_is_empty(stack)){ TreeNode* cur = stack_pop(stack); if(flag++ \u0026gt; 0) printf(\u0026#34; \u0026#34;); printf(\u0026#34;%d\u0026#34;, cur-\u0026gt;value); if(cur-\u0026gt;right != NULL) stack_push(stack_2, cur-\u0026gt;right); if(cur-\u0026gt;left != NULL) stack_push(stack_2, cur-\u0026gt;left); } while(!stack_is_empty(stack_2)){ TreeNode* cur = stack_pop(stack_2); printf(\u0026#34; %d\u0026#34;, cur-\u0026gt;value); if(cur-\u0026gt;left != NULL) stack_push(stack, cur-\u0026gt;left); if(cur-\u0026gt;right != NULL) stack_push(stack, cur-\u0026gt;right); } } stack_delete(stack); stack_delete(stack_2); } TreeNode* build_tree(int* inorder, int* postorder, int length){ if(length==0) return NULL; int root_val = postorder[length-1]; TreeNode* res = tree_node_init(root_val); int idx = 0; for(int i=0; i\u0026lt;length; i++){ if(inorder[i] == root_val){ idx = i; break; } } int new_inorder[30]; int new_postorder[30]; for(int i=0; i\u0026lt;idx; i++) { new_inorder[i] = inorder[i]; new_postorder[i] = postorder[i]; } res-\u0026gt;left = build_tree(new_inorder, new_postorder, idx); for(int i=0; i+idx+1\u0026lt;length; i++) { new_inorder[i] = inorder[i+idx+1]; } for(int i=0; i+idx\u0026lt;length-1; i++){ new_postorder[i] = postorder[i+idx]; } res-\u0026gt;right = build_tree(new_inorder, new_postorder, length-idx-1); return res; } int main(){ Tree* tree = tree_init(); int node_num; scanf(\u0026#34;%d\u0026#34;, \u0026amp;node_num); int inorder[31]; int postorder[31]; for(int i=0; i\u0026lt;node_num; i++){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;inorder[i]); } for(int i=0; i\u0026lt;node_num; i++){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;postorder[i]); } tree-\u0026gt;top = build_tree(inorder, postorder, node_num); tree_zig_zag_print(tree); tree_delete(tree); } ","permalink":"https://novel2430.github.io/notes/zig-zagging-on-a-tree/","summary":"\u003ch1 id=\"7-1-zigzagging-on-a-tree\"\u003e7-1 ZigZagging on a Tree\u003c/h1\u003e\n\u003cp\u003eSuppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences. And it is a simple standard routine to print the numbers in level-order. However, if you think the problem is too simple, then you are too naive. This time you are supposed to print the numbers in \u0026ldquo;zigzagging order\u0026rdquo; \u0026ndash; that is, starting from the root, print the numbers level-by-level, alternating between left to right and right to left. For example, for the following tree you must output: 1 11 5 8 17 12 20 15.\u003c/p\u003e","title":"Zig Zagging on a Tree"},{"content":"6-1 Isomorphic Two trees, T1 and T2, are isomorphic if T1 can be transformed into T2 by swapping left and right children of (some of the) nodes in T1. For instance, the two trees in Figure 1 are isomorphic because they are the same if the children of A, B, and G, but not the other nodes, are swapped. Give a polynomial time algorithm to decide if two trees are isomorphic.\nFormat of functions: int Isomorphic( Tree T1, Tree T2 ); where Tree is defined as the following:\ntypedef struct TreeNode *Tree; struct TreeNode { ElementType Element; Tree Left; Tree Right; }; The function is supposed to return 1 if T1 and T2 are indeed isomorphic, or 0 if not.\nSample program of judge: #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef char ElementType; typedef struct TreeNode *Tree; struct TreeNode { ElementType Element; Tree Left; Tree Right; }; Tree BuildTree(); /* details omitted */ int Isomorphic( Tree T1, Tree T2 ); int main() { Tree T1, T2; T1 = BuildTree(); T2 = BuildTree(); printf(“%d\\n”, Isomorphic(T1, T2)); return 0; } /* Your function will be put here */ Sample Output 1 (for the trees shown in Figure 1): 1 Sample Output 2 (for the trees shown in Figure 2): 0 Note main part : check each node\u0026rsquo;s children situation\nCode #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef char ElementType; typedef struct TreeNode *Tree; struct TreeNode { ElementType Element; Tree Left; Tree Right; }; Tree BuildTree(); /* details omitted */ int Isomorphic( Tree T1, Tree T2 ); int checkValue(Tree n1, Tree n2){ if(n1!=NULL \u0026amp;\u0026amp; n2!=NULL \u0026amp;\u0026amp; n1-\u0026gt;Element==n2-\u0026gt;Element) return 1; if(n1==NULL \u0026amp;\u0026amp; n2==NULL) return 1; return 0; } int checkChild(Tree n1, Tree n2){ Tree n1_left = n1-\u0026gt;Left; Tree n1_right = n1-\u0026gt;Right; Tree n2_left = n2-\u0026gt;Left; Tree n2_right = n2-\u0026gt;Right; if(checkValue(n1_left, n2_left) \u0026amp;\u0026amp; checkValue(n1_right, n2_right)) return 1; // same if(checkValue(n1_left, n2_right) \u0026amp;\u0026amp; checkValue(n1_right, n2_left)) return 2; // same with swap return 0; // not same } int Isomorphic_help( Tree T1, Tree T2 ){ if(T1==NULL \u0026amp;\u0026amp; T2==NULL) return 1; int situation = checkChild(T1, T2); if(situation==1){ int r1 = Isomorphic_help(T1-\u0026gt;Left, T2-\u0026gt;Left); int r2 = Isomorphic_help(T1-\u0026gt;Right, T2-\u0026gt;Right); return r1*r2; } else if(situation==2){ int r1 = Isomorphic_help(T1-\u0026gt;Left, T2-\u0026gt;Right); int r2 = Isomorphic_help(T1-\u0026gt;Right, T2-\u0026gt;Left); return r1*r2; } else{ return 0; } } int Isomorphic( Tree T1, Tree T2 ){ int res = checkValue(T1, T2); if(res==0) return 0; return Isomorphic_help(T1, T2); } int main() { Tree T1, T2; /* T1 = BuildTree(); */ /* T2 = BuildTree(); */ printf(\u0026#34;%d\\n\u0026#34;, Isomorphic(T1, T2)); return 0; } /* Your function will be put here */ ","permalink":"https://novel2430.github.io/notes/isomorphic/","summary":"\u003ch1 id=\"6-1-isomorphic\"\u003e6-1 Isomorphic\u003c/h1\u003e\n\u003cp\u003eTwo trees, \u003ccode\u003eT1\u003c/code\u003e and \u003ccode\u003eT2\u003c/code\u003e, are isomorphic if \u003ccode\u003eT1\u003c/code\u003e can be transformed into \u003ccode\u003eT2\u003c/code\u003e by swapping left and right children of (some of the) nodes in \u003ccode\u003eT1\u003c/code\u003e. For instance, the two trees in Figure 1 are isomorphic because they are the same if the children of A, B, and G, but not the other nodes, are swapped. Give a polynomial time algorithm to decide if two trees are isomorphic.\u003c/p\u003e","title":"Isomorphic"},{"content":"7-1 Pop Sequence Given a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, \u0026hellip;, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.\nInput Specification: Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M (the maximum capacity of the stack), N (the length of push sequence), and K (the number of pop sequences to be checked). Then K lines follow, each contains a pop sequence of N numbers. All the numbers in a line are separated by a space.\nOutput Specification: For each pop sequence, print in one line YES if it is indeed a possible pop sequence of the stack, or NO if not.\nSample Input: 5 7 5 1 2 3 4 5 6 7 3 2 1 7 5 6 4 7 6 5 4 3 2 1 5 6 4 3 7 2 1 1 7 6 5 4 3 2 Sample Output: YES NO NO YES NO Code: #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // Basic Struct typedef struct stack_node{ int values; struct stack_node* next; struct stack_node* before; }stack_node; typedef struct my_stack { stack_node* head; stack_node* top; }my_stack ; // Node op stack_node* node_init(int num){ stack_node* node = (stack_node*)malloc(sizeof(stack_node)); node-\u0026gt;values = num; node-\u0026gt;next = NULL; node-\u0026gt;before = NULL; return node; } void node_delete(stack_node* node){ if(node==NULL) return; free(node); node = NULL; } // Stack op my_stack* stack_init(){ my_stack* res = (my_stack*)malloc(sizeof(my_stack)); res-\u0026gt;head = node_init(0); res-\u0026gt;top = res-\u0026gt;head; return res; } void stack_delete(my_stack* stack){ if(stack==NULL) return; stack_node* cur = stack-\u0026gt;head; while(cur != NULL){ stack_node* next_node = cur-\u0026gt;next; node_delete(cur); cur = next_node; } free(stack); stack = NULL; } void stack_push(my_stack* stack, int num){ stack-\u0026gt;head-\u0026gt;values++; stack_node* node = node_init(num); stack-\u0026gt;top-\u0026gt;next = node; node-\u0026gt;before = stack-\u0026gt;top; stack-\u0026gt;top = node; } int stack_pop(my_stack* stack){ stack-\u0026gt;head-\u0026gt;values--; int res = stack-\u0026gt;top-\u0026gt;values; stack_node* old_top = stack-\u0026gt;top; stack_node* new_top = stack-\u0026gt;top-\u0026gt;before; node_delete(old_top); stack-\u0026gt;top = new_top; stack-\u0026gt;top-\u0026gt;next = NULL; return res; } int stack_is_empty(my_stack* stack){ if(stack==NULL || stack-\u0026gt;head!=stack-\u0026gt;top){ return 0; } return 1; } int main(){ int max_length, max_num, seq_count; scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;max_length, \u0026amp;max_num, \u0026amp;seq_count); // build test int test[seq_count][max_num]; for(int i=0; i\u0026lt;seq_count; i++){ for(int j=0; j\u0026lt;max_num; j++){ int cur_num; scanf(\u0026#34;%d\u0026#34;, \u0026amp;cur_num); test[i][j] = cur_num; } } // do test for(int i=0; i\u0026lt;seq_count; i++){ my_stack* stack = stack_init(); int idx = 1; for(int j=0; j\u0026lt;max_num; j++){ int now_num = test[i][j]; for(;idx\u0026lt;=now_num \u0026amp;\u0026amp; stack-\u0026gt;head-\u0026gt;values\u0026lt;max_length; idx++){ stack_push(stack, idx); } if(stack-\u0026gt;top!=stack-\u0026gt;head \u0026amp;\u0026amp; stack-\u0026gt;top-\u0026gt;values==now_num){ stack_pop(stack); } else break; } if(i\u0026gt;0) printf(\u0026#34;\\n\u0026#34;); if(stack_is_empty(stack)) printf(\u0026#34;YES\u0026#34;); else printf(\u0026#34;NO\u0026#34;); stack_delete(stack); } } ","permalink":"https://novel2430.github.io/notes/pop-sequence/","summary":"\u003ch1 id=\"7-1-pop-sequence\"\u003e7-1 Pop Sequence\u003c/h1\u003e\n\u003cp\u003eGiven a stack which can keep \u003ccode\u003eM\u003c/code\u003e numbers at most. Push \u003ccode\u003eN\u003c/code\u003e numbers in the order of 1, 2, 3, \u0026hellip;, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if \u003ccode\u003eM\u003c/code\u003e is 5 and \u003ccode\u003eN\u003c/code\u003e is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.\u003c/p\u003e","title":"Pop Sequence"}]